{"version":3,"file":"hyper.umd.cjs","sources":["../src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts","../src/datastar/engine/consts.ts","../src/datastar/utils/dom.ts","../src/datastar/utils/paths.ts","../src/datastar/utils/text.ts","../src/datastar/engine/errors.ts","../src/datastar/engine/types.ts","../src/datastar/engine/engine.ts","../src/datastar/plugins/actions/peek.ts","../src/datastar/plugins/actions/setAll.ts","../src/datastar/plugins/actions/toggleAll.ts","../src/hyper-ext/plugins/actions/dispatch.ts","../src/hyper-ext/plugins/actions/fileUrl.ts","../src/datastar/plugins/attributes/attr.ts","../src/datastar/plugins/attributes/bind.ts","../src/datastar/plugins/attributes/class.ts","../src/datastar/plugins/attributes/computed.ts","../src/datastar/plugins/attributes/effect.ts","../src/datastar/plugins/backend/shared.ts","../src/datastar/plugins/attributes/indicator.ts","../src/datastar/plugins/attributes/jsonSignals.ts","../src/datastar/utils/tags.ts","../src/datastar/utils/timing.ts","../src/datastar/utils/view-transitions.ts","../src/datastar/plugins/attributes/on.ts","../src/datastar/plugins/attributes/onIntersect.ts","../src/datastar/plugins/attributes/onInterval.ts","../src/datastar/plugins/attributes/onLoad.ts","../src/datastar/plugins/attributes/onSignalPatch.ts","../src/datastar/plugins/attributes/ref.ts","../src/datastar/plugins/attributes/show.ts","../src/datastar/plugins/attributes/signals.ts","../src/datastar/plugins/attributes/style.ts","../src/datastar/plugins/attributes/text.ts","../src/hyper-ext/plugins/attributes/error.ts","../src/hyper-ext/plugins/attributes/for.ts","../src/hyper-ext/plugins/attributes/if.ts","../src/datastar/plugins/backend/actions/fetch.ts","../src/datastar/plugins/backend/actions/delete.ts","../src/datastar/plugins/backend/actions/get.ts","../src/datastar/plugins/backend/actions/patch.ts","../src/datastar/plugins/backend/actions/post.ts","../src/datastar/plugins/backend/actions/put.ts","../src/hyper-ext/utils/csrf.ts","../src/hyper-ext/plugins/backend/actions/fetch-laravel.ts","../src/hyper-ext/plugins/backend/actions/postx.ts","../src/hyper-ext/plugins/backend/actions/putx.ts","../src/hyper-ext/plugins/backend/actions/patchx.ts","../src/hyper-ext/plugins/backend/actions/deletex.ts","../src/hyper-ext/plugins/backend/actions/navigate.ts","../src/datastar/plugins/backend/watchers/patchElements.ts","../src/datastar/plugins/backend/watchers/patchSignals.ts","../src/hyper-ext/plugins/backend/watchers/popstateHandler.ts","../src/hyper-ext/plugins/backend/watchers/globalNavigate.ts","../src/hyper-ext/plugins/attributes/navigate.ts","../src/hyper-ext/bundles/hyper.ts"],"sourcesContent":["// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts\n// Icon: material-symbols:intercept\n// Slug: Essential Laravel behavior handling - production ready.\n// Description: Handles redirects, exceptions, dd/dump with proper Hyper response detection.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\nexport const ResponseInterceptor: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"responseInterceptor\",\n    onGlobalInit: () => {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const [resource, init] = args;\n            const requestUrl = getUrlFromResource(resource);\n\n            // Skip intercepting certain URLs to prevent infinite loops\n            if (shouldSkipUrl(requestUrl)) {\n                return originalFetch(...args);\n            }\n\n            // Check if this is a Datastar request\n            const isDatastarRequest =\n                (init?.headers as Record<string, string>)?.[\n                    \"Datastar-Request\"\n                ] === \"true\" ||\n                (init?.headers as Headers)?.get?.(\"Datastar-Request\") ===\n                    \"true\";\n\n            try {\n                const response = await originalFetch(...args);\n\n                // CRITICAL: Check for Laravel redirects FIRST, before any other detection\n                if (isRedirectResponse(response, requestUrl)) {\n                    const redirectUrl = getRedirectUrl(response);\n                    if (redirectUrl && redirectUrl !== window.location.href) {\n                        window.location.href = redirectUrl; // Full page redirect\n                        return new Response(\"\", { status: 204 });\n                    }\n                }\n\n                // Always let Datastar requests pass through\n                if (isDatastarRequest) {\n                    return response;\n                }\n\n                // Detect Hyper responses\n                const isHyperResponse =\n                    response.headers.get(\"X-Hyper-Response\") === \"true\";\n                const isSSEResponse = response.headers\n                    .get(\"Content-Type\")\n                    ?.includes(\"text/event-stream\");\n                const hasDatastarEvent =\n                    (response.headers\n                        .get(\"Content-Type\")\n                        ?.includes(\"text/event-stream\") &&\n                        response.url.includes(\"datastar\")) ||\n                    response.headers.get(\"event\")?.startsWith(\"datastar-\");\n\n                // Let Datastar handle its own responses\n                if (isHyperResponse || isSSEResponse || hasDatastarEvent) {\n                    return response;\n                }\n\n                // Handle Laravel responses (errors, dd/dump, etc.)\n                try {\n                    await handleLaravelResponse(response, requestUrl);\n                } catch (error) {\n                    if (error instanceof RedirectHandled) {\n                        return new Response(\"\", { status: 204 });\n                    }\n                    throw error;\n                }\n\n                return new Response(\"\", { status: 200 });\n            } catch (error) {\n                if (!(error instanceof RedirectHandled)) {\n                    console.error(\"Network error:\", error);\n                }\n                throw error;\n            }\n        };\n    },\n};\n\n// Custom error class for cleaner flow control\nclass RedirectHandled extends Error {\n    constructor() {\n        super(\"Redirect handled\");\n        this.name = \"RedirectHandled\";\n    }\n}\n\nfunction getUrlFromResource(resource: RequestInfo | URL): string {\n    if (typeof resource === \"string\") return resource;\n    if (resource instanceof URL) return resource.href;\n    if (resource instanceof Request) return resource.url;\n    return String(resource);\n}\n\nfunction shouldSkipUrl(url: string): boolean {\n    // Skip Laravel Boost, debugging tools, and other internal requests\n    const skipPatterns = [\n        \"_boost/browser-logs\",\n        \"_boost/\",\n        \"_debugbar/\",\n        \"_ignition/\",\n        \"telescope/\",\n        \"horizon/\",\n        \".js\",\n        \".css\",\n        \".png\",\n        \".jpg\",\n        \".jpeg\",\n        \".gif\",\n        \".svg\",\n        \".ico\",\n        \".woff\",\n        \".woff2\",\n        \".ttf\",\n        \".eot\",\n    ];\n\n    return skipPatterns.some((pattern) => url.includes(pattern));\n}\n\nasync function handleLaravelResponse(\n    response: Response,\n    requestUrl: string\n): Promise<void> {\n    // Handle redirects first\n    if (isRedirectResponse(response, requestUrl)) {\n        const redirectUrl = getRedirectUrl(response);\n        if (redirectUrl && redirectUrl !== window.location.href) {\n            window.location.replace(redirectUrl);\n            throw new RedirectHandled();\n        }\n        return;\n    }\n\n    // Handle error responses and dd/dump\n    if (response.status >= 400) {\n        const html = await response.text();\n        if (isLaravelSpecialResponse(html)) {\n            replaceDocument(html);\n        }\n        return;\n    }\n\n    // Handle successful HTML responses\n    const contentType = response.headers.get(\"Content-Type\") || \"\";\n    if (contentType.includes(\"text/html\")) {\n        const html = await response.text();\n        if (isLaravelSpecialResponse(html)) {\n            replaceDocument(html);\n        }\n    }\n}\n\nfunction isRedirectResponse(response: Response, originalUrl: string): boolean {\n    return (\n        [301, 302, 303, 307, 308].includes(response.status) ||\n        (response.url && response.url !== originalUrl) ||\n        !!response.headers.get(\"Location\")\n    );\n}\n\nfunction getRedirectUrl(response: Response): string | null {\n    let redirectUrl = response.url || response.headers.get(\"Location\");\n\n    if (!redirectUrl) return null;\n\n    // Make relative URLs absolute\n    if (redirectUrl.startsWith(\"/\")) {\n        redirectUrl = window.location.origin + redirectUrl;\n    }\n\n    return redirectUrl;\n}\n\nfunction isLaravelSpecialResponse(html: string): boolean {\n    // Laravel error pages (Ignition, Whoops)\n    if (\n        html.includes(\"ignition-\") ||\n        html.includes(\"data-ignition\") ||\n        html.includes(\"Whoops\\\\\") ||\n        html.includes(\"whoops-container\") ||\n        (html.includes(\"Illuminate\\\\\") && html.includes(\"Exception\"))\n    ) {\n        return true;\n    }\n\n    // Laravel dd/dump responses\n    if (\n        html.includes(\"sf-dump\") ||\n        html.includes(\"var-dump\") ||\n        html.includes(\"symfony-var-dumper\") ||\n        html.includes(\"dump-container\")\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction replaceDocument(html: string): void {\n    try {\n        // Modern approach: Parse HTML and replace document content\n        const parser = new DOMParser();\n        const newDoc = parser.parseFromString(html, \"text/html\");\n\n        // Replace the entire document\n        document.documentElement.innerHTML = newDoc.documentElement.innerHTML;\n\n        // Update document title if it exists in the new content\n        if (newDoc.title) {\n            document.title = newDoc.title;\n        }\n\n        executeNewScripts();\n    } catch (error) {\n        console.error(\"Failed to replace document:\", error);\n        window.location.reload();\n    }\n}\n\nfunction executeNewScripts(): void {\n    const scripts = document.querySelectorAll(\"script:not([data-executed])\");\n\n    scripts.forEach((element) => {\n        const oldScript = element as HTMLScriptElement;\n        oldScript.setAttribute(\"data-executed\", \"true\");\n\n        const newScript = document.createElement(\"script\");\n        Array.from(oldScript.attributes).forEach((attr) => {\n            newScript.setAttribute(attr.name, attr.value);\n        });\n\n        if (oldScript.src) {\n            newScript.src = oldScript.src;\n        } else {\n            newScript.textContent = oldScript.textContent;\n        }\n\n        if (oldScript.parentNode) {\n            oldScript.parentNode.replaceChild(newScript, oldScript);\n        }\n    });\n}\n","// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /🖕JS_DS🚀/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion","import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n","export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n","import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n","import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(ctx: InitContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n","import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  returnsValue?: boolean // If the expression returns a value\n  shouldEvaluate?: boolean // If the value should be evaluated\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T | undefined // get a value from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n  initErr: (reason: string, metadata?: object) => Error\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp | string\n  exclude?: RegExp | string\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n","import { isHTMLOrSVG } from \"../utils/dom\";\nimport { isEmpty, isPojo, pathToObj } from \"../utils/paths\";\nimport { camel, snake } from \"../utils/text\";\nimport { DATASTAR, DSP, DSS } from \"./consts\";\nimport { initErr, runtimeErr } from \"./errors\";\nimport type {\n    ActionPlugins,\n    AttributePlugin,\n    Computed,\n    DatastarPlugin,\n    Effect,\n    HTMLOrSVG,\n    InitContext,\n    JSONPatch,\n    OnRemovalFn,\n    RuntimeContext,\n    RuntimeExpressionFunction,\n    Signal,\n    SignalFilterOptions,\n} from \"./types\";\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from \"./types\";\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n    deps_?: Link;\n    depsTail_?: Link;\n    subs_?: Link;\n    subsTail_?: Link;\n    flags_: ReactiveFlags;\n}\n\ninterface Link {\n    dep_: ReactiveNode;\n    sub_: ReactiveNode;\n    prevSub_?: Link;\n    nextSub_?: Link;\n    prevDep_?: Link;\n    nextDep_?: Link;\n}\n\ninterface Stack<T> {\n    value_: T;\n    prev_?: Stack<T>;\n}\n\nenum ReactiveFlags {\n    None = 0,\n    Mutable = 1 << 0,\n    Watching = 1 << 1,\n    RecursedCheck = 1 << 2,\n    Recursed = 1 << 3,\n    Dirty = 1 << 4,\n    Pending = 1 << 5,\n}\n\nenum EffectFlags {\n    Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n    fn_(): void;\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n    value_?: T;\n    getter(previousValue?: T): T;\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n    previousValue: T;\n    value_: T;\n}\n\nlet currentPatch: Record<string, any> = {};\nconst queuedEffects: (AlienEffect | undefined)[] = [];\nlet batchDepth = 0;\nlet notifyIndex = 0;\nlet queuedEffectsLength = 0;\nlet activeSub: ReactiveNode | undefined;\n\nconst startBatch = (): void => {\n    batchDepth++;\n};\n\nconst endBatch = (): void => {\n    if (!--batchDepth) {\n        flush();\n        dispatch();\n    }\n};\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n    return signalOper.bind(0, {\n        previousValue: initialValue,\n        value_: initialValue,\n        flags_: 1 satisfies ReactiveFlags.Mutable,\n    }) as Signal<T>;\n};\n\nconst computedSymbol = Symbol(\"computed\");\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n    const c = computedOper.bind(0, {\n        flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n        getter,\n    }) as Computed<T>;\n    // @ts-ignore\n    c[computedSymbol] = 1;\n    return c;\n};\n\nconst effect = (fn: () => void): Effect => {\n    const e: AlienEffect = {\n        fn_: fn,\n        flags_: 2 satisfies ReactiveFlags.Watching,\n    };\n    if (activeSub) {\n        link(e, activeSub);\n    }\n    const prev = setCurrentSub(e);\n    startBatch();\n    try {\n        e.fn_();\n    } finally {\n        endBatch();\n        setCurrentSub(prev);\n    }\n    return effectOper.bind(0, e);\n};\n\nconst peek = <T>(fn: () => T): T => {\n    const prev = setCurrentSub(undefined);\n    try {\n        return fn();\n    } finally {\n        setCurrentSub(prev);\n    }\n};\n\nconst flush = () => {\n    while (notifyIndex < queuedEffectsLength) {\n        const effect = queuedEffects[notifyIndex]!;\n        queuedEffects[notifyIndex++] = undefined;\n        run(effect, (effect.flags_ &= ~EffectFlags.Queued));\n    }\n    notifyIndex = 0;\n    queuedEffectsLength = 0;\n};\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n    if (\"getter\" in signal) {\n        return updateComputed(signal);\n    }\n    return updateSignal(signal, signal.value_);\n};\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n    const prevSub = activeSub;\n    activeSub = sub;\n    return prevSub;\n};\n\nconst updateComputed = (c: AlienComputed): boolean => {\n    const prevSub = setCurrentSub(c);\n    startTracking(c);\n    try {\n        const oldValue = c.value_;\n        return oldValue !== (c.value_ = c.getter(oldValue));\n    } finally {\n        setCurrentSub(prevSub);\n        endTracking(c);\n    }\n};\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n    s.flags_ = 1 satisfies ReactiveFlags.Mutable;\n    return s.previousValue !== (s.previousValue = value);\n};\n\nconst notify = (e: AlienEffect): void => {\n    const flags = e.flags_;\n    if (!(flags & EffectFlags.Queued)) {\n        e.flags_ = flags | EffectFlags.Queued;\n        const subs = e.subs_;\n        if (subs) {\n            notify(subs.sub_ as AlienEffect);\n        } else {\n            queuedEffects[queuedEffectsLength++] = e;\n        }\n    }\n};\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n    if (\n        flags & (16 satisfies ReactiveFlags.Dirty) ||\n        (flags & (32 satisfies ReactiveFlags.Pending) &&\n            checkDirty(e.deps_!, e))\n    ) {\n        const prev = setCurrentSub(e);\n        startTracking(e);\n        startBatch();\n        try {\n            e.fn_();\n        } finally {\n            endBatch();\n            setCurrentSub(prev);\n            endTracking(e);\n        }\n        return;\n    }\n    if (flags & (32 satisfies ReactiveFlags.Pending)) {\n        e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending);\n    }\n    let link = e.deps_;\n    while (link) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        if (depFlags & EffectFlags.Queued) {\n            run(\n                dep as AlienEffect,\n                (dep.flags_ = depFlags & ~EffectFlags.Queued)\n            );\n        }\n        link = link.nextDep_;\n    }\n};\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n    const flags = c.flags_;\n    if (\n        flags & (16 satisfies ReactiveFlags.Dirty) ||\n        (flags & (32 satisfies ReactiveFlags.Pending) &&\n            checkDirty(c.deps_!, c))\n    ) {\n        if (updateComputed(c)) {\n            const subs = c.subs_;\n            if (subs) {\n                shallowPropagate(subs);\n            }\n        }\n    } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n        c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending);\n    }\n    if (activeSub) {\n        link(c, activeSub);\n    }\n    return c.value_!;\n};\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n    if (value.length) {\n        const newValue = value[0];\n        if (s.value_ !== (s.value_ = newValue)) {\n            s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty;\n            const subs = s.subs_;\n            if (subs) {\n                propagate(subs);\n                if (!batchDepth) {\n                    flush();\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const currentValue = s.value_;\n    if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n        if (updateSignal(s, currentValue)) {\n            const subs_ = s.subs_;\n            if (subs_) {\n                shallowPropagate(subs_);\n            }\n        }\n    }\n    if (activeSub) {\n        link(s, activeSub);\n    }\n    return currentValue;\n};\n\nconst effectOper = (e: AlienEffect): void => {\n    let dep = e.deps_;\n    while (dep) {\n        dep = unlink(dep, e);\n    }\n    const sub = e.subs_;\n    if (sub) {\n        unlink(sub);\n    }\n    e.flags_ = 0 satisfies ReactiveFlags.None;\n};\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n    const prevDep = sub.depsTail_;\n    if (prevDep && prevDep.dep_ === dep) {\n        return;\n    }\n    let nextDep: Link | undefined;\n    const recursedCheck =\n        sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck);\n    if (recursedCheck) {\n        nextDep = prevDep ? prevDep.nextDep_ : sub.deps_;\n        if (nextDep && nextDep.dep_ === dep) {\n            sub.depsTail_ = nextDep;\n            return;\n        }\n    }\n    const prevSub = dep.subsTail_;\n    if (\n        prevSub &&\n        prevSub.sub_ === sub &&\n        (!recursedCheck || isValidLink(prevSub, sub))\n    ) {\n        return;\n    }\n    const newLink =\n        (sub.depsTail_ =\n        dep.subsTail_ =\n            {\n                dep_: dep,\n                sub_: sub,\n                prevDep_: prevDep,\n                nextDep_: nextDep,\n                prevSub_: prevSub,\n            });\n    if (nextDep) {\n        nextDep.prevDep_ = newLink;\n    }\n    if (prevDep) {\n        prevDep.nextDep_ = newLink;\n    } else {\n        sub.deps_ = newLink;\n    }\n    if (prevSub) {\n        prevSub.nextSub_ = newLink;\n    } else {\n        dep.subs_ = newLink;\n    }\n};\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n    const dep_ = link.dep_;\n    const prevDep_ = link.prevDep_;\n    const nextDep_ = link.nextDep_;\n    const nextSub_ = link.nextSub_;\n    const prevSub_ = link.prevSub_;\n    if (nextDep_) {\n        nextDep_.prevDep_ = prevDep_;\n    } else {\n        sub_.depsTail_ = prevDep_;\n    }\n    if (prevDep_) {\n        prevDep_.nextDep_ = nextDep_;\n    } else {\n        sub_.deps_ = nextDep_;\n    }\n    if (nextSub_) {\n        nextSub_.prevSub_ = prevSub_;\n    } else {\n        dep_.subsTail_ = prevSub_;\n    }\n    if (prevSub_) {\n        prevSub_.nextSub_ = nextSub_;\n    } else if (!(dep_.subs_ = nextSub_)) {\n        if (\"getter\" in dep_) {\n            let toRemove = dep_.deps_;\n            if (toRemove) {\n                dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty;\n                do {\n                    toRemove = unlink(toRemove, dep_);\n                } while (toRemove);\n            }\n        } else if (!(\"previousValue\" in dep_)) {\n            effectOper(dep_ as AlienEffect);\n        }\n    }\n    return nextDep_;\n};\n\nconst propagate = (link: Link): void => {\n    let next = link.nextSub_;\n    let stack: Stack<Link | undefined> | undefined;\n\n    top: while (true) {\n        const sub = link.sub_;\n\n        let flags = sub.flags_;\n\n        if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n            if (\n                !(\n                    flags &\n                    (60 as\n                        | ReactiveFlags.RecursedCheck\n                        | ReactiveFlags.Recursed\n                        | ReactiveFlags.Dirty\n                        | ReactiveFlags.Pending)\n                )\n            ) {\n                sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending);\n            } else if (\n                !(\n                    flags &\n                    (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed)\n                )\n            ) {\n                flags = 0 satisfies ReactiveFlags.None;\n            } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n                sub.flags_ =\n                    (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n                    (32 satisfies ReactiveFlags.Pending);\n            } else if (\n                !(\n                    flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)\n                ) &&\n                isValidLink(link, sub)\n            ) {\n                sub.flags_ =\n                    flags |\n                    (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending);\n                flags &= 1 satisfies ReactiveFlags.Mutable;\n            } else {\n                flags = 0 satisfies ReactiveFlags.None;\n            }\n\n            if (flags & (2 satisfies ReactiveFlags.Watching)) {\n                notify(sub as AlienEffect);\n            }\n\n            if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n                const subSubs = sub.subs_;\n                if (subSubs) {\n                    link = subSubs;\n                    if (subSubs.nextSub_) {\n                        stack = { value_: next, prev_: stack };\n                        next = link.nextSub_;\n                    }\n                    continue;\n                }\n            }\n        }\n\n        if ((link = next!)) {\n            next = link.nextSub_;\n            continue;\n        }\n\n        while (stack) {\n            link = stack.value_!;\n            stack = stack.prev_;\n            if (link) {\n                next = link.nextSub_;\n                continue top;\n            }\n        }\n\n        break;\n    }\n};\n\nconst startTracking = (sub: ReactiveNode): void => {\n    sub.depsTail_ = undefined;\n    sub.flags_ =\n        (sub.flags_ &\n            ~(56 as\n                | ReactiveFlags.Recursed\n                | ReactiveFlags.Dirty\n                | ReactiveFlags.Pending)) |\n        (4 satisfies ReactiveFlags.RecursedCheck);\n};\n\nconst endTracking = (sub: ReactiveNode): void => {\n    const depsTail_ = sub.depsTail_;\n    let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_;\n    while (toRemove) {\n        toRemove = unlink(toRemove, sub);\n    }\n    sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck);\n};\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n    let stack: Stack<Link> | undefined;\n    let checkDepth = 0;\n\n    top: while (true) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n\n        let dirty = false;\n\n        if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n            dirty = true;\n        } else if (\n            (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n            (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n        ) {\n            if (update(dep as AlienSignal | AlienComputed)) {\n                const subs = dep.subs_!;\n                if (subs.nextSub_) {\n                    shallowPropagate(subs);\n                }\n                dirty = true;\n            }\n        } else if (\n            (depFlags &\n                (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n            (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n        ) {\n            if (link.nextSub_ || link.prevSub_) {\n                stack = { value_: link, prev_: stack };\n            }\n            link = dep.deps_!;\n            sub = dep;\n            ++checkDepth;\n            continue;\n        }\n\n        if (!dirty && link.nextDep_) {\n            link = link.nextDep_;\n            continue;\n        }\n\n        while (checkDepth) {\n            --checkDepth;\n            const firstSub = sub.subs_!;\n            const hasMultipleSubs = firstSub.nextSub_;\n            if (hasMultipleSubs) {\n                link = stack!.value_;\n                stack = stack!.prev_;\n            } else {\n                link = firstSub;\n            }\n            if (dirty) {\n                if (update(sub as AlienSignal | AlienComputed)) {\n                    if (hasMultipleSubs) {\n                        shallowPropagate(firstSub);\n                    }\n                    sub = link.sub_;\n                    continue;\n                }\n            } else {\n                sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending);\n            }\n            sub = link.sub_;\n            if (link.nextDep_) {\n                link = link.nextDep_;\n                continue top;\n            }\n            dirty = false;\n        }\n\n        return dirty;\n    }\n};\n\nconst shallowPropagate = (link: Link): void => {\n    do {\n        const sub = link.sub_;\n        const nextSub = link.nextSub_;\n        const subFlags = sub.flags_;\n        if (\n            (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n            (32 satisfies ReactiveFlags.Pending)\n        ) {\n            sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty);\n            if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n                notify(sub as AlienEffect);\n            }\n        }\n        link = nextSub!;\n    } while (link);\n};\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n    const depsTail = sub.depsTail_;\n    if (depsTail) {\n        let link = sub.deps_!;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === depsTail) {\n                break;\n            }\n            link = link.nextDep_!;\n        } while (link);\n    }\n    return false;\n};\n\nconst getPath = <T = any>(path: string): T | undefined => {\n    let result = root;\n    const split = path.split(\".\");\n    for (const path of split) {\n        if (result == null || !Object.hasOwn(result, path)) {\n            return;\n        }\n        result = result[path];\n    }\n    return result as T;\n};\n\nexport const DELETE = Symbol(\"delete\");\nconst deep = (value: any, prefix = \"\"): any => {\n    const isArr = Array.isArray(value);\n    if (isArr || isPojo(value)) {\n        const deepObj = (isArr ? [] : {}) as Record<string, Signal>;\n        for (const key in value) {\n            deepObj[key] = signal(\n                deep((value as Record<string, Signal>)[key], `${prefix + key}.`)\n            );\n        }\n        const keys = signal(0);\n        return new Proxy(deepObj, {\n            get: (_, prop: string) => {\n                if (!(prop === \"toJSON\" && !Object.hasOwn(deepObj, prop))) {\n                    if (isArr && prop in Array.prototype) {\n                        keys();\n                        return deepObj[prop];\n                    } else {\n                        if (typeof prop === \"symbol\") {\n                            return deepObj[prop];\n                        }\n                        if (\n                            !Object.hasOwn(deepObj, prop) ||\n                            deepObj[prop]() == null\n                        ) {\n                            deepObj[prop] = signal(\"\");\n                            dispatch({ [prefix + prop]: \"\" });\n                            keys(keys() + 1);\n                        }\n                        return deepObj[prop]();\n                    }\n                }\n            },\n            set: (_, prop: string, newValue) => {\n                if (newValue === DELETE) {\n                    if (Object.hasOwn(deepObj, prop)) {\n                        delete deepObj[prop];\n                        dispatch({ [prefix + prop]: DELETE });\n                        keys(keys() + 1);\n                    }\n                } else {\n                    if (isArr && prop === \"length\") {\n                        deepObj[prop] = newValue;\n                        dispatch({ [prefix.slice(0, -1)]: deepObj });\n                        keys(keys() + 1);\n                    } else {\n                        if (Object.hasOwn(deepObj, prop)) {\n                            if (newValue == null) {\n                                if (deepObj[prop](null)) {\n                                    dispatch({ [prefix + prop]: null });\n                                }\n                            } else {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch({ [prefix + prop]: \"\" });\n                                } else {\n                                    if (\n                                        deepObj[prop](\n                                            deep(newValue, `${prefix + prop}.`)\n                                        )\n                                    ) {\n                                        dispatch({ [prefix + prop]: newValue });\n                                    }\n                                }\n                            }\n                        } else {\n                            if (newValue != null) {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch({ [prefix + prop]: \"\" });\n                                } else {\n                                    deepObj[prop] = signal(\n                                        deep(newValue, `${prefix + prop}.`)\n                                    );\n                                    dispatch({ [prefix + prop]: newValue });\n                                }\n                                keys(keys() + 1);\n                            }\n                        }\n                    }\n                }\n\n                return true;\n            },\n            deleteProperty: (_, prop: string) => {\n                if (Object.hasOwn(deepObj, prop)) {\n                    if (deepObj[prop](null)) {\n                        dispatch({ [prefix + prop]: null });\n                    }\n                }\n\n                return true;\n            },\n            ownKeys: () => {\n                keys();\n                return Reflect.ownKeys(deepObj);\n            },\n            has(_, prop) {\n                keys();\n                return prop in deepObj;\n            },\n        });\n    }\n    return value;\n};\n\nconst dispatch = (obj?: Record<string, any>) => {\n    if (obj) {\n        pathToObj(currentPatch, obj);\n    }\n    if (!batchDepth && !isEmpty(currentPatch)) {\n        const oldPatch = currentPatch;\n        currentPatch = {};\n        document.dispatchEvent(\n            new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n                detail: oldPatch,\n            })\n        );\n    }\n};\n\nconst mergePatch = (\n    patch: Record<string, any>,\n    { ifMissing }: { ifMissing?: boolean } = {}\n): void => {\n    startBatch();\n    for (const key in patch) {\n        if (patch[key] == null) {\n            if (!ifMissing) {\n                delete root[key];\n            }\n        } else {\n            mergeInner(patch[key], key, root, \"\", ifMissing);\n        }\n    }\n    endBatch();\n};\n\nconst mergeInner = (\n    patch: any,\n    target: string,\n    targetParent: Record<string, any>,\n    prefix: string,\n    ifMissing: boolean | undefined\n): void => {\n    if (isPojo(patch)) {\n        if (\n            !(\n                Object.hasOwn(targetParent, target) &&\n                (isPojo(targetParent[target]) ||\n                    Array.isArray(targetParent[target]))\n            )\n        ) {\n            targetParent[target] = {};\n        }\n\n        for (const key in patch) {\n            if (patch[key] == null) {\n                if (!ifMissing) {\n                    delete targetParent[target][key];\n                }\n            } else {\n                mergeInner(\n                    patch[key],\n                    key,\n                    targetParent[target],\n                    `${prefix + target}.`,\n                    ifMissing\n                );\n            }\n        }\n    } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n        targetParent[target] = patch;\n    }\n};\n\nfunction filtered(\n    { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n    obj: JSONPatch = root\n) {\n    // We need to find all valid signal paths in the object\n    const pathObj: Record<string, any> = {};\n    const stack: Array<[any, string]> = [[obj, \"\"]];\n\n    while (stack.length) {\n        const [node, prefix] = stack.pop()!;\n\n        for (const key in node) {\n            if (isPojo(node[key])) {\n                stack.push([node[key], `${prefix + key}.`]);\n            } else if (\n                toRegExp(include).test(prefix + key) &&\n                !toRegExp(exclude).test(prefix + key)\n            ) {\n                pathObj[prefix + key] = getPath(prefix + key);\n            }\n        }\n    }\n\n    return pathToObj({}, pathObj);\n}\n\nfunction toRegExp(val: string | RegExp): RegExp {\n    if (typeof val === \"string\") {\n        return RegExp(val.replace(/^\\/|\\/$/g, \"\"));\n    }\n\n    return val;\n}\n\nconst root: Record<string, any> = deep({});\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {};\nconst plugins: AttributePlugin[] = [];\nlet pluginRegexs: RegExp[] = [];\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>();\n\nlet mutationObserver: MutationObserver | null = null;\n\nlet alias = \"\";\nexport function setAlias(value: string) {\n    alias = value;\n}\n\nexport function aliasify(name: string) {\n    return alias ? `data-${alias}-${name}` : `data-${name}`;\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n    for (const plugin of pluginsToLoad) {\n        const ctx: InitContext = {\n            plugin,\n            actions,\n            root,\n            filtered,\n            signal,\n            computed,\n            effect,\n            mergePatch,\n            peek,\n            getPath,\n            startBatch,\n            endBatch,\n            initErr: 0 as any,\n        };\n        ctx.initErr = initErr.bind(0, ctx);\n\n        if (plugin.type === \"action\") {\n            actions[plugin.name] = plugin;\n        } else if (plugin.type === \"attribute\") {\n            plugins.push(plugin);\n            plugin.onGlobalInit?.(ctx);\n        } else if (plugin.type === \"watcher\") {\n            plugin.onGlobalInit?.(ctx);\n        } else {\n            throw ctx.initErr(\"InvalidPluginType\");\n        }\n    }\n\n    // Sort attribute plugins by descending length then alphabetically\n    plugins.sort((a, b) => {\n        const lenDiff = b.name.length - a.name.length;\n        if (lenDiff !== 0) return lenDiff;\n        return a.name.localeCompare(b.name);\n    });\n\n    pluginRegexs = plugins.map((plugin) =>\n        RegExp(`^${plugin.name}([A-Z]|_|$)`)\n    );\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n    const ignore = `[${aliasify(\"ignore\")}]`;\n    for (const el of els) {\n        if (!el.closest(ignore)) {\n            for (const key in el.dataset) {\n                applyAttributePlugin(el, key, el.dataset[key]!);\n            }\n        }\n    }\n}\n\nfunction cleanupEls(els: Iterable<HTMLOrSVG>): void {\n    for (const el of els) {\n        const cleanups = removals.get(el);\n        // If removals has el, delete it and run all cleanup functions\n        if (removals.delete(el)) {\n            for (const cleanup of cleanups!.values()) {\n                cleanup();\n            }\n            cleanups!.clear();\n        }\n    }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n    // Delay applying plugins to give custom plugins a chance to load\n    queueMicrotask(() => {\n        applyEls([root]);\n        applyEls(root.querySelectorAll<HTMLOrSVG>(\"*\"));\n\n        // Monitor the entire document body or a provided element for changes\n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n        if (!mutationObserver) {\n            mutationObserver = new MutationObserver(observe);\n            mutationObserver.observe(root, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n            });\n        }\n    });\n}\n\nfunction applyAttributePlugin(\n    el: HTMLOrSVG,\n    attrKey: string,\n    value: string\n): void {\n    if (attrKey.startsWith(alias)) {\n        const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey);\n        const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey));\n        if (plugin) {\n            // Extract the key and modifiers\n            let [key, ...rawModifiers] = rawKey\n                .slice(plugin.name.length)\n                .split(/__+/);\n\n            const hasKey = !!key;\n            if (hasKey) {\n                key = camel(key);\n            }\n            const hasValue = !!value;\n\n            // Create the runtime context\n            const ctx: RuntimeContext = {\n                plugin,\n                actions,\n                root,\n                filtered,\n                signal,\n                computed,\n                effect,\n                mergePatch,\n                peek,\n                getPath,\n                startBatch,\n                endBatch,\n                initErr: 0 as any,\n                el,\n                rawKey,\n                key,\n                value,\n                mods: new Map(),\n                runtimeErr: 0 as any,\n                rx: 0 as any,\n            };\n            ctx.initErr = initErr.bind(0, ctx);\n            ctx.runtimeErr = runtimeErr.bind(0, ctx);\n            if (\n                plugin.shouldEvaluate === undefined ||\n                plugin.shouldEvaluate === true\n            ) {\n                ctx.rx = generateReactiveExpression(ctx);\n            }\n\n            // Check the requirements\n            const keyReq = plugin.keyReq || \"allowed\";\n            if (hasKey) {\n                if (keyReq === \"denied\") {\n                    throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`);\n                }\n            } else if (keyReq === \"must\") {\n                throw ctx.runtimeErr(`${plugin.name}KeyRequired`);\n            }\n\n            const valReq = plugin.valReq || \"allowed\";\n            if (hasValue) {\n                if (valReq === \"denied\") {\n                    throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`);\n                }\n            } else if (valReq === \"must\") {\n                throw ctx.runtimeErr(`${plugin.name}ValueRequired`);\n            }\n\n            // Check for exclusive requirements\n            if (keyReq === \"exclusive\" || valReq === \"exclusive\") {\n                if (hasKey && hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`);\n                }\n                if (!hasKey && !hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`);\n                }\n            }\n\n            for (const rawMod of rawModifiers) {\n                const [label, ...mod] = rawMod.split(\".\");\n                ctx.mods.set(\n                    camel(label),\n                    new Set(mod.map((t) => t.toLowerCase()))\n                );\n            }\n\n            const cleanup = plugin.onLoad(ctx);\n            if (cleanup) {\n                let cleanups = removals.get(el);\n                if (cleanups) {\n                    cleanups.get(rawKey)?.();\n                } else {\n                    cleanups = new Map();\n                    removals.set(el, cleanups);\n                }\n                cleanups.set(rawKey, cleanup);\n            }\n        }\n    }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n    const ignore = `[${aliasify(\"ignore\")}]`;\n\n    for (const {\n        target,\n        type,\n        attributeName,\n        addedNodes,\n        removedNodes,\n    } of mutations) {\n        if (type === \"childList\") {\n            for (const node of removedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    cleanupEls([node]);\n                    cleanupEls(node.querySelectorAll<HTMLOrSVG>(\"*\"));\n                }\n            }\n\n            for (const node of addedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    applyEls([node]);\n                    applyEls(node.querySelectorAll<HTMLOrSVG>(\"*\"));\n                }\n            }\n        } else if (type === \"attributes\") {\n            // If el has a parent with data-ignore, skip it\n            if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n                const key = camel(attributeName!.slice(5));\n                const value = target.getAttribute(attributeName!);\n                if (value === null) {\n                    const cleanups = removals.get(target);\n                    if (cleanups) {\n                        cleanups.get(key)?.();\n                        cleanups.delete(key);\n                    }\n                } else {\n                    applyAttributePlugin(target, key, value);\n                }\n            }\n        }\n    }\n}\n\nfunction generateReactiveExpression(\n    ctx: RuntimeContext\n): RuntimeExpressionFunction {\n    let expr = \"\";\n\n    const attrPlugin = (ctx.plugin as AttributePlugin) || undefined;\n\n    // plugin is guaranteed to be an attribute plugin\n    if (attrPlugin?.returnsValue) {\n        // This regex allows Datastar expressions to support nested\n        // regex and strings that contain ; without breaking.\n        //\n        // Each of these regex defines a block type we want to match\n        // (importantly we ignore the content within these blocks):\n        //\n        // regex            \\/(\\\\\\/|[^\\/])*\\/\n        // double quotes      \"(\\\\\"|[^\\\"])*\"\n        // single quotes      '(\\\\'|[^'])*'\n        // ticks              `(\\\\`|[^`])*`\n        // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n        //\n        // The iife support is (intentionally) limited. It only supports\n        // function and arrow syntax with no arguments, and no nested IIFEs.\n        //\n        // We also want to match the non delimiter part of statements\n        // note we only support ; statement delimiters:\n        //\n        // [^;]\n        //\n        const statementRe =\n            /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm;\n        const statements = ctx.value.trim().match(statementRe);\n        if (statements) {\n            const lastIdx = statements.length - 1;\n            const last = statements[lastIdx].trim();\n            if (!last.startsWith(\"return\")) {\n                statements[lastIdx] = `return (${last});`;\n            }\n            expr = statements.join(\";\\n\");\n        }\n    } else {\n        expr = ctx.value.trim();\n    }\n\n    // Replace signal references with bracket notation\n    // Examples:\n    //   $count          → $['count']\n    //   $count--        → $['count']--\n    //   $count++        → $['count']++\n    //   $count += 5     → $['count'] += 5\n    //   $foo = 5        → $['foo'] = 5\n    //   $foo.bar        → $['foo']['bar']\n    //   $foo-bar        → $['foo-bar']\n    //   $foo.bar-baz    → $['foo']['bar-baz']\n    //   $foo-$bar       → $['foo']-$['bar']\n    //   $arr[$index]    → $['arr'][$['index']]\n    //   $['foo']        → $['foo']\n    //   $foo[obj.bar]   → $['foo'][obj.bar]\n    //   $foo['bar.baz'] → $['foo']['bar.baz']\n    //   $1              → $['1']\n    //   $123            → $['123']\n    //   $foo.0.name     → $['foo']['0']['name']\n    //   $foo.0.1.2.bar.0 → $['foo']['0']['1']['2']['bar']['0']\n\n    // Transform all signal patterns\n    expr = expr\n        // $['x'] → $x (normalize existing bracket notation)\n        .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, \"$$$1\")\n        // $x → $['x'] (including dots and hyphens)\n        .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n            const parts = signalName.split(\".\");\n            return parts.reduce(\n                (acc: string, part: string) => `${acc}['${part}']`,\n                \"$\"\n            );\n        })\n        // $ inside brackets: [$x] → [$['x']]\n        .replace(\n            /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n            (_, varName) => `[$['${varName.slice(1)}']]`\n        );\n\n    // Ignore any escaped values\n    const escaped = new Map<string, string>();\n    const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, \"gm\");\n    let counter = 0;\n    for (const match of expr.matchAll(escapeRe)) {\n        const k = match[1];\n        const v = `dsEscaped${counter++}`;\n        escaped.set(v, k);\n        expr = expr.replace(DSP + k + DSS, v);\n    }\n\n    const nameGen = (prefix: string, name: string) => {\n        return `${prefix}${snake(name).replaceAll(/\\./g, \"_\")}`;\n    };\n\n    // Replace any action calls\n    const actionsCalled = new Set<string>();\n    const actionsRe = RegExp(`@(${Object.keys(actions).join(\"|\")})\\\\(`, \"gm\");\n    const actionMatches = [...expr.matchAll(actionsRe)];\n    const actionNames = new Set<string>();\n    const actionFns = new Set<(...args: any[]) => any>();\n    if (actionMatches.length) {\n        const actionPrefix = `${DATASTAR}Act_`;\n        for (const match of actionMatches) {\n            const actionName = match[1];\n            const action = actions[actionName];\n            if (!action) {\n                continue;\n            }\n            actionsCalled.add(actionName);\n\n            const name = nameGen(actionPrefix, actionName);\n\n            // Add ctx to action calls\n            expr = expr.replace(`@${actionName}(`, `${name}(`);\n            actionNames.add(name);\n            actionFns.add((...args: any[]) => action.fn(ctx, ...args));\n        }\n    }\n\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n        expr = expr.replace(k, v);\n    }\n\n    ctx.fnContent = expr;\n\n    try {\n        const fn = Function(\n            \"el\",\n            \"$\",\n            ...(attrPlugin?.argNames || []),\n            ...actionNames,\n            expr\n        );\n        return (...args: any[]) => {\n            try {\n                return fn(ctx.el, root, ...args, ...actionFns);\n            } catch (e: any) {\n                throw ctx.runtimeErr(\"ExecuteExpression\", {\n                    error: e.message,\n                });\n            }\n        };\n    } catch (error: any) {\n        throw ctx.runtimeErr(\"GenerateExpression\", {\n            error: error.message,\n        });\n    }\n}\n","// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport type { ActionPlugin } from '../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n","// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n","// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n","// Icon: material-symbols:send\n// Slug: Dispatches custom browser events for component communication.\n// Description: Dispatches CustomEvents globally or to specific elements, enabling event-driven reactive patterns like Livewire.\n\nimport type { ActionPlugin } from '../../../datastar/engine/types';\n\n/**\n * Dispatch Action - Event Communication System\n *\n * Mirrors Livewire's dispatch system, enabling both frontend and backend\n * to trigger custom events for component communication.\n *\n * Usage:\n * @dispatch('event-name')                                  // Global dispatch\n * @dispatch('event-name', {data: 'value'})                // With data\n * @dispatch('event-name', {id: 123}, {selector: '#target'}) // Targeted\n *\n * Options:\n * - selector: CSS selector for targeted dispatch (multiple elements supported)\n * - window: Force window dispatch (default: true if no selector)\n * - bubbles: Event bubbles (default: true)\n * - cancelable: Event can be canceled (default: true)\n * - composed: Event composes through shadow DOM (default: true)\n */\nexport const Dispatch: ActionPlugin = {\n    type: 'action',\n    name: 'dispatch',\n    fn: (\n        { el },\n        eventName: string,\n        data?: any,\n        options?: {\n            selector?: string;\n            window?: boolean;\n            bubbles?: boolean;\n            cancelable?: boolean;\n            composed?: boolean;\n        }\n    ) => {\n        // Validate event name\n        if (!eventName || typeof eventName !== 'string') {\n            console.error(\n                '[Hyper Dispatch] Invalid event name. Must be a non-empty string.',\n                { eventName }\n            );\n            return;\n        }\n\n        // Default options\n        const opts = {\n            selector: options?.selector,\n            window: options?.window ?? (!options?.selector), // Default to window if no selector\n            bubbles: options?.bubbles ?? true,\n            cancelable: options?.cancelable ?? true,\n            composed: options?.composed ?? true,\n        };\n\n        // Create CustomEvent\n        const event = new CustomEvent(eventName, {\n            detail: data || {},\n            bubbles: opts.bubbles,\n            cancelable: opts.cancelable,\n            composed: opts.composed,\n        });\n\n        // Targeted dispatch\n        if (opts.selector) {\n            const targets = document.querySelectorAll(opts.selector);\n\n            if (targets.length === 0) {\n                console.warn(\n                    `[Hyper Dispatch] No elements found for selector: ${opts.selector}`,\n                    { eventName, selector: opts.selector }\n                );\n                return;\n            }\n\n            targets.forEach((target) => {\n                target.dispatchEvent(new CustomEvent(eventName, {\n                    detail: data || {},\n                    bubbles: opts.bubbles,\n                    cancelable: opts.cancelable,\n                    composed: opts.composed,\n                }));\n            });\n\n            return;\n        }\n\n        // Global dispatch (window)\n        if (opts.window) {\n            window.dispatchEvent(event);\n            return;\n        }\n\n        // Element dispatch (fallback to current element)\n        el.dispatchEvent(event);\n    },\n};\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/actions/fileUrl.ts\n\n// Icon: material-symbols:attachment\n// Slug: Converts file sources to valid HTML src/href URLs with smart fallbacks.\n// Description: Handles base64 arrays from file binding and provides fallbacks. File paths are auto-converted by Laravel backend.\n\nimport type {\n    ActionPlugin,\n    RuntimeContext,\n} from \"../../../datastar/engine/types\";\n\n/**\n * FileUrl Action - Simplified and Reliable\n *\n * Now much simpler since Laravel handles path-to-URL conversion.\n * Frontend only needs to handle:\n * - Base64 arrays from Datastar file inputs\n * - URLs (already converted by Laravel)\n * - Fallbacks for missing/empty data\n *\n * Usage Examples:\n * @fileUrl($profilePicture)                           // Auto-detect with fallback\n * @fileUrl($document, {fallback: '/default.pdf'})     // Custom fallback\n * @fileUrl('/storage/file.jpg')                       // URL passthrough\n * @fileUrl($avatar, {defaultMime: 'image/png'})       // Custom MIME for base64\n */\nexport const FileUrl: ActionPlugin = {\n    type: \"action\",\n    name: \"fileUrl\",\n    fn: (\n        _ctx: RuntimeContext,\n        fileSource: any,\n        options?: {\n            fallback?: string;\n            defaultMime?: string;\n            mimeSignal?: string; // Name of companion MIME signal\n        }\n    ): string => {\n        const opts = options || {};\n        const fallback = opts.fallback || \"\";\n        const defaultMime = opts.defaultMime || \"application/octet-stream\";\n        const mimeSignal = opts.mimeSignal;\n\n        // Handle null, undefined, or empty values\n        if (fileSource == null) {\n            return fallback;\n        }\n\n        // Handle arrays (from Datastar file binding)\n        if (Array.isArray(fileSource)) {\n            // Empty array means no file selected\n            if (fileSource.length === 0) {\n                return fallback;\n            }\n\n            const base64Content = fileSource[0];\n            if (!base64Content || typeof base64Content !== \"string\") {\n                return fallback;\n            }\n\n            // Determine MIME type\n            let mimeType = defaultMime;\n\n            // Try to get MIME from companion signal if specified\n            if (mimeSignal && typeof window !== \"undefined\") {\n                const mimeArray = ((window as any).$ || {})[mimeSignal];\n                if (Array.isArray(mimeArray) && mimeArray.length > 0) {\n                    mimeType = mimeArray[0] || defaultMime;\n                }\n            }\n\n            // Construct data URL\n            return `data:${mimeType};base64,${base64Content}`;\n        }\n\n        // Handle strings (URLs, paths, data URLs)\n        if (typeof fileSource === \"string\") {\n            const trimmed = fileSource.trim();\n\n            // Empty string\n            if (!trimmed) {\n                return fallback;\n            }\n\n            // Laravel should have converted file paths to proper URLs\n            // We just return whatever string we got\n            return trimmed;\n        }\n\n        // Handle unexpected types gracefully\n        if (typeof fileSource === \"object\") {\n            console.warn(\n                \"FileUrl action received unexpected object:\",\n                fileSource\n            );\n        }\n\n        return fallback;\n    },\n};\n","// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    key = kebab(key)\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx<string>()\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx<Record<string, any>>()\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn’t already exist) and sets up two-way data binding between it and an element’s value.\n\nimport { aliasify } from '../../engine/engine'\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePatch,\n    runtimeErr,\n    getPath,\n  }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const contents: string[] = []\n            const mimes: string[] = []\n            const names: string[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw runtimeErr('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw runtimeErr('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      contents.push(match.groups.contents)\n                      mimes.push(match.groups.mime)\n                      names.push(f.name)\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePatch(\n                pathToObj(\n                  {},\n                  {\n                    [signalName]: contents,\n                    [`${signalName}Mimes`]: mimes,\n                    [`${signalName}Names`]: names,\n                  },\n                ),\n              )\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const inputs = document.querySelectorAll(\n        `[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const pathObj: Record<string, string> = {}\n      let i = 0\n      for (const input of inputs) {\n        pathObj[`${path}.${i}`] = get(input, 'none')\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePatch(pathToObj({}, { [path]: get(el, type) }), {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePatch(pathToObj({}, { [path]: value }))\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n}\n","// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key) {\n      key = modifyCasing(kebab(key), mods)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n}\n","// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, computed, mergePatch }) => {\n    mergePatch(pathToObj({}, { [modifyCasing(key, mods)]: computed(rx) }))\n  },\n}\n","// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n","import { DATASTAR } from '../../engine/consts'\nimport type { HTMLOrSVG } from '../../engine/types'\n\nexport const DATASTAR_FETCH_EVENT = `${DATASTAR}-fetch`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nexport interface DatastarFetchEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_FETCH_EVENT]: CustomEvent<DatastarFetchEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_FETCH_EVENT,\n    (event: CustomEvent<DatastarFetchEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n","// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\nimport {\n  DATASTAR_FETCH_EVENT,\n  type DatastarFetchEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, mergePatch, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePatch(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          mergePatch(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePatch(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n}\n","// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport type { AttributePlugin, SignalFilterOptions } from '../../engine/types'\nimport { jsStrToObject } from '../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n","import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n","import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n","// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\nimport { DATASTAR_FETCH_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx, startBatch, endBatch } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trusted` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trusted'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      startBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n","// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../engine/types'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n","// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagHas, tagToMs } from '../../utils/tags'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n","// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagToMs } from '../../utils/tags'\nimport { delay } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n","// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n  type JSONPatch,\n  type SignalFilterOptions,\n} from '../../engine/types'\nimport { isEmpty } from '../../utils/paths'\nimport { jsStrToObject } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\n\nexport const OnSignalPatch: AttributePlugin = {\n  type: 'attribute',\n  name: 'onSignalPatch',\n  valReq: 'must',\n  argNames: ['patch'],\n  returnsValue: true,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    plugin,\n    rx,\n    filtered,\n    runtimeErr,\n    startBatch,\n    endBatch,\n  }) => {\n    // Throw an error if the key exists and is not `filter`\n    if (!!key && key !== 'filter') {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`)\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          startBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n}\n","// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, value, mergePatch }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: el }))\n  },\n}\n","// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[key] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n","// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Style: AttributePlugin = {\n  type: 'attribute',\n  name: 'style',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, rx }) => {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    key &&= kebab(key)\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx<Record<string, any>>()\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n}\n","// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","//==========================================================================================\n// Icon: material-symbols:error-outline\n// Slug: Shows validation error for a field.\n// Description: Displays the first validation error message for a specified field from the errors signal.\n\nimport type { AttributePlugin } from \"../../../datastar/engine/types\";\nimport { pathToObj } from \"../../../datastar/utils/paths\";\n\nexport const Error: AttributePlugin = {\n    type: \"attribute\",\n    name: \"error\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: ({ el, value, effect, computed, getPath, mergePatch }) => {\n        const fieldName = value.trim();\n\n        // Ensure the 'errors' signal exists and is initialized as an empty object\n        // This works like the bind plugin - creates the signal if missing\n        mergePatch(pathToObj({}, { errors: {} }), { ifMissing: true });\n\n        // Create a computed that reactively reads the error for this field\n        const errorComputed = computed(() => {\n            const errors = getPath(\"errors\");\n            if (errors && errors[fieldName]) {\n                const fieldErrors = errors[fieldName];\n                if (Array.isArray(fieldErrors) && fieldErrors.length > 0) {\n                    return fieldErrors[0];\n                } else if (typeof fieldErrors === \"string\") {\n                    return fieldErrors;\n                }\n            }\n            return null;\n        });\n\n        // Effect that updates the DOM when the error changes\n        const cleanup = effect(() => {\n            const errorMessage = errorComputed();\n\n            if (errorMessage) {\n                el.style.removeProperty(\"display\");\n                el.textContent = errorMessage;\n            } else {\n                el.style.setProperty(\"display\", \"none\");\n                el.textContent = \"\";\n            }\n        });\n\n        return cleanup;\n    },\n};\n//=======================================================================================\n","// Icon: material-symbols:repeat\n// Slug: Iterates over an array or object with efficient diffing.\n// Description: Production-ready loop directive with keyed diffing, zero signal pollution, and full Datastar reactivity integration.\n\nimport type {\n    AttributePlugin,\n    HTMLOrSVG,\n} from \"../../../datastar/engine/types\";\nimport { apply } from \"../../../datastar/engine/engine\";\n\n/**\n * ARCHITECTURE: Clean Loop Implementation\n *\n * PRINCIPLES:\n * 1. NO SIGNAL POLLUTION - Only source signals exist (e.g., $users)\n * 2. Direct mapping: iterator \"user\" → source path \"users.0\", \"users.1\", etc.\n * 3. Datastar's Proxy-based reactivity handles all property mutations\n * 4. Keyed diffing reuses DOM elements, retransforming indices on position changes\n * 5. Efficient change detection: no-change, simple-add, simple-remove, complex\n */\n\ninterface IterationState {\n    prevKeys: any[];\n    lookup: Map<any, LoopElement>;\n    template: HTMLTemplateElement;\n    templateContent: DocumentFragment;\n    iteratorNames: ParsedExpression;\n    keyExpression: string | null;\n    effectCleanup: (() => void) | null;\n    sourceSignalPath: string;\n    isNormalized: boolean;\n    iterationId: string;\n}\n\ninterface LoopElement {\n    el: HTMLOrSVG;\n    key: any;\n    index: number;\n}\n\ninterface ParsedExpression {\n    item: string;\n    index?: string;\n    collection?: string;\n    items: string;\n}\n\nconst iterationStates = new WeakMap<HTMLOrSVG, IterationState>();\n\nexport const For: AttributePlugin = {\n    type: \"attribute\",\n    name: \"for\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: (ctx) => {\n        const { el, value, mods, effect, getPath, runtimeErr, startBatch, endBatch, peek } = ctx;\n\n        // Validate template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw runtimeErr(\"ForMustBeOnTemplate\", {\n                message: \"data-for must be used on <template> elements\",\n            });\n        }\n\n        // Parse expression: \"user in $users\", \"[name, email] in $users\", \"item, index in $items\"\n        const parsed = parseExpression(value);\n        if (!parsed) {\n            throw runtimeErr(\"InvalidForExpression\", {\n                expression: value,\n                expected: 'Format: \"item in $items\", \"[name, age] in $users\", \"item, index in $items\"',\n            });\n        }\n\n        // Get key expression from data-for__key modifier\n        const keyMod = mods.get(\"key\");\n        const keyExpression = keyMod && keyMod.size > 0 ? Array.from(keyMod)[0] : null;\n\n        // Setup\n        const template = el as HTMLTemplateElement;\n        template.style.display = \"none\";\n        const templateContent = template.content.cloneNode(true) as DocumentFragment;\n\n        const sourceSignalPath = parsed.items;\n        const sourceData = getPath(sourceSignalPath);\n        const isNormalized = shouldNormalizeData(sourceData);\n\n        // Generate unique iteration ID for this data-for instance\n        const iterationId = `__for_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n        const state: IterationState = {\n            prevKeys: [],\n            lookup: new Map(),\n            template,\n            templateContent,\n            iteratorNames: parsed,\n            keyExpression,\n            effectCleanup: null,\n            sourceSignalPath,\n            isNormalized,\n            iterationId,\n        };\n\n        iterationStates.set(el, state);\n\n        // Create reactive effect that tracks source signal\n        const effectCleanup = effect(() => {\n            // Access source signal reactively through getPath\n            // This properly triggers Datastar's reactive tracking\n            const sourceData = getPath(sourceSignalPath);\n\n            // For arrays, track structure changes AND deep properties (for objects only)\n            if (Array.isArray(sourceData)) {\n                const reactiveArray = ctx.root[sourceSignalPath];\n\n                // Track deep properties ONLY for object items (not primitives)\n                // This enables reactive updates like: $users[0].name = 'New Name'\n                if (reactiveArray && reactiveArray.length > 0) {\n                    const firstItem = reactiveArray[0];\n                    // Only track deep if items are objects (not strings/numbers)\n                    if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                        for (const key in reactiveArray) {\n                            const item = reactiveArray[key];\n                            void item; // Track array structure\n                            // Track all object properties for reactivity\n                            if (item && typeof item === 'object') {\n                                for (const prop in item) {\n                                    void item[prop];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            const items = normalizeData(sourceData);\n\n            const newArrayWithKeys = items.map((item, index) => ({\n                item,\n                index,\n                key: evaluateKey(keyExpression, item, index),\n            }));\n\n            // Prevent tracking during DOM updates (critical for performance)\n            peek(() => {\n                startBatch();\n                try {\n                    diffAndUpdate(newArrayWithKeys, state, ctx);\n                } finally {\n                    endBatch();\n                }\n            });\n        });\n\n        state.effectCleanup = effectCleanup;\n\n        return () => {\n            cleanup(state);\n            iterationStates.delete(el);\n        };\n    },\n};\n\n/**\n * Parse for expression\n */\nfunction parseExpression(expression: string): ParsedExpression | null {\n    const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    const stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n    const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n\n    const match = expression.match(forAliasRE);\n    if (!match) return null;\n\n    let itemsExpr = match[2].trim();\n    if (itemsExpr.startsWith(\"$\")) {\n        itemsExpr = itemsExpr.slice(1);\n    }\n\n    const result: ParsedExpression = {\n        item: \"\",\n        items: itemsExpr,\n    };\n\n    let item = match[1].replace(stripParensRE, \"\").trim();\n    const iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n        result.item = item.replace(forIteratorRE, \"\").trim();\n        result.index = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n            result.collection = iteratorMatch[2].trim();\n        }\n    } else {\n        result.item = item;\n    }\n\n    return result;\n}\n\n/**\n * Diff and update DOM with keyed diffing\n */\nfunction diffAndUpdate(\n    newArrayWithKeys: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    // Handle duplicate keys\n    const seen = new Set();\n    const finalArray = newArrayWithKeys.map((data, i) => {\n        let finalKey = data.key;\n        if (seen.has(finalKey)) {\n            finalKey = `${finalKey}_dup_${i}`;\n        }\n        seen.add(finalKey);\n        return { ...data, key: finalKey };\n    });\n\n    const newKeys = finalArray.map(d => d.key);\n    const prevKeys = state.prevKeys;\n\n    // Detect change type\n    const changeType = detectChange(prevKeys, newKeys);\n\n    if (changeType === 'no-change') {\n        // NO-CHANGE: Keys haven't changed, but properties might have\n        // Sync ephemeral signals from source for DISPLAY properties (data-text, etc.)\n        // Bindings (data-bind) update ephemeral signals directly, but display\n        // properties need to be synced when source properties change\n        if (!state.isNormalized && finalArray.length > 0) {\n            // Check if this is an object array (first item is an object)\n            const firstItem = finalArray[0].item;\n            if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                for (const itemData of finalArray) {\n                    const loopEl = state.lookup.get(itemData.key);\n                    if (loopEl) {\n                        const sanitizedKey = sanitizeKey(itemData.key);\n                        // Sync ephemeral signal with latest source data\n                        ctx.mergePatch({\n                            [state.iterationId]: {\n                                [sanitizedKey]: itemData.item\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        return;\n    } else if (changeType === 'simple-add') {\n        handleAdd(finalArray, state, ctx);\n    } else if (changeType === 'simple-remove') {\n        handleRemove(prevKeys, newKeys, state, ctx, finalArray);\n    } else {\n        handleReorder(finalArray, state, ctx);\n    }\n\n    state.prevKeys = [...newKeys];\n}\n\n/**\n * Detect change type for optimized updates\n */\nfunction detectChange(prevKeys: any[], newKeys: any[]): 'no-change' | 'simple-add' | 'simple-remove' | 'complex' {\n    if (prevKeys.length === newKeys.length && prevKeys.every((k, i) => k === newKeys[i])) {\n        return 'no-change';\n    }\n\n    if (prevKeys.length < newKeys.length) {\n        if (prevKeys.every((k, i) => k === newKeys[i])) {\n            return 'simple-add';\n        }\n    }\n\n    if (prevKeys.length > newKeys.length) {\n        const newSet = new Set(newKeys);\n        if (!newKeys.some(k => !new Set(prevKeys).has(k))) {\n            let newIdx = 0;\n            for (const pk of prevKeys) {\n                if (newSet.has(pk)) {\n                    if (newKeys[newIdx] !== pk) return 'complex';\n                    newIdx++;\n                }\n            }\n            return 'simple-remove';\n        }\n    }\n\n    return 'complex';\n}\n\n/**\n * Handle simple additions\n */\nfunction handleAdd(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const startIdx = state.prevKeys.length;\n    let prevEl: HTMLOrSVG = state.template;\n\n    if (startIdx > 0) {\n        const lastKey = state.prevKeys[startIdx - 1];\n        const last = state.lookup.get(lastKey);\n        if (last) prevEl = last.el;\n    }\n\n    for (let i = startIdx; i < data.length; i++) {\n        const item = data[i];\n        const loopEl = createElement(item, state, ctx);\n        state.lookup.set(item.key, loopEl);\n        prevEl.after(loopEl.el);\n        prevEl = loopEl.el;\n        queueMicrotask(() => apply(loopEl.el));\n    }\n}\n\n/**\n * Handle simple removals\n */\nfunction handleRemove(\n    prevKeys: any[],\n    newKeys: any[],\n    state: IterationState,\n    ctx: any,\n    data: Array<{ item: any; index: number; key: any }>\n) {\n    const newSet = new Set(newKeys);\n\n    // Remove elements no longer in new keys\n    for (const key of prevKeys) {\n        if (!newSet.has(key)) {\n            const loopEl = state.lookup.get(key);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(key);\n            }\n        }\n    }\n\n    // Update indices for remaining elements\n    for (const itemData of data) {\n        const loopEl = state.lookup.get(itemData.key);\n        if (loopEl && loopEl.index !== itemData.index) {\n            loopEl.index = itemData.index;\n\n            // Update index in ephemeral signal for reactive updates\n            if (!state.isNormalized) {\n                const sanitizedKey = sanitizeKey(itemData.key);\n                const currentData = ctx.root[state.iterationId]?.[sanitizedKey];\n                if (currentData !== undefined) {\n                    ctx.mergePatch({\n                        [state.iterationId]: {\n                            [`${sanitizedKey}__index`]: itemData.index\n                        }\n                    });\n                }\n            }\n        }\n    }\n}\n\n/**\n * Handle complex changes with smart reordering\n */\nfunction handleReorder(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const newSet = new Set(data.map(d => d.key));\n\n    // Remove elements no longer in new keys\n    for (const pk of state.prevKeys) {\n        if (!newSet.has(pk)) {\n            const loopEl = state.lookup.get(pk);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(pk);\n            }\n        }\n    }\n\n    // Reorder/create elements\n    let prevEl: HTMLOrSVG = state.template;\n    for (const item of data) {\n        const existing = state.lookup.get(item.key);\n\n        if (existing) {\n            // Reuse element - update index in ephemeral signal if it changed\n            if (existing.index !== item.index) {\n                existing.index = item.index;\n\n                // Update index in ephemeral signal for reactive updates\n                if (!state.isNormalized) {\n                    const sanitizedKey = sanitizeKey(item.key);\n                    const currentData = ctx.root[state.iterationId]?.[sanitizedKey];\n                    if (currentData !== undefined) {\n                        ctx.mergePatch({\n                            [state.iterationId]: {\n                                [`${sanitizedKey}__index`]: item.index\n                            }\n                        });\n                    }\n                }\n            }\n\n            if (existing.el.previousElementSibling !== prevEl) {\n                prevEl.after(existing.el);\n            }\n            prevEl = existing.el;\n        } else {\n            // Create new element\n            const loopEl = createElement(item, state, ctx);\n            state.lookup.set(item.key, loopEl);\n            prevEl.after(loopEl.el);\n            prevEl = loopEl.el;\n            queueMicrotask(() => apply(loopEl.el));\n        }\n    }\n}\n\n/**\n * Create new loop element with EPHEMERAL SIGNALS\n *\n * CRITICAL: Use ephemeral signals (keyed by item key) to prevent source signal corruption\n */\nfunction createElement(\n    itemData: { item: any; index: number; key: any },\n    state: IterationState,\n    ctx: any\n): LoopElement {\n    const { templateContent, sourceSignalPath, iteratorNames, isNormalized, iterationId } = state;\n\n    const clone = templateContent.cloneNode(true) as DocumentFragment;\n    const el = clone.firstElementChild as HTMLOrSVG;\n\n    // Map iterator to ephemeral signal path (keyed by item key to prevent corruption)\n    let signalPath = sourceSignalPath;\n    let indexSignalPath: string | null = null;\n    if (!isNormalized) {\n        // For arrays: Create ephemeral signal keyed by unique key\n        // This prevents corruption of source signal\n        const sanitizedKey = sanitizeKey(itemData.key);\n        signalPath = `${iterationId}.${sanitizedKey}`;\n        indexSignalPath = `${iterationId}.${sanitizedKey}__index`;\n\n        // Create ephemeral signals for item and index\n        ctx.mergePatch({\n            [iterationId]: {\n                [sanitizedKey]: itemData.item,\n                [`${sanitizedKey}__index`]: itemData.index\n            }\n        });\n    }\n\n    transformElement(el, iteratorNames, itemData.index, signalPath, indexSignalPath, isNormalized, itemData.item);\n\n    return {\n        el,\n        key: itemData.key,\n        index: itemData.index,\n    };\n}\n\n/**\n * Sanitize key for use as signal path\n */\nfunction sanitizeKey(key: any): string {\n    return String(key).replace(/[^a-zA-Z0-9_]/g, '_');\n}\n\n/**\n * Transform element attributes\n */\nfunction transformElement(\n    el: HTMLOrSVG,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n) {\n    const process = (elem: Element): void => {\n        Array.from(elem.attributes).forEach((attr) => {\n            if (attr.name.startsWith(\"data-\") && attr.value) {\n                attr.value = transformExpression(\n                    attr.value,\n                    attr.name,\n                    iterators,\n                    index,\n                    signalPath,\n                    indexSignalPath,\n                    isNormalized,\n                    value\n                );\n            }\n        });\n\n        if (elem instanceof HTMLTemplateElement && elem.content) {\n            Array.from(elem.content.children).forEach(child => process(child));\n        } else {\n            Array.from(elem.children).forEach(child => process(child));\n        }\n    };\n\n    process(el);\n}\n\n/**\n * Transform expression\n */\nfunction transformExpression(\n    expr: string,\n    attrName: string,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n): string {\n    let result = expr;\n\n    // Determine if signal name or expression\n    const isSignalName = /^(bind|ref|indicator|signals|computed)/.test(attrName.replace(/^data-/, \"\"));\n\n    // Protect string literals\n    const literals: string[] = [];\n    result = result\n        .replace(/'(?:[^'\\\\]|\\\\.)*'/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/\"(?:[^\"\\\\]|\\\\.)*\"/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/`(?:[^`\\\\]|\\\\.)*`/g, m => (literals.push(m), `__LIT${literals.length - 1}__`));\n\n    // Transform index - use reactive signal if available, otherwise literal\n    if (iterators.index) {\n        if (indexSignalPath && !isNormalized) {\n            // Use reactive index signal with $ prefix for expressions\n            const prefix = isSignalName ? \"\" : \"$\";\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), prefix + indexSignalPath);\n        } else {\n            // Fallback to literal index for normalized data\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), index.toString());\n        }\n    }\n\n    // Transform collection\n    if (iterators.collection) {\n        const prefix = isSignalName ? \"\" : \"$\";\n        result = result.replace(new RegExp(`\\\\b${esc(iterators.collection)}\\\\b`, \"g\"), prefix + signalPath);\n    }\n\n    // Transform item\n    if (isDestructured(iterators.item)) {\n        const vars = extractVars(iterators.item);\n        const isArrayDestructuring = iterators.item.trim().startsWith('[');\n\n        vars.forEach((v, idx) => {\n            let varSignalPath: string;\n            let varValue: any;\n\n            if (isArrayDestructuring) {\n                // Array destructuring: [x, y] → signalPath.0, signalPath.1\n                varSignalPath = `${signalPath}.${idx}`;\n                varValue = Array.isArray(value) ? value[idx] : value;\n            } else {\n                // Object destructuring: {name, price} → signalPath.name, signalPath.price\n                varSignalPath = `${signalPath}.${v}`;\n                varValue = value && typeof value === 'object' ? value[v] : value;\n            }\n\n            result = transformVar(result, v, varSignalPath, isSignalName, isNormalized, varValue, iterators);\n        });\n    } else {\n        result = transformVar(result, iterators.item, signalPath, isSignalName, isNormalized, value, iterators);\n    }\n\n    // Restore literals\n    result = result.replace(/__LIT(\\d+)__/g, (_, i) => literals[parseInt(i)]);\n\n    return result;\n}\n\n/**\n * Transform variable\n */\nfunction transformVar(\n    expr: string,\n    varName: string,\n    signalPath: string,\n    isSignalName: boolean,\n    isNormalized: boolean,\n    value: any,\n    _iterators: ParsedExpression\n): string {\n    if (isNormalized) {\n        // Value-based: replace with literal value\n        return expr.replace(new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"), JSON.stringify(value));\n    }\n\n    const prefix = isSignalName ? \"\" : \"$\";\n\n    // Property access: varName.prop → signalPath.prop\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\.([a-zA-Z_][a-zA-Z0-9_.]*)\\\\b`, \"g\"),\n        `${prefix}${signalPath}.$1`\n    );\n\n    // Standalone: varName → signalPath\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"),\n        prefix + signalPath\n    );\n\n    return expr;\n}\n\n/**\n * Utilities\n */\nfunction shouldNormalizeData(data: any): boolean {\n    return typeof data === \"number\" || (data && typeof data === \"object\" && !Array.isArray(data));\n}\n\nfunction normalizeData(data: any): any[] {\n    if (data == null) return [];\n    if (Array.isArray(data)) return data;\n    if (typeof data === \"number\") return Array.from({ length: data }, (_, i) => i + 1);\n    if (typeof data === \"object\") return Object.entries(data);\n    return [data];\n}\n\nfunction evaluateKey(keyExpr: string | null, item: any, index: number): any {\n    if (!keyExpr) {\n        if (item && typeof item === \"object\") {\n            if (\"id\" in item && item.id != null) return item.id;\n            if (\"uuid\" in item && item.uuid != null) return item.uuid;\n            if (\"key\" in item && item.key != null) return item.key;\n        }\n        return index;\n    }\n\n    if (keyExpr === \"index\") return index;\n\n    if (keyExpr.includes('.')) {\n        const parts = keyExpr.split('.');\n        let val = item;\n        for (const part of parts) {\n            if (val && typeof val === \"object\" && part in val) {\n                val = val[part];\n            } else {\n                return index;\n            }\n        }\n        return val !== undefined && val !== null ? val : index;\n    }\n\n    if (item && typeof item === \"object\" && keyExpr in item) {\n        const keyVal = item[keyExpr];\n        return keyVal !== undefined && keyVal !== null ? keyVal : index;\n    }\n\n    return index;\n}\n\nfunction isDestructured(item: string): boolean {\n    return /^\\[.*\\]$/.test(item) || /^\\{.*\\}$/.test(item);\n}\n\nfunction extractVars(item: string): string[] {\n    return item\n        .replace(/[\\[\\]\\{\\}]/g, \"\")\n        .split(\",\")\n        .map(i => i.trim());\n}\n\nfunction esc(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nfunction cleanup(state: IterationState) {\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    state.lookup.forEach(loopEl => loopEl.el.remove());\n    state.lookup.clear();\n    state.prevKeys.length = 0;\n}\n","// Icon: material-symbols:check-circle-outline\n// Slug: Conditionally renders elements based on expression.\n// Description: Implements conditional rendering like Alpine.js x-if - must be on <template> with single root element. Uses computed wrapper for proper reactivity with Datastar's signal system.\n\nimport type { AttributePlugin, HTMLOrSVG } from \"../../../datastar/engine/types\";\nimport { apply } from \"../../../datastar/engine\";\n\n/**\n * State management interface for each data-if instance\n */\ninterface IfState {\n    renderedElement: Element | null;\n    isRendered: boolean;\n    commentMarker: Comment;\n    effectCleanup: (() => void) | null;\n    ifId: string;\n}\n\n// WeakMap to store if state per element\nconst ifStates = new WeakMap<HTMLOrSVG, IfState>();\nlet ifCounter = 0;\n\nexport const If: AttributePlugin = {\n    type: \"attribute\",\n    name: \"if\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: true,\n    returnsValue: true,\n    onLoad: ({ el, effect, rx, runtimeErr, computed }) => {\n        // VALIDATION: Must be on template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw runtimeErr(\"IfMustBeOnTemplate\", {\n                message: \"data-if must be used on <template> elements\",\n            });\n        }\n\n        // VALIDATION: Template must have single root element (Alpine.js requirement)\n        const templateContent = el.content;\n        const rootElements = Array.from(templateContent.children);\n        if (rootElements.length !== 1) {\n            throw runtimeErr(\"IfTemplateMustHaveSingleRoot\", {\n                count: rootElements.length,\n                message:\n                    \"data-if template must contain exactly one root element\",\n            });\n        }\n\n        const template = el;\n        const container = template.parentElement!;\n\n        // Hide template element\n        template.style.display = \"none\";\n\n        // ALPINE.JS PATTERN: Create comment marker for reliable positioning\n        const ifId = `__if_${++ifCounter}`;\n        const commentMarker = document.createComment(`Datastar if ${ifId}`);\n        container.insertBefore(commentMarker, template.nextSibling);\n\n        // Initialize state tracking with WeakMap (data-for pattern)\n        const state: IfState = {\n            renderedElement: null,\n            isRendered: false,\n            commentMarker,\n            effectCleanup: null,\n            ifId,\n        };\n\n        ifStates.set(el, state);\n\n        try {\n            // COMPUTED WRAPPER: Re-evaluate expression reactively (data-for pattern)\n            // This ensures proper subscription even when signals are deleted/recreated by Datastar\n            const conditionComputed = computed(() => {\n                return rx(); // Evaluate reactive expression inside computed\n            });\n\n            // DATASTAR REACTIVE EFFECT: Conditional rendering\n            const effectCleanup = effect(() => {\n                const shouldRender = !!conditionComputed();\n\n                // State transition: false -> true (RENDER)\n                if (shouldRender && !state.isRendered) {\n                    state.renderedElement = renderElement(\n                        template,\n                        state.commentMarker\n                    );\n                    state.isRendered = true;\n                }\n                // State transition: true -> false (CLEANUP)\n                else if (!shouldRender && state.isRendered) {\n                    if (state.renderedElement) {\n                        cleanupElement(state.renderedElement);\n                        state.renderedElement = null;\n                    }\n                    state.isRendered = false;\n                }\n            });\n\n            state.effectCleanup = effectCleanup;\n\n            // Return cleanup function (called when plugin is removed)\n            return () => {\n                cleanupIfInstance(state);\n                ifStates.delete(el);\n            };\n        } catch (error) {\n            // Cleanup on error\n            const instanceState = ifStates.get(el);\n            if (instanceState) {\n                cleanupIfInstance(instanceState);\n                ifStates.delete(el);\n            }\n            throw error;\n        }\n    },\n};\n\n/**\n * RENDER FUNCTION: Clone template and insert into DOM\n * Follows data-for pattern with queueMicrotask for Datastar processing\n */\nfunction renderElement(\n    template: HTMLTemplateElement,\n    commentMarker: Comment\n): Element {\n    // Clone template content\n    const clone = template.content.cloneNode(true) as DocumentFragment;\n    const element = clone.firstElementChild as Element;\n\n    // Insert element into DOM after the comment marker\n    commentMarker.parentNode!.insertBefore(element, commentMarker.nextSibling);\n\n    // Apply Datastar processing to generated element\n    // Use queueMicrotask to ensure DOM is ready (data-for pattern)\n    queueMicrotask(() => {\n        apply(element as HTMLElement);\n    });\n\n    return element;\n}\n\n/**\n * CLEANUP FUNCTION: Remove element from DOM\n * Datastar's mutation observer handles attribute cleanup\n */\nfunction cleanupElement(element: Element): void {\n    element.remove();\n}\n\n/**\n * COMPREHENSIVE CLEANUP: Clean up entire if instance\n * Follows data-for's comprehensive cleanup pattern\n */\nfunction cleanupIfInstance(state: IfState): void {\n    // Cleanup reactive effect\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    // Remove rendered element if present\n    if (state.renderedElement) {\n        cleanupElement(state.renderedElement);\n        state.renderedElement = null;\n    }\n\n    // Remove comment marker\n    if (state.commentMarker && state.commentMarker.parentNode) {\n        state.commentMarker.remove();\n    }\n\n    // Reset state\n    state.isRendered = false;\n}\n","import {\n    DATASTAR,\n    DATASTAR_REQUEST,\n    DefaultSseRetryDurationMs,\n    EventTypePatchElements,\n    EventTypePatchSignals,\n} from \"../../../engine/consts\";\n// Factory for creating HTTP method action plugins\nimport type {\n    ActionPlugin,\n    HTMLOrSVG,\n    RuntimeContext,\n    SignalFilterOptions,\n} from \"../../../engine/types\";\nimport { kebab } from \"../../../utils/text\";\nimport {\n    DATASTAR_FETCH_EVENT,\n    type DatastarFetchEvent,\n    ERROR,\n    FINISHED,\n    RETRIES_FAILED,\n    RETRYING,\n    STARTED,\n} from \"../shared\";\n\n// Global store for active SSE controllers per element\nconst fetchAbortControllers = new WeakMap<HTMLOrSVG, AbortController>();\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n    name: string,\n    method: string\n): ActionPlugin => ({\n    type: \"action\",\n    name,\n    fn: async (ctx, url: string, args: FetchArgs) => {\n        const { el } = ctx;\n\n        const requestCancellation = args?.requestCancellation ?? \"auto\";\n        const controller =\n            requestCancellation instanceof AbortController\n                ? requestCancellation\n                : new AbortController();\n        const isDisabled = requestCancellation === \"disabled\";\n        if (!isDisabled) {\n            fetchAbortControllers.get(el)?.abort();\n        }\n\n        if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n            fetchAbortControllers.set(el, controller);\n        }\n\n        try {\n            await fetcher(ctx, method, url, args, controller.signal);\n        } finally {\n            if (fetchAbortControllers.get(el) === controller) {\n                fetchAbortControllers.delete(el);\n            }\n        }\n    },\n});\n\nconst dispatchFetch = (\n    type: string,\n    el: HTMLOrSVG,\n    argsRaw: Record<string, string>\n) =>\n    document.dispatchEvent(\n        new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n            detail: { type, el, argsRaw },\n        })\n    );\n\nconst isWrongContent = (err: any) => `${err}`.includes(\"text/event-stream\");\n\ntype ResponseOverrides =\n    | {\n          selector?: string;\n          mode?: string;\n          useViewTransition?: boolean;\n      }\n    | {\n          onlyIfMissing?: boolean;\n      };\n\nexport type FetchArgs = {\n    headers?: Record<string, string>;\n    openWhenHidden?: boolean;\n    retryInterval?: number;\n    retryScaler?: number;\n    retryMaxWaitMs?: number;\n    retryMaxCount?: number;\n    responseOverrides?: ResponseOverrides;\n    contentType?: \"json\" | \"form\";\n    filterSignals?: SignalFilterOptions;\n    selector?: string;\n    requestCancellation?: \"auto\" | \"disabled\" | AbortController;\n};\n\nconst fetcher = async (\n    { el, evt, filtered, runtimeErr }: RuntimeContext,\n    method: string,\n    url: string,\n    {\n        selector,\n        headers: userHeaders,\n        contentType = \"json\",\n        filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n        openWhenHidden = false,\n        retryInterval = DefaultSseRetryDurationMs,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n    }: FetchArgs = {},\n    abort?: AbortSignal\n) => {\n    const action = method.toLowerCase();\n    let cleanupFn = () => {};\n    try {\n        if (!url?.length) {\n            throw runtimeErr(\"FetchNoUrlProvided\", { action });\n        }\n\n        const initialHeaders: Record<string, any> = {\n            Accept: \"text/event-stream, text/html, application/json\",\n            [DATASTAR_REQUEST]: true,\n        };\n        if (contentType === \"json\") {\n            initialHeaders[\"Content-Type\"] = \"application/json\";\n        }\n        const headers = Object.assign({}, initialHeaders, userHeaders);\n\n        // We ignore the content-type header if using form data\n        // if missing the boundary will be set automatically\n\n        const req: FetchEventSourceInit = {\n            method,\n            headers,\n            openWhenHidden,\n            retryInterval,\n            retryScaler,\n            retryMaxWaitMs,\n            retryMaxCount,\n            signal: abort,\n            onopen: async (response: Response) => {\n                if (response.status >= 400)\n                    dispatchFetch(ERROR, el, {\n                        status: response.status.toString(),\n                    });\n            },\n            onmessage: (evt) => {\n                if (!evt.event.startsWith(DATASTAR)) return;\n                const type = evt.event;\n                const argsRawLines: Record<string, string[]> = {};\n\n                for (const line of evt.data.split(\"\\n\")) {\n                    const i = line.indexOf(\" \");\n                    const k = line.slice(0, i);\n                    const v = line.slice(i + 1);\n                    (argsRawLines[k] ||= []).push(v);\n                }\n\n                const argsRaw = Object.fromEntries(\n                    Object.entries(argsRawLines).map(([k, v]) => [\n                        k,\n                        v.join(\"\\n\"),\n                    ])\n                );\n\n                dispatchFetch(type, el, argsRaw);\n            },\n            onerror: (error) => {\n                if (isWrongContent(error)) {\n                    // don't retry if the content-type is wrong\n                    throw runtimeErr(\"InvalidContentType\", { url });\n                }\n                // do nothing and it will retry\n                if (error) {\n                    console.error(error.message);\n                    dispatchFetch(RETRYING, el, { message: error.message });\n                }\n            },\n        };\n\n        const urlInstance = new URL(url, window.location.href);\n        const queryParams = new URLSearchParams(urlInstance.search);\n\n        if (contentType === \"json\") {\n            const res = JSON.stringify(filtered({ include, exclude }));\n            if (method === \"GET\") {\n                queryParams.set(DATASTAR, res);\n            } else {\n                req.body = res;\n            }\n        } else if (contentType === \"form\") {\n            const formEl = (\n                selector ? document.querySelector(selector) : el.closest(\"form\")\n            ) as HTMLFormElement;\n            if (!formEl) {\n                throw runtimeErr(\n                    selector ? \"FetchFormNotFound\" : \"FetchClosestFormNotFound\",\n                    { action, selector }\n                );\n            }\n\n            // Validate the form\n            if (!formEl.checkValidity()) {\n                formEl.reportValidity();\n                cleanupFn();\n                return;\n            }\n\n            // Collect the form data\n\n            const formData = new FormData(formEl);\n            let submitter = el as HTMLElement | null;\n\n            if (el === formEl && evt instanceof SubmitEvent) {\n                // Get the submitter from the event\n                submitter = evt.submitter;\n            } else {\n                // Prevent the form being submitted\n                const preventDefault = (evt: Event) => evt.preventDefault();\n                formEl.addEventListener(\"submit\", preventDefault);\n                cleanupFn = () =>\n                    formEl.removeEventListener(\"submit\", preventDefault);\n            }\n\n            // Append the value of the form submitter if it is a button with a name\n            if (submitter instanceof HTMLButtonElement) {\n                const name = submitter.getAttribute(\"name\");\n                if (name) formData.append(name, submitter.value);\n            }\n\n            const multipart =\n                formEl.getAttribute(\"enctype\") === \"multipart/form-data\";\n            // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n            if (!multipart) {\n                headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            }\n\n            const formParams = new URLSearchParams(formData as any);\n            if (method === \"GET\") {\n                for (const [key, value] of formParams) {\n                    queryParams.append(key, value);\n                }\n            } else if (multipart) {\n                // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n                if (\n                    __USE_UPLOAD_PROGRESS__ &&\n                    urlInstance.protocol === \"https:\"\n                ) {\n                    const boundary = `----FormDataBoundary${Math.random()\n                        .toString(36)\n                        .substring(2, 11)}`;\n                    const encoder = new TextEncoder();\n\n                    // Calculate total size\n                    let total = 0;\n                    const parts: Array<{\n                        field: string;\n                        value: string | File;\n                    }> = [];\n\n                    for (const [name, value] of formData) {\n                        parts.push({ field: name, value });\n                        total += encoder.encode(`--${boundary}\\r\\n`).byteLength;\n\n                        if (value instanceof File) {\n                            total += encoder.encode(\n                                `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                                    `Content-Type: ${\n                                        value.type || \"application/octet-stream\"\n                                    }\\r\\n\\r\\n`\n                            ).byteLength;\n                            total += value.size + 2;\n                        } else {\n                            total += encoder.encode(\n                                `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`\n                            ).byteLength;\n                        }\n                    }\n                    total += encoder.encode(`--${boundary}--\\r\\n`).byteLength;\n\n                    let loaded = 0;\n\n                    req.body = new ReadableStream({\n                        async start(controller) {\n                            const write = (data: Uint8Array) => {\n                                controller.enqueue(data);\n                                loaded += data.byteLength;\n\n                                const progress = Math.round(\n                                    (loaded / total) * 100\n                                );\n                                dispatchFetch(\"upload-progress\", el, {\n                                    progress: progress.toString(),\n                                    loaded: loaded.toString(),\n                                    total: total.toString(),\n                                });\n                            };\n\n                            dispatchFetch(\"upload-progress\", el, {\n                                progress: \"0\",\n                                loaded: \"0\",\n                                total: total.toString(),\n                            });\n\n                            try {\n                                for (const { field, value } of parts) {\n                                    write(encoder.encode(`--${boundary}\\r\\n`));\n\n                                    if (value instanceof File) {\n                                        write(\n                                            encoder.encode(\n                                                `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                                                    `Content-Type: ${\n                                                        value.type ||\n                                                        \"application/octet-stream\"\n                                                    }\\r\\n\\r\\n`\n                                            )\n                                        );\n\n                                        const reader = value\n                                            .stream()\n                                            .getReader();\n                                        try {\n                                            while (true) {\n                                                const { done, value: chunk } =\n                                                    await reader.read();\n                                                if (done) break;\n                                                write(chunk);\n                                            }\n                                        } finally {\n                                            reader.releaseLock();\n                                        }\n                                        write(encoder.encode(\"\\r\\n\"));\n                                    } else {\n                                        write(\n                                            encoder.encode(\n                                                `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`\n                                            )\n                                        );\n                                    }\n                                }\n\n                                write(encoder.encode(`--${boundary}--\\r\\n`));\n\n                                if (loaded < total) {\n                                    dispatchFetch(\"upload-progress\", el, {\n                                        progress: \"100\",\n                                        loaded: total.toString(),\n                                        total: total.toString(),\n                                    });\n                                }\n\n                                controller.close();\n                            } catch (error) {\n                                controller.error(error);\n                            }\n                        },\n                    });\n\n                    // Override content-type header with the boundary\n                    headers[\n                        \"Content-Type\"\n                    ] = `multipart/form-data; boundary=${boundary}`;\n                    // Set duplex mode for streaming uploads\n                    (req as any).duplex = \"half\";\n                } else {\n                    req.body = formData;\n                }\n            } else {\n                req.body = formParams;\n            }\n        } else {\n            throw runtimeErr(\"FetchInvalidContentType\", {\n                action,\n                contentType,\n            });\n        }\n\n        dispatchFetch(STARTED, el, {});\n        urlInstance.search = queryParams.toString();\n\n        try {\n            await fetchEventSource(urlInstance.toString(), el, req);\n        } catch (error) {\n            if (!isWrongContent(error)) {\n                throw runtimeErr(\"FetchFailed\", { method, url, error });\n            }\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven’t\n            // set the content-type to text/event-stream\n        }\n    } finally {\n        dispatchFetch(FINISHED, el, {});\n        cleanupFn();\n    }\n};\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n    id: string;\n    event: string;\n    data: string;\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void\n): Promise<void> {\n    const reader = stream.getReader();\n    let result = await reader.read();\n    while (!result.done) {\n        onChunk(result.value);\n        result = await reader.read();\n    }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (!buffer) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10) lineStart = ++position; // skip to next char\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58: // :\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n                    case 13: // \\r\n                        discardTrailingNewline = true;\n                    case 10: // \\n\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) break; // Wait for the next arr and then continue parsing\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength)\n            buffer = undefined; // we've finished reading it\n        else if (lineStart) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\nfunction getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (!line.length) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset =\n                fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    message.data = message.data\n                        ? `${message.data}\\n${value}`\n                        : value;\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = +value;\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n};\n\nconst newMessage = (): EventSourceMessage => ({\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n});\n\ninterface FetchEventSourceInit extends RequestInit {\n    headers?: Record<string, string>;\n    onopen?: (response: Response) => Promise<void>;\n    onmessage?: (ev: EventSourceMessage) => void;\n    onclose?: () => void;\n    onerror?: (err: any) => number | null | undefined | void;\n    openWhenHidden?: boolean;\n    fetch?: typeof fetch;\n    retryInterval?: number;\n    retryScaler?: number;\n    retryMaxWaitMs?: number;\n    retryMaxCount?: number;\n    overrides?: ResponseOverrides;\n}\n\nfunction fetchEventSource(\n    input: RequestInfo,\n    el: HTMLOrSVG,\n    {\n        signal: inputSignal,\n        headers: inputHeaders,\n        onopen: inputOnOpen,\n        onmessage,\n        onclose,\n        onerror,\n        openWhenHidden,\n        fetch: inputFetch,\n        retryInterval = 1_000,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n        overrides,\n        ...rest\n    }: FetchEventSourceInit\n) {\n    return new Promise<void>((resolve, reject) => {\n        // make a copy of the input headers since we may modify it below:\n        const headers: Record<string, string> = {\n            ...inputHeaders,\n        };\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) create(); // page is now visible again, recreate request.\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch || window.fetch;\n        const onopen = inputOnOpen || (() => {});\n\n        let retries = 0;\n        let baseRetryInterval = retryInterval;\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                // on successful connection, reset the retry logic\n                retries = 0;\n                retryInterval = baseRetryInterval;\n\n                await onopen(response);\n\n                const dispatchNonSSE = async (\n                    dispatchType: string,\n                    response: Response,\n                    name: string,\n                    overrides?: ResponseOverrides,\n                    ...argNames: string[]\n                ) => {\n                    const argsRaw: Record<string, string> = {\n                        [name]: await response.text(),\n                    };\n                    for (const n of argNames) {\n                        let v = response.headers.get(`datastar-${kebab(n)}`);\n                        if (overrides) {\n                            const o = (overrides as any)[n];\n                            if (o)\n                                v =\n                                    typeof o === \"string\"\n                                        ? o\n                                        : JSON.stringify(o);\n                        }\n                        if (v) argsRaw[n] = v;\n                    }\n\n                    dispatchFetch(dispatchType, el, argsRaw);\n                    dispose();\n                    resolve();\n                };\n\n                const ct = response.headers.get(\"Content-Type\");\n                if (ct?.includes(\"text/html\")) {\n                    return await dispatchNonSSE(\n                        EventTypePatchElements,\n                        response,\n                        \"elements\",\n                        overrides,\n                        \"selector\",\n                        \"mode\",\n                        \"useViewTransition\"\n                    );\n                }\n\n                if (ct?.includes(\"application/json\")) {\n                    return await dispatchNonSSE(\n                        EventTypePatchSignals,\n                        response,\n                        \"signals\",\n                        overrides,\n                        \"onlyIfMissing\"\n                    );\n                }\n\n                if (ct?.includes(\"text/javascript\")) {\n                    const script = document.createElement(\"script\");\n                    const scriptAttributesHeader = response.headers.get(\n                        \"datastar-script-attributes\"\n                    );\n\n                    if (scriptAttributesHeader) {\n                        for (const [name, value] of Object.entries(\n                            JSON.parse(scriptAttributesHeader)\n                        )) {\n                            script.setAttribute(name, value as string);\n                        }\n                    }\n                    script.textContent = await response.text();\n                    document.head.appendChild(script);\n                    dispose();\n                    return;\n                }\n\n                await getBytes(\n                    response.body!,\n                    getLines(\n                        getMessages(\n                            (id) => {\n                                if (id) {\n                                    // signals the id and send it back on the next retry:\n                                    headers[\"last-event-id\"] = id;\n                                } else {\n                                    // don't send the last-event-id header anymore:\n                                    delete headers[\"last-event-id\"];\n                                }\n                            },\n                            (retry) => {\n                                baseRetryInterval = retryInterval = retry;\n                            },\n                            onmessage\n                        )\n                    )\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven’t aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) || retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval = Math.min(\n                            retryInterval * retryScaler,\n                            retryMaxWaitMs\n                        ); // exponential backoff\n                        if (++retries >= retryMaxCount) {\n                            dispatchFetch(RETRIES_FAILED, el, {});\n                            // we should not retry anymore:\n                            dispose();\n                            reject(\"Max retries reached.\"); // Max retries reached, check your server or network connection\n                        } else {\n                            console.error(\n                                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n","// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request.\n// Description: Sends a `DELETE` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n","// Icon: ic:baseline-get-app\n// Slug: Sends a `GET` request.\n// Description: Sends a `GET` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const GET = createHttpMethod('get', 'GET')\n","// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request.\n// Description: Sends a `PATCH` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n","// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request.\n// Description: Sends a `POST` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const POST = createHttpMethod('post', 'POST')\n","// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request.\n// Description: Sends a `PUT` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n","/**\n * Laravel CSRF Token Utilities\n * Handles automatic CSRF token injection for Laravel routes\n */\n\n/**\n * Get CSRF token from Laravel's meta tag\n */\nexport function getCSRFToken(): string | null {\n    const metaTag = document.querySelector('meta[name=\"csrf-token\"]');\n    return metaTag?.getAttribute(\"content\") || null;\n}\n\n/**\n * Check if user already provided CSRF token manually\n */\nexport function hasManualCSRF(\n    userHeaders: Record<string, string> = {}\n): boolean {\n    const csrfHeaders = [\"X-CSRF-TOKEN\", \"x-csrf-token\", \"X-Csrf-Token\"];\n    return csrfHeaders.some((header) => userHeaders[header]);\n}\n\n/**\n * Get CSRF headers for Laravel routes (only if not manually provided)\n */\nexport function getCSRFHeaders(\n    userHeaders: Record<string, string> = {}\n): Record<string, string> {\n    if (hasManualCSRF(userHeaders)) {\n        return {}; // Don't override manual CSRF\n    }\n\n    const csrfToken = getCSRFToken();\n    return csrfToken ? { \"X-CSRF-TOKEN\": csrfToken } : {};\n}\n","// hyper-ext/plugins/backend/actions/fetch-laravel.ts\nimport type { ActionPlugin } from \"../../../../datastar/engine/types\";\nimport {\n    createHttpMethod,\n    type FetchArgs,\n} from \"../../../../datastar/plugins/backend/actions/fetch\";\nimport { getCSRFHeaders } from \"../../../utils/csrf\";\n\n/**\n * Factory for creating Laravel-aware HTTP method plugins with auto-CSRF injection\n * Enhances base Datastar fetch with Laravel CSRF token handling\n */\nexport const createHttpMethodWithCSRF = (\n    name: string,\n    method: string\n): ActionPlugin => {\n    const basePlugin = createHttpMethod(name, method);\n\n    return {\n        ...basePlugin,\n        fn: async (ctx, url: string, args: FetchArgs) => {\n            // Enhance args with CSRF headers\n            const enhancedArgs = {\n                ...args,\n                headers: {\n                    ...args?.headers,\n                    ...getCSRFHeaders(args?.headers),\n                },\n            };\n\n            // Delegate to base plugin with enhanced args\n            return basePlugin.fn(ctx, url, enhancedArgs);\n        },\n    };\n};\n","// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request with Laravel CSRF token.\n// Description: Sends a `POST` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const POSTX = createHttpMethodWithCSRF(\"postx\", \"POST\");\n","// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request with Laravel CSRF token.\n// Description: Sends a `PUT` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const PUTX = createHttpMethodWithCSRF(\"putx\", \"PUT\");\n","// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request with Laravel CSRF token.\n// Description: Sends a `PATCH` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const PATCHX = createHttpMethodWithCSRF(\"patchx\", \"PATCH\");\n","// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request with Laravel CSRF token.\n// Description: Sends a `DELETE` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const DELETEX = createHttpMethodWithCSRF(\"deletex\", \"DELETE\");\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/actions/navigate.ts\n// Icon: material-symbols:navigation\n// Slug: Enhanced navigate action with JSON query support and consistent behavior.\n// Description: Professional navigate action that supports both string URLs and JSON query objects.\n\nimport type {\n    ActionPlugin,\n    RuntimeContext,\n} from \"../../../../datastar/engine/types\";\n\n/**\n * Enhanced Navigate Action - Professional Navigation with JSON Support\n *\n * Provides consistent navigation behavior between frontend expressions and backend responses.\n * Supports both traditional URL strings and JSON query parameter objects.\n *\n * USAGE EXAMPLES:\n *\n * Traditional URL Navigation:\n * @navigate('/dashboard')                              // Basic navigation\n * @navigate('/users', 'main')                         // Navigation with key\n * @navigate('/contacts?search=john', 'filters')       // URL with query params\n *\n * JSON Query Navigation (NEW):\n * @navigate({search: 'john', page: 1}, 'filters')                    // JSON queries\n * @navigate({search: 'john', page: 1}, 'filters', {merge: true})     // JSON with merge\n * @navigate({}, 'clear')                                             // Clear all queries\n *\n * Advanced Options:\n * @navigate('/users', 'main', {merge: false})                       // Explicit no merge\n * @navigate('/users', 'main', {only: ['search', 'category']})       // Only preserve specific\n * @navigate('/users', 'main', {except: ['page']})                   // Preserve except specific\n * @navigate('/users', 'main', {replace: true})                      // Replace instead of push\n *\n * Mixed Usage:\n * @navigate('/contacts', 'main', {queries: {search: $searchTerm}, merge: true})\n */\nexport const NavigateAction: ActionPlugin = {\n    type: \"action\",\n    name: \"navigate\",\n    fn: (\n        ctx: RuntimeContext,\n        urlOrQueries: string | Record<string, any>,\n        key: string = \"true\",\n        options: NavigateOptions = {}\n    ): void => {\n        // Input validation\n        if (!urlOrQueries) {\n            throw ctx.runtimeErr(\"NavigateUrlRequired\", {\n                received: String(urlOrQueries),\n            });\n        }\n\n        if (typeof key !== \"string\") {\n            throw ctx.runtimeErr(\"NavigateKeyMustBeString\", {\n                received: String(key),\n            });\n        }\n\n        try {\n            // Process the URL based on input type\n            const finalUrl = processNavigationInput(urlOrQueries, options);\n\n            // Ensure hyperNavigate is available\n            if (typeof (window as any).hyperNavigate !== \"function\") {\n                console.error(\n                    \"hyperNavigate is not available. Ensure GlobalNavigate watcher is loaded.\"\n                );\n                window.location.href = finalUrl;\n                return;\n            }\n\n            // Execute navigation\n            (window as any).hyperNavigate(finalUrl, key);\n\n            // Handle browser history if specified\n            if (options.replace) {\n                setTimeout(() => {\n                    history.replaceState(null, \"\", finalUrl);\n                }, 0);\n            }\n        } catch (error) {\n            console.error(\"Navigate action failed:\", error);\n\n            // Fallback to standard navigation\n            const fallbackUrl =\n                typeof urlOrQueries === \"string\"\n                    ? urlOrQueries\n                    : `${window.location.pathname}?${buildQueryString(\n                          urlOrQueries\n                      )}`;\n            window.location.href = fallbackUrl;\n        }\n    },\n};\n\n/**\n * Navigation options interface - matches both frontend and backend\n */\ninterface NavigateOptions {\n    merge?: boolean; // Whether to merge with existing query parameters\n    only?: string[]; // Only preserve these query parameters\n    except?: string[]; // Preserve all query parameters except these\n    replace?: boolean; // Use replaceState instead of pushState\n    queries?: Record<string, any>; // Additional queries to merge (when urlOrQueries is a path)\n}\n\n/**\n * Process navigation input based on type and options\n */\nfunction processNavigationInput(\n    urlOrQueries: string | Record<string, any>,\n    options: NavigateOptions\n): string {\n    if (typeof urlOrQueries === \"string\") {\n        // Traditional string URL\n        return processStringUrl(urlOrQueries, options);\n    } else {\n        // JSON query object\n        return processJsonQueries(urlOrQueries, options);\n    }\n}\n\n/**\n * Process traditional string URL with options\n */\nfunction processStringUrl(url: string, options: NavigateOptions): string {\n    // Handle additional queries option\n    if (options.queries && Object.keys(options.queries).length > 0) {\n        url = mergeQueriesIntoUrl(url, options.queries);\n    }\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(url, options.only, options.except);\n    }\n\n    return url;\n}\n\n/**\n * Process JSON query object into URL\n */\nfunction processJsonQueries(\n    queries: Record<string, any>,\n    options: NavigateOptions\n): string {\n    // Build base URL from current location\n    const currentPath = window.location.pathname;\n    const queryString = buildQueryString(queries);\n\n    const baseUrl = queryString ? `${currentPath}?${queryString}` : currentPath;\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(baseUrl, options.only, options.except);\n    }\n\n    return baseUrl;\n}\n\n/**\n * Determine if merge logic should be applied\n */\nfunction shouldApplyMerge(options: NavigateOptions): boolean {\n    // Explicit merge setting takes precedence\n    if (options.merge !== undefined) {\n        return options.merge;\n    }\n\n    // Implied merge when using only/except\n    if (options.only || options.except) {\n        return true;\n    }\n\n    // Default: no merge (explicit behavior)\n    return false;\n}\n\n/**\n * Build query string from object, handling various value types\n */\nfunction buildQueryString(queries: Record<string, any>): string {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(queries)) {\n        if (value === null || value === undefined) {\n            // Skip null/undefined values\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            // Handle arrays (for multi-select, checkboxes, etc.)\n            value.forEach((item) => {\n                if (item !== null && item !== undefined && item !== \"\") {\n                    params.append(key, String(item));\n                }\n            });\n        } else if (value === \"\" || String(value).trim() === \"\") {\n            // Skip empty strings\n            continue;\n        } else {\n            // Handle primitive values\n            params.set(key, String(value));\n        }\n    }\n\n    return params.toString();\n}\n\n/**\n * Merge additional queries into existing URL\n */\nfunction mergeQueriesIntoUrl(\n    url: string,\n    additionalQueries: Record<string, any>\n): string {\n    try {\n        let targetUrl: URL;\n\n        if (url.startsWith(\"?\")) {\n            targetUrl = new URL(\n                `${window.location.pathname}${url}`,\n                window.location.origin\n            );\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n        } else {\n            targetUrl = new URL(url, window.location.origin);\n        }\n\n        // Add additional queries\n        for (const [key, value] of Object.entries(additionalQueries)) {\n            if (value === null || value === undefined || value === \"\") {\n                targetUrl.searchParams.delete(key);\n            } else if (Array.isArray(value)) {\n                targetUrl.searchParams.delete(key);\n                value.forEach((item) => {\n                    if (item !== null && item !== undefined && item !== \"\") {\n                        targetUrl.searchParams.append(key, String(item));\n                    }\n                });\n            } else {\n                targetUrl.searchParams.set(key, String(value));\n            }\n        }\n\n        return `${targetUrl.pathname}${targetUrl.search}`;\n    } catch (error) {\n        console.warn(\"Error merging queries into URL:\", error);\n        return url;\n    }\n}\n\n/**\n * Merge query parameters with current URL - consistent with attribute plugin\n */\nfunction mergeQueryParameters(\n    url: string,\n    only?: string[],\n    except?: string[]\n): string {\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL (same logic as attribute plugin)\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = only\n                ? only.includes(key)\n                : !except || !except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error merging query parameters:\", error);\n        return url;\n    }\n}\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Traditional string navigation\n * @navigate('/users')                                    // Clean navigation\n * @navigate('/users?active=true', 'main')               // With queries\n *\n * // JSON query navigation\n * @navigate({search: $searchTerm, page: 1})             // Pure queries\n * @navigate({category: 'work'}, 'filters')              // With key\n *\n * // Advanced options\n * @navigate('/users', 'main', {\n *   queries: {search: $searchTerm},\n *   merge: true,\n *   except: ['page']\n * })\n *\n * // Clear all queries\n * @navigate({})                                         // Clear everything\n * @navigate('/')                                        // Clean slate\n *\n * // Array handling\n * @navigate({tags: ['php', 'laravel'], status: 'active'})  // Multi-value params\n */\n","// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../engine/consts'\nimport { aliasify } from '../../../engine/engine'\nimport type { InitContext, WatcherPlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport { supportsViewTransitions } from '../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) => {\n      if (\n        supportsViewTransitions &&\n        args.useViewTransition?.trim() === 'true'\n      ) {\n        document.startViewTransition(() => onPatchElements(ctx, args))\n      } else {\n        onPatchElements(ctx, args)\n      }\n    })\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements = '',\n    selector,\n    mode = DefaultElementPatchMode,\n  }: Record<string, string>,\n) {\n  const { initErr } = ctx\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${elements}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (\n    !selector &&\n    (mode === ElementPatchModeOuter || mode === ElementPatchModeReplace)\n  ) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.error(\n            initErr('NoTargetsFound', {\n              id: child.id,\n            }),\n          )\n          continue\n        }\n      }\n\n      applyToTargets(ctx, mode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.error(\n        initErr('NoTargetsFound', {\n          selector: selector,\n        }),\n      )\n      return\n    }\n\n    applyToTargets(ctx, mode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nfunction execute(target: Element): void {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nfunction applyToTargets(\n  { initErr }: InitContext,\n  mode: string,\n  element: DocumentFragment | Element,\n  capturedTargets: Iterable<Element>,\n) {\n  for (const target of capturedTargets) {\n    const cloned = element.cloneNode(true) as Element\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, cloned, mode)\n      execute(target)\n    } else {\n      execute(cloned)\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', { mode })\n      }\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newContent: DocumentFragment | Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) &&\n      newContent instanceof HTMLElement &&\n      newContent.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all IDs contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of IDs,\n  // which allows for a looser definition of \"matching\" than traditional ID matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven’t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn’t match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newNode.getAttribute('value') !== oldNode.getAttribute('value')) {\n        oldNode.value = newNode.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasify('preserve-attr')) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn’t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n","// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\nimport type { WatcherPlugin } from '../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n","// hyper-front/src/hyper-ext/plugins/backend/watchers/popstateHandler.ts\n// Icon: material-symbols:history\n// Slug: Handles browser back/forward navigation intelligently.\n// Description: Smart popstate handler that respects navigation state and opt-in behavior.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\n// Global flag OUTSIDE the function - proper scope!\nlet popstateInitialized = false;\n\nexport const PopstateHandler: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"popstateHandler\",\n    onGlobalInit: () => {\n        // Only initialize once globally\n        if (!popstateInitialized) {\n            popstateInitialized = true;\n\n            window.addEventListener(\"popstate\", function (event) {\n                // Check if we have any elements with data-navigate on the page\n                const hasNavigateElements =\n                    document.querySelector(\"[data-navigate]\");\n\n                // If no navigation elements exist, just reload (original behavior)\n                if (!hasNavigateElements) {\n                    window.location.reload();\n                    return;\n                }\n\n                // If we have navigation elements, try reactive navigation\n                // Check if hyperNavigate is available (it should be via GlobalNavigate watcher)\n                if (typeof (window as any).hyperNavigate === \"function\") {\n                    // Determine appropriate navigation key based on state or default\n                    const navigationKey =\n                        event.state?.navigationKey || \"popstate\";\n                    (window as any).hyperNavigate(\n                        window.location.href,\n                        navigationKey\n                    );\n                } else {\n                    // Fallback to reload if hyperNavigate isn't available yet\n                    window.location.reload();\n                }\n            });\n        }\n    },\n};\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/globalNavigate.ts\n// Icon: material-symbols:public\n// Slug: Enhanced global navigation with comprehensive options support.\n// Description: Provides consistent navigation API across all frontend/backend interactions.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\n// Global flag to ensure this runs only once\nlet globalNavigateSetup = false;\n\nexport const GlobalNavigate: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"globalNavigate\",\n    onGlobalInit: (ctx) => {\n        // Only initialize once globally\n        if (!globalNavigateSetup) {\n            globalNavigateSetup = true;\n            setupEnhancedGlobalNavigation(ctx);\n        }\n    },\n};\n\n/**\n * Navigation options interface - matches backend exactly\n */\ninterface NavigationOptions {\n    merge?: boolean; // Whether to merge with existing query parameters\n    only?: string[]; // Only preserve these query parameters\n    except?: string[]; // Preserve all query parameters except these\n    replace?: boolean; // Use replaceState instead of pushState\n}\n\n/**\n * Set up enhanced global navigation functions with comprehensive options support\n *\n * Provides perfect consistency between:\n * - Frontend: data-navigate, @navigate()\n * - Backend: hyper()->navigate(), hyper()->navigateWith(), etc.\n */\nfunction setupEnhancedGlobalNavigation(ctx: any) {\n    const { actions, startBatch, endBatch } = ctx;\n\n    /**\n     * Enhanced navigation with comprehensive options support\n     *\n     * @param url Target URL or query object\n     * @param key Navigation key for Datastar routing\n     * @param options Navigation options (merge, only, except, replace)\n     */\n    const navigateWithOptions = (\n        url: string,\n        key: string = \"true\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            startBatch();\n\n            // Get the GET action from Datastar's action registry\n            const getAction = actions.get || actions.GET;\n\n            if (!getAction) {\n                throw new Error(\n                    \"GET action not found in Datastar actions registry\"\n                );\n            }\n\n            // Prepare fetch arguments with navigate headers\n            const fetchArgs = {\n                headers: {\n                    \"HYPER-NAVIGATE\": \"true\",\n                    \"HYPER-NAVIGATE-KEY\": key,\n                },\n            };\n\n            // Create proper runtime context\n            const runtimeCtx = {\n                ...ctx,\n                el: document.body,\n            };\n\n            // Call GET action using Datastar's infrastructure\n            getAction.fn(runtimeCtx, url, fetchArgs);\n\n            // Handle browser history\n            setTimeout(() => {\n                if (options.replace) {\n                    history.replaceState(null, \"\", url);\n                } else {\n                    history.pushState(null, \"\", url);\n                }\n            }, 0);\n        } catch (error) {\n            console.error(\"Enhanced navigate failed:\", error);\n            // Fallback to normal navigation\n            window.location.href = url;\n        } finally {\n            endBatch();\n        }\n    };\n\n    /**\n     * BASIC NAVIGATION FUNCTIONS\n     */\n\n    // Basic hyperNavigate - backward compatible\n    (window as any).hyperNavigate = (url: string, key: string = \"true\") => {\n        navigateWithOptions(url, key, {});\n    };\n\n    // Enhanced navigation with options - used by backend\n    (window as any).hyperNavigateWithOptions = navigateWithOptions;\n\n    /**\n     * SPECIALIZED NAVIGATION FUNCTIONS\n     */\n\n    // Navigate with explicit merge behavior\n    (window as any).hyperNavigateWith = (\n        url: string,\n        key: string = \"true\",\n        merge: boolean = false,\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge });\n    };\n\n    // Navigate and merge with current parameters\n    (window as any).hyperNavigateMerge = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge: true });\n    };\n\n    // Navigate with clean slate (no merging)\n    (window as any).hyperNavigateClean = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge: false });\n    };\n\n    // Navigate preserving only specific parameters\n    (window as any).hyperNavigateOnly = (\n        url: string,\n        only: string[],\n        key: string = \"true\"\n    ) => {\n        navigateWithOptions(url, key, { merge: true, only });\n    };\n\n    // Navigate preserving all except specific parameters\n    (window as any).hyperNavigateExcept = (\n        url: string,\n        except: string[],\n        key: string = \"true\"\n    ) => {\n        navigateWithOptions(url, key, { merge: true, except });\n    };\n\n    // Navigate using replaceState\n    (window as any).hyperNavigateReplace = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, replace: true });\n    };\n\n    /**\n     * ENHANCED BACK/REFRESH FUNCTIONS\n     */\n\n    // Enhanced hyperBack with options support\n    (window as any).hyperBackWithOptions = (\n        fallbackUrl: string = \"/\",\n        key: string = \"back\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            let backUrl = fallbackUrl;\n\n            // Try to get the previous URL from browser history\n            if (\n                document.referrer &&\n                document.referrer !== window.location.href\n            ) {\n                const referrerUrl = new URL(document.referrer);\n                const currentUrl = new URL(window.location.href);\n\n                // Only use referrer if it's from the same origin\n                if (referrerUrl.origin === currentUrl.origin) {\n                    backUrl = document.referrer;\n                }\n            }\n\n            // Navigate reactively with the specified options\n            navigateWithOptions(backUrl, key, options);\n        } catch (error) {\n            console.error(\"Enhanced hyperBack failed:\", error);\n            // Fallback to simple history.back()\n            if (history.length > 1) {\n                history.back();\n            } else {\n                window.location.href = fallbackUrl;\n            }\n        }\n    };\n\n    // Enhanced hyperRefresh with options support\n    (window as any).hyperRefreshWithOptions = (\n        key: string = \"refresh\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            const currentUrl = window.location.href;\n            navigateWithOptions(currentUrl, key, options);\n        } catch (error) {\n            console.error(\"Enhanced hyperRefresh failed:\", error);\n            // Fallback to regular refresh\n            window.location.reload();\n        }\n    };\n\n    /**\n     * CONVENIENCE FUNCTIONS\n     */\n\n    // Update current page queries\n    (window as any).hyperUpdateQueries = (\n        queries: Record<string, any>,\n        key: string = \"update\",\n        merge: boolean = true\n    ) => {\n        const currentPath = window.location.pathname;\n        const queryString = buildQueryString(queries);\n        const url = queryString ? `${currentPath}?${queryString}` : currentPath;\n\n        navigateWithOptions(url, key, { merge });\n    };\n\n    // Clear specific query parameters\n    (window as any).hyperClearQueries = (\n        paramNames: string[],\n        key: string = \"clear\"\n    ) => {\n        const clearQueries = paramNames.reduce((acc, name) => {\n            acc[name] = null;\n            return acc;\n        }, {} as Record<string, null>);\n\n        (window as any).hyperUpdateQueries(clearQueries, key, true);\n    };\n\n    // Reset pagination while preserving filters\n    (window as any).hyperResetPagination = (key: string = \"pagination\") => {\n        (window as any).hyperUpdateQueries({ page: 1 }, key, true);\n    };\n\n    /**\n     * BACKWARD COMPATIBILITY FUNCTIONS\n     */\n\n    // Backward compatible hyperBack (without options)\n    (window as any).hyperBack = (\n        fallbackUrl: string = \"/\",\n        key: string = \"back\"\n    ) => {\n        (window as any).hyperBackWithOptions(fallbackUrl, key, { merge: true });\n    };\n\n    // Backward compatible hyperRefresh (without options)\n    (window as any).hyperRefresh = (key: string = \"refresh\") => {\n        (window as any).hyperRefreshWithOptions(key, { merge: true });\n    };\n\n    // Simple reload function for hard refreshes\n    (window as any).hyperReload = () => {\n        window.location.reload();\n    };\n\n    /**\n     * DEBUGGING HELPERS\n     */\n\n    // Log current navigation state\n    (window as any).hyperDebugNavigation = () => {\n        console.group(\"🧭 Hyper Navigation Debug\");\n        console.log(\"Current URL:\", window.location.href);\n        console.log(\"Current Path:\", window.location.pathname);\n        console.log(\"Current Query:\", window.location.search);\n        console.log(\n            \"Current Queries:\",\n            Object.fromEntries(new URLSearchParams(window.location.search))\n        );\n        console.log(\"Referrer:\", document.referrer);\n        console.log(\"History Length:\", history.length);\n        console.groupEnd();\n    };\n}\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Build query string from object, handling various value types\n */\nfunction buildQueryString(queries: Record<string, any>): string {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(queries)) {\n        if (value === null || value === undefined) {\n            // Skip null/undefined values - they clear parameters\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            // Handle arrays (for multi-select, checkboxes, etc.)\n            value.forEach((item) => {\n                if (item !== null && item !== undefined && item !== \"\") {\n                    params.append(key, String(item));\n                }\n            });\n        } else if (value === \"\" || String(value).trim() === \"\") {\n            // Skip empty strings\n            continue;\n        } else {\n            // Handle primitive values\n            params.set(key, String(value));\n        }\n    }\n\n    return params.toString();\n}\n\n/**\n * EXPOSED API SUMMARY\n *\n * Basic Navigation:\n * - hyperNavigate(url, key?)\n * - hyperNavigateWithOptions(url, key?, options?)\n *\n * Explicit Control:\n * - hyperNavigateWith(url, key?, merge?, options?)\n * - hyperNavigateMerge(url, key?, options?)\n * - hyperNavigateClean(url, key?, options?)\n * - hyperNavigateOnly(url, only[], key?)\n * - hyperNavigateExcept(url, except[], key?)\n * - hyperNavigateReplace(url, key?, options?)\n *\n * Enhanced Back/Refresh:\n * - hyperBackWithOptions(fallback?, key?, options?)\n * - hyperRefreshWithOptions(key?, options?)\n *\n * Convenience:\n * - hyperUpdateQueries(queries{}, key?, merge?)\n * - hyperClearQueries(names[], key?)\n * - hyperResetPagination(key?)\n *\n * Utilities:\n * - hyperReload()\n * - hyperDebugNavigation()\n *\n * Backward Compatible:\n * - hyperBack(fallback?, key?)\n * - hyperRefresh(key?)\n */\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/attributes/navigate.ts\n// Icon: material-symbols:navigation\n// Slug: Enhanced reactive navigation with Datastar-standard modifiers.\n// Description: Professional navigation with explicit merge control and standard modifier support.\n\nimport type { AttributePlugin } from \"../../../datastar/engine/types\";\n\n/**\n * Enhanced Navigate Attribute - Professional Navigation System\n *\n * Follows Datastar modifier conventions for explicit, predictable navigation.\n * No more \"smart defaults\" - developers control exactly what happens.\n *\n * MODIFIER EXAMPLES:\n * data-navigate=\"true\"                                    // Basic navigation (no merge)\n * data-navigate__key.sidebar=\"true\"                       // Navigation with key\n * data-navigate__merge=\"true\"                            // Explicit merge behavior\n * data-navigate__merge__key.main=\"true\"                  // Merge with key\n * data-navigate__only.search,category=\"true\"             // Only preserve specific params\n * data-navigate__except.page=\"true\"                      // Preserve all except specific\n * data-navigate__replace=\"true\"                          // Replace instead of push history\n * data-navigate__debounce.300ms=\"true\"                   // Debounce navigation\n *\n * COMPLEX EXAMPLES:\n * data-navigate__merge__except.page__debounce.500ms=\"true\"    // Comprehensive control\n * data-navigate__key.filters__only.search,category=\"true\"     // Granular parameter control\n */\nexport const Navigate: AttributePlugin = {\n    type: \"attribute\",\n    name: \"navigate\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: (ctx) => {\n        const { el, value, mods, runtimeErr } = ctx;\n\n        // Parse navigation configuration from modifiers\n        const navigateConfig = parseNavigateModifiers(mods, value.trim());\n\n        if (!navigateConfig) {\n            throw runtimeErr(\"InvalidNavigateConfiguration\", {\n                value,\n                modifiers: Array.from(mods.keys()),\n            });\n        }\n\n        // Create timing wrapper if specified\n        const executeNavigation = navigateConfig.timing\n            ? createTimingWrapper(handleNavigation, navigateConfig.timing)\n            : handleNavigation;\n\n        // Create click handler\n        const handleClick = (event: Event) => {\n            const target = event.target as HTMLElement;\n            const link = target.closest(\"a[href]\") as HTMLAnchorElement;\n\n            if (!link || !shouldInterceptNavigation(link)) {\n                return;\n            }\n\n            event.preventDefault();\n            executeNavigation(link.href, navigateConfig);\n        };\n\n        // Create form submit handler for GET forms\n        const handleSubmit = (event: Event) => {\n            const form = event.target as HTMLFormElement;\n\n            if (!shouldInterceptFormSubmit(form)) {\n                return;\n            }\n\n            event.preventDefault();\n\n            const formData = new FormData(form);\n            const url = new URL(form.action, window.location.href);\n\n            // Add form data to URL params\n            for (const [key, value] of formData.entries()) {\n                if (typeof value === \"string\") {\n                    url.searchParams.set(key, value);\n                }\n            }\n\n            executeNavigation(url.toString(), navigateConfig);\n        };\n\n        // Attach event listeners\n        el.addEventListener(\"click\", handleClick);\n        el.addEventListener(\"submit\", handleSubmit);\n\n        return () => {\n            el.removeEventListener(\"click\", handleClick);\n            el.removeEventListener(\"submit\", handleSubmit);\n        };\n    },\n};\n\n/**\n * Navigation configuration interface\n */\ninterface NavigateConfig {\n    key: string;\n    merge: boolean;\n    only?: string[];\n    except?: string[];\n    replace?: boolean;\n    timing?: TimingConfig;\n}\n\ninterface TimingConfig {\n    type: \"debounce\" | \"throttle\" | \"delay\";\n    duration: number;\n    leading?: boolean;\n}\n\n/**\n * Parse Datastar modifiers into navigation configuration\n *\n * SUPPORTED MODIFIERS:\n * - __key.{keyname} → Sets navigation key\n * - __merge → Enable query parameter merging\n * - __only.{param1,param2} → Only preserve specific parameters\n * - __except.{param1,param2} → Preserve all except specific parameters\n * - __replace → Use replaceState instead of pushState\n * - __debounce.{duration}ms → Debounce navigation\n * - __throttle.{duration}ms → Throttle navigation\n * - __delay.{duration}ms → Simple delay\n */\nfunction parseNavigateModifiers(\n    mods: Map<string, Set<string>>,\n    value: string\n): NavigateConfig | null {\n    if (!value || value.trim() === \"\") {\n        return null;\n    }\n\n    const config: NavigateConfig = {\n        key: \"true\", // Default key\n        merge: false, // EXPLICIT: No more smart defaults!\n        replace: false,\n    };\n\n    // Parse modifiers\n    for (const [modName, modTags] of mods) {\n        switch (modName) {\n            case \"key\":\n                // __key.sidebar → key = \"sidebar\"\n                config.key = modTags.size > 0 ? Array.from(modTags)[0] : \"true\";\n                break;\n\n            case \"merge\":\n                // __merge → merge = true\n                config.merge = true;\n                break;\n\n            case \"only\":\n                // __only.search,category → only = [\"search\", \"category\"]\n                config.only = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"except\":\n                // __except.page → except = [\"page\"]\n                config.except = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"replace\":\n                // __replace → replace = true\n                config.replace = true;\n                break;\n\n            case \"debounce\":\n                // __debounce.300ms → debounce for 300ms\n                config.timing = parseTimingModifier(\"debounce\", modTags);\n                break;\n\n            case \"throttle\":\n                // __throttle.500ms → throttle for 500ms\n                config.timing = parseTimingModifier(\"throttle\", modTags);\n                break;\n\n            case \"delay\":\n                // __delay.1s → simple delay for 1s\n                config.timing = parseTimingModifier(\"delay\", modTags);\n                break;\n        }\n    }\n\n    // Validation: cannot use both only and except\n    if (config.only && config.except) {\n        console.warn(\n            \"Navigate: Cannot use both __only and __except modifiers. Using __only.\"\n        );\n        delete config.except;\n    }\n\n    return config;\n}\n\n/**\n * Parse timing modifier tags into timing configuration\n */\nfunction parseTimingModifier(\n    type: \"debounce\" | \"throttle\" | \"delay\",\n    tags: Set<string>\n): TimingConfig | undefined {\n    const tagArray = Array.from(tags);\n\n    // Find duration tag (e.g., \"300ms\", \"1s\", \"1000\")\n    const durationTag = tagArray.find((tag) => /^\\d+(?:ms|s)?$/.test(tag));\n    if (!durationTag) {\n        console.warn(\n            `Navigate: Invalid ${type} timing - no duration specified`\n        );\n        return undefined;\n    }\n\n    // Parse duration\n    let duration: number;\n    if (durationTag.endsWith(\"ms\")) {\n        duration = parseInt(durationTag.slice(0, -2));\n    } else if (durationTag.endsWith(\"s\")) {\n        duration = parseInt(durationTag.slice(0, -1)) * 1000;\n    } else {\n        duration = parseInt(durationTag); // Assume milliseconds\n    }\n\n    return {\n        type,\n        duration,\n        leading: tagArray.includes(\"leading\"),\n    };\n}\n\n/**\n * Create timing wrapper for navigation function\n */\nfunction createTimingWrapper(\n    fn: (url: string, config: NavigateConfig) => void,\n    timing: TimingConfig\n): (url: string, config: NavigateConfig) => void {\n    switch (timing.type) {\n        case \"debounce\":\n            return createDebounce(fn, timing.duration, timing.leading);\n\n        case \"throttle\":\n            return createThrottle(fn, timing.duration, timing.leading);\n\n        case \"delay\":\n            return createDelay(fn, timing.duration);\n\n        default:\n            return fn;\n    }\n}\n\n/**\n * Simple debounce implementation\n */\nfunction createDebounce<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number,\n    leading?: boolean\n): T {\n    let timeout: ReturnType<typeof setTimeout> | undefined;\n    let hasRun = false;\n\n    return ((...args: Parameters<T>) => {\n        const callNow = leading && !hasRun;\n\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            hasRun = false;\n            if (!leading) fn(...args);\n        }, delay);\n\n        if (callNow) {\n            hasRun = true;\n            fn(...args);\n        }\n    }) as T;\n}\n\n/**\n * Simple throttle implementation\n */\nfunction createThrottle<T extends (...args: any[]) => void>(\n    fn: T,\n    limit: number,\n    leading?: boolean\n): T {\n    let inThrottle = false;\n    let lastArgs: Parameters<T> | null = null;\n\n    return ((...args: Parameters<T>) => {\n        if (!inThrottle) {\n            if (leading !== false) {\n                fn(...args);\n            }\n            inThrottle = true;\n\n            setTimeout(() => {\n                inThrottle = false;\n                if (lastArgs && leading === false) {\n                    fn(...lastArgs);\n                    lastArgs = null;\n                }\n            }, limit);\n        } else {\n            lastArgs = args;\n        }\n    }) as T;\n}\n\n/**\n * Simple delay implementation\n */\nfunction createDelay<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number\n): T {\n    return ((...args: Parameters<T>) => {\n        setTimeout(() => fn(...args), delay);\n    }) as T;\n}\n\n/**\n * Handle navigation with configuration\n */\nfunction handleNavigation(url: string, config: NavigateConfig): void {\n    try {\n        // Process URL with merge configuration\n        const finalUrl = processUrlWithMergeConfig(url, config);\n\n        // Ensure hyperNavigate is available\n        if (typeof (window as any).hyperNavigate !== \"function\") {\n            console.error(\n                \"hyperNavigate not available. Falling back to standard navigation.\"\n            );\n            window.location.href = finalUrl;\n            return;\n        }\n\n        // Use global hyperNavigate\n        (window as any).hyperNavigate(finalUrl, config.key);\n\n        // Handle browser history\n        if (config.replace) {\n            history.replaceState(null, \"\", finalUrl);\n        } else {\n            // hyperNavigate already handles pushState, but we ensure consistency\n            setTimeout(() => {\n                if (window.location.href !== finalUrl) {\n                    history.pushState(null, \"\", finalUrl);\n                }\n            }, 0);\n        }\n    } catch (error) {\n        console.error(\"Navigation failed:\", error);\n        window.location.href = url;\n    }\n}\n\n/**\n * Process URL with merge configuration - EXPLICIT and PREDICTABLE\n */\nfunction processUrlWithMergeConfig(\n    url: string,\n    config: NavigateConfig\n): string {\n    // If no merging, return URL as-is\n    if (!config.merge) {\n        return url;\n    }\n\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = config.only\n                ? config.only.includes(key)\n                : !config.except || !config.except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                // Remove empty parameters\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error processing URL merge:\", error);\n        return url;\n    }\n}\n\n/**\n * Determine if we should intercept navigation for this link\n */\nfunction shouldInterceptNavigation(link: HTMLAnchorElement): boolean {\n    // Skip external links\n    try {\n        const url = new URL(link.href, window.location.href);\n        if (url.origin !== window.location.origin) {\n            return false;\n        }\n    } catch {\n        return false;\n    }\n\n    // Skip download links\n    if (link.hasAttribute(\"download\")) {\n        return false;\n    }\n\n    // Skip explicitly opted-out links\n    if (link.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Determine if we should intercept form submission\n */\nfunction shouldInterceptFormSubmit(form: HTMLFormElement): boolean {\n    // Only handle GET forms\n    if (form.method.toLowerCase() !== \"get\") {\n        return false;\n    }\n\n    // Skip explicitly opted-out forms\n    if (form.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n","import { ResponseInterceptor } from \"../plugins/backend/watchers/responseInterceptor\";\nimport { apply, load, setAlias } from \"../../datastar/engine\";\n\n// Import all your plugins...\nimport { Peek } from \"../../datastar/plugins/actions/peek\";\nimport { SetAll } from \"../../datastar/plugins/actions/setAll\";\nimport { ToggleAll } from \"../../datastar/plugins/actions/toggleAll\";\nimport { Dispatch } from \"../plugins/actions/dispatch\";\nimport { FileUrl } from \"../plugins/actions/fileUrl\";\nimport { Attr } from \"../../datastar/plugins/attributes/attr\";\nimport { Bind } from \"../../datastar/plugins/attributes/bind\";\nimport { Class } from \"../../datastar/plugins/attributes/class\";\nimport { Computed } from \"../../datastar/plugins/attributes/computed\";\nimport { Effect } from \"../../datastar/plugins/attributes/effect\";\nimport { Indicator } from \"../../datastar/plugins/attributes/indicator\";\nimport { JsonSignals } from \"../../datastar/plugins/attributes/jsonSignals\";\nimport { On } from \"../../datastar/plugins/attributes/on\";\nimport { OnIntersect } from \"../../datastar/plugins/attributes/onIntersect\";\nimport { OnInterval } from \"../../datastar/plugins/attributes/onInterval\";\nimport { OnLoad } from \"../../datastar/plugins/attributes/onLoad\";\nimport { OnSignalPatch } from \"../../datastar/plugins/attributes/onSignalPatch\";\nimport { Ref } from \"../../datastar/plugins/attributes/ref\";\nimport { Show } from \"../../datastar/plugins/attributes/show\";\nimport { Signals } from \"../../datastar/plugins/attributes/signals\";\nimport { Style } from \"../../datastar/plugins/attributes/style\";\nimport { Text } from \"../../datastar/plugins/attributes/text\";\nimport { Error } from \"../plugins/attributes/error\";\nimport { For } from \"../plugins/attributes/for\";\nimport { If } from \"../plugins/attributes/if\";\nimport { DELETE } from \"../../datastar/plugins/backend/actions/delete\";\nimport { GET } from \"../../datastar/plugins/backend/actions/get\";\nimport { PATCH } from \"../../datastar/plugins/backend/actions/patch\";\nimport { POST } from \"../../datastar/plugins/backend/actions/post\";\nimport { PUT } from \"../../datastar/plugins/backend/actions/put\";\nimport { POSTX } from \"../plugins/backend/actions/postx\";\nimport { PUTX } from \"../plugins/backend/actions/putx\";\nimport { PATCHX } from \"../plugins/backend/actions/patchx\";\nimport { DELETEX } from \"../plugins/backend/actions/deletex\";\nimport { NavigateAction } from \"../plugins/backend/actions/navigate\";\nimport { PatchElements } from \"../../datastar/plugins/backend/watchers/patchElements\";\nimport { PatchSignals } from \"../../datastar/plugins/backend/watchers/patchSignals\";\nimport { PopstateHandler } from \"../plugins/backend/watchers/popstateHandler\";\nimport { GlobalNavigate } from \"../plugins/backend/watchers/globalNavigate\";\nimport { Navigate } from \"../plugins/attributes/navigate\";\n\nload(\n    // Backend actions\n    GET,\n    POST,\n    PUT,\n    PATCH,\n    DELETE,\n    // Backend actions - Laravel with CSRF\n    POSTX,\n    PUTX,\n    PATCHX,\n    DELETEX,\n    NavigateAction,\n    // Backend watchers\n    ResponseInterceptor,\n    PatchElements,\n    PatchSignals,\n    PopstateHandler,\n    GlobalNavigate,\n\n    // Attributes\n    Attr,\n    Bind,\n    Class,\n    Computed,\n    Effect,\n    Error,\n    For,\n    If,\n    Indicator,\n    JsonSignals,\n    Navigate,\n    On,\n    OnIntersect,\n    OnInterval,\n    OnLoad,\n    OnSignalPatch,\n    Ref,\n    Show,\n    Signals,\n    Style,\n    Text,\n    // Actions\n    Dispatch,\n    Peek,\n    SetAll,\n    ToggleAll,\n    FileUrl\n);\n\napply();\n\nexport { apply, load, setAlias };\n"],"names":["url","scripts","effect","signal","link","path","DELETE","cleanup","root","peek","filtered","mergePatch","key","update","runtimeErr","getPath","el","type","value","syncSignal","computed","startBatch","endBatch","apply","Error","sourceData","evt","response","overrides","buildQueryString","initErr","actions","delay"],"mappings":"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"}