{"version":3,"file":"hyper.js","sources":["../src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts","../src/datastar/engine/consts.ts","../src/datastar/utils/dom.ts","../src/datastar/utils/paths.ts","../src/datastar/utils/text.ts","../src/datastar/engine/errors.ts","../src/datastar/engine/types.ts","../src/datastar/engine/engine.ts","../src/datastar/plugins/actions/peek.ts","../src/datastar/plugins/actions/setAll.ts","../src/datastar/plugins/actions/toggleAll.ts","../src/hyper-ext/plugins/actions/dispatch.ts","../src/hyper-ext/plugins/actions/fileUrl.ts","../src/datastar/plugins/attributes/attr.ts","../src/datastar/plugins/attributes/bind.ts","../src/datastar/plugins/attributes/class.ts","../src/datastar/plugins/attributes/computed.ts","../src/datastar/plugins/attributes/effect.ts","../src/datastar/plugins/backend/shared.ts","../src/datastar/plugins/attributes/indicator.ts","../src/datastar/plugins/attributes/jsonSignals.ts","../src/datastar/utils/tags.ts","../src/datastar/utils/timing.ts","../src/datastar/utils/view-transitions.ts","../src/datastar/plugins/attributes/on.ts","../src/datastar/plugins/attributes/onIntersect.ts","../src/datastar/plugins/attributes/onInterval.ts","../src/datastar/plugins/attributes/onLoad.ts","../src/datastar/plugins/attributes/onSignalPatch.ts","../src/datastar/plugins/attributes/ref.ts","../src/datastar/plugins/attributes/show.ts","../src/datastar/plugins/attributes/signals.ts","../src/datastar/plugins/attributes/style.ts","../src/datastar/plugins/attributes/text.ts","../src/hyper-ext/plugins/attributes/error.ts","../src/hyper-ext/plugins/attributes/for.ts","../src/hyper-ext/plugins/attributes/if.ts","../src/datastar/plugins/backend/actions/fetch.ts","../src/datastar/plugins/backend/actions/delete.ts","../src/datastar/plugins/backend/actions/get.ts","../src/datastar/plugins/backend/actions/patch.ts","../src/datastar/plugins/backend/actions/post.ts","../src/datastar/plugins/backend/actions/put.ts","../src/hyper-ext/utils/csrf.ts","../src/hyper-ext/plugins/backend/actions/fetch-laravel.ts","../src/hyper-ext/plugins/backend/actions/postx.ts","../src/hyper-ext/plugins/backend/actions/putx.ts","../src/hyper-ext/plugins/backend/actions/patchx.ts","../src/hyper-ext/plugins/backend/actions/deletex.ts","../src/hyper-ext/plugins/backend/actions/navigate.ts","../src/datastar/plugins/backend/watchers/patchElements.ts","../src/datastar/plugins/backend/watchers/patchSignals.ts","../src/hyper-ext/plugins/backend/watchers/popstateHandler.ts","../src/hyper-ext/plugins/backend/watchers/globalNavigate.ts","../src/hyper-ext/plugins/attributes/navigate.ts","../src/hyper-ext/bundles/hyper.ts"],"sourcesContent":["// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts\n// Icon: material-symbols:intercept\n// Slug: Essential Laravel behavior handling - production ready.\n// Description: Handles redirects, exceptions, dd/dump with proper Hyper response detection.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\nexport const ResponseInterceptor: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"responseInterceptor\",\n    onGlobalInit: () => {\n        const originalFetch = window.fetch;\n\n        window.fetch = async (...args) => {\n            const [resource, init] = args;\n            const requestUrl = getUrlFromResource(resource);\n\n            // Skip intercepting certain URLs to prevent infinite loops\n            if (shouldSkipUrl(requestUrl)) {\n                return originalFetch(...args);\n            }\n\n            // Check if this is a Datastar request\n            const isDatastarRequest =\n                (init?.headers as Record<string, string>)?.[\n                    \"Datastar-Request\"\n                ] === \"true\" ||\n                (init?.headers as Headers)?.get?.(\"Datastar-Request\") ===\n                    \"true\";\n\n            try {\n                const response = await originalFetch(...args);\n\n                // CRITICAL: Check for Laravel redirects FIRST, before any other detection\n                if (isRedirectResponse(response, requestUrl)) {\n                    const redirectUrl = getRedirectUrl(response);\n                    if (redirectUrl && redirectUrl !== window.location.href) {\n                        window.location.href = redirectUrl; // Full page redirect\n                        return new Response(\"\", { status: 204 });\n                    }\n                }\n\n                // Always let Datastar requests pass through\n                if (isDatastarRequest) {\n                    return response;\n                }\n\n                // Detect Hyper responses\n                const isHyperResponse =\n                    response.headers.get(\"X-Hyper-Response\") === \"true\";\n                const isSSEResponse = response.headers\n                    .get(\"Content-Type\")\n                    ?.includes(\"text/event-stream\");\n                const hasDatastarEvent =\n                    (response.headers\n                        .get(\"Content-Type\")\n                        ?.includes(\"text/event-stream\") &&\n                        response.url.includes(\"datastar\")) ||\n                    response.headers.get(\"event\")?.startsWith(\"datastar-\");\n\n                // Let Datastar handle its own responses\n                if (isHyperResponse || isSSEResponse || hasDatastarEvent) {\n                    return response;\n                }\n\n                // Handle Laravel responses (errors, dd/dump, etc.)\n                try {\n                    await handleLaravelResponse(response, requestUrl);\n                } catch (error) {\n                    if (error instanceof RedirectHandled) {\n                        return new Response(\"\", { status: 204 });\n                    }\n                    throw error;\n                }\n\n                return new Response(\"\", { status: 200 });\n            } catch (error) {\n                if (!(error instanceof RedirectHandled)) {\n                    console.error(\"Network error:\", error);\n                }\n                throw error;\n            }\n        };\n    },\n};\n\n// Custom error class for cleaner flow control\nclass RedirectHandled extends Error {\n    constructor() {\n        super(\"Redirect handled\");\n        this.name = \"RedirectHandled\";\n    }\n}\n\nfunction getUrlFromResource(resource: RequestInfo | URL): string {\n    if (typeof resource === \"string\") return resource;\n    if (resource instanceof URL) return resource.href;\n    if (resource instanceof Request) return resource.url;\n    return String(resource);\n}\n\nfunction shouldSkipUrl(url: string): boolean {\n    // Skip Laravel Boost, debugging tools, and other internal requests\n    const skipPatterns = [\n        \"_boost/browser-logs\",\n        \"_boost/\",\n        \"_debugbar/\",\n        \"_ignition/\",\n        \"telescope/\",\n        \"horizon/\",\n        \".js\",\n        \".css\",\n        \".png\",\n        \".jpg\",\n        \".jpeg\",\n        \".gif\",\n        \".svg\",\n        \".ico\",\n        \".woff\",\n        \".woff2\",\n        \".ttf\",\n        \".eot\",\n    ];\n\n    return skipPatterns.some((pattern) => url.includes(pattern));\n}\n\nasync function handleLaravelResponse(\n    response: Response,\n    requestUrl: string\n): Promise<void> {\n    // Handle redirects first\n    if (isRedirectResponse(response, requestUrl)) {\n        const redirectUrl = getRedirectUrl(response);\n        if (redirectUrl && redirectUrl !== window.location.href) {\n            window.location.replace(redirectUrl);\n            throw new RedirectHandled();\n        }\n        return;\n    }\n\n    // Handle error responses and dd/dump\n    if (response.status >= 400) {\n        const html = await response.text();\n        if (isLaravelSpecialResponse(html)) {\n            replaceDocument(html);\n        }\n        return;\n    }\n\n    // Handle successful HTML responses\n    const contentType = response.headers.get(\"Content-Type\") || \"\";\n    if (contentType.includes(\"text/html\")) {\n        const html = await response.text();\n        if (isLaravelSpecialResponse(html)) {\n            replaceDocument(html);\n        }\n    }\n}\n\nfunction isRedirectResponse(response: Response, originalUrl: string): boolean {\n    return (\n        [301, 302, 303, 307, 308].includes(response.status) ||\n        (response.url && response.url !== originalUrl) ||\n        !!response.headers.get(\"Location\")\n    );\n}\n\nfunction getRedirectUrl(response: Response): string | null {\n    let redirectUrl = response.url || response.headers.get(\"Location\");\n\n    if (!redirectUrl) return null;\n\n    // Make relative URLs absolute\n    if (redirectUrl.startsWith(\"/\")) {\n        redirectUrl = window.location.origin + redirectUrl;\n    }\n\n    return redirectUrl;\n}\n\nfunction isLaravelSpecialResponse(html: string): boolean {\n    // Laravel error pages (Ignition, Whoops)\n    if (\n        html.includes(\"ignition-\") ||\n        html.includes(\"data-ignition\") ||\n        html.includes(\"Whoops\\\\\") ||\n        html.includes(\"whoops-container\") ||\n        (html.includes(\"Illuminate\\\\\") && html.includes(\"Exception\"))\n    ) {\n        return true;\n    }\n\n    // Laravel dd/dump responses\n    if (\n        html.includes(\"sf-dump\") ||\n        html.includes(\"var-dump\") ||\n        html.includes(\"symfony-var-dumper\") ||\n        html.includes(\"dump-container\")\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction replaceDocument(html: string): void {\n    try {\n        // Modern approach: Parse HTML and replace document content\n        const parser = new DOMParser();\n        const newDoc = parser.parseFromString(html, \"text/html\");\n\n        // Replace the entire document\n        document.documentElement.innerHTML = newDoc.documentElement.innerHTML;\n\n        // Update document title if it exists in the new content\n        if (newDoc.title) {\n            document.title = newDoc.title;\n        }\n\n        executeNewScripts();\n    } catch (error) {\n        console.error(\"Failed to replace document:\", error);\n        window.location.reload();\n    }\n}\n\nfunction executeNewScripts(): void {\n    const scripts = document.querySelectorAll(\"script:not([data-executed])\");\n\n    scripts.forEach((element) => {\n        const oldScript = element as HTMLScriptElement;\n        oldScript.setAttribute(\"data-executed\", \"true\");\n\n        const newScript = document.createElement(\"script\");\n        Array.from(oldScript.attributes).forEach((attr) => {\n            newScript.setAttribute(attr.name, attr.value);\n        });\n\n        if (oldScript.src) {\n            newScript.src = oldScript.src;\n        } else {\n            newScript.textContent = oldScript.textContent;\n        }\n\n        if (oldScript.parentNode) {\n            oldScript.parentNode.replaceChild(newScript, oldScript);\n        }\n    });\n}\n","// This is auto-generated by Datastar. DO NOT EDIT.\nconst lol = /🖕JS_DS🚀/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\n\nexport const DATASTAR = \"datastar\";\nexport const DATASTAR_REQUEST = \"Datastar-Request\";\n\n// #region Defaults\n\n// #region Default durations\n\n// The default duration for retrying SSE on connection reset. This is part of the underlying retry mechanism of SSE.\nexport const DefaultSseRetryDurationMs = 1000;\n\n// #endregion\n\n\n// #region Default strings\n\n\n// #endregion\n\n\n// #region Default booleans\n\n// Should elements be patched using the ViewTransition API?\nexport const DefaultElementsUseViewTransitions = false;\n\n// Should a given set of signals patch if they are missing?\nexport const DefaultPatchSignalsOnlyIfMissing = false;\n\n// #endregion\n\n\n// #region Enums\n\n// The mode in which a element is patched into the DOM.\n// Morphs the element into the existing element.\nexport const ElementPatchModeOuter = \"outer\"\n// Replaces the inner HTML of the existing element.\nexport const ElementPatchModeInner = \"inner\"\n// Removes the existing element.\nexport const ElementPatchModeRemove = \"remove\"\n// Replaces the existing element with the new element.\nexport const ElementPatchModeReplace = \"replace\"\n// Prepends the element inside to the existing element.\nexport const ElementPatchModePrepend = \"prepend\"\n// Appends the element inside the existing element.\nexport const ElementPatchModeAppend = \"append\"\n// Inserts the element before the existing element.\nexport const ElementPatchModeBefore = \"before\"\n// Inserts the element after the existing element.\nexport const ElementPatchModeAfter = \"after\"\n\n// Default value for ElementPatchMode\nexport const DefaultElementPatchMode = ElementPatchModeOuter;\n\n// The type protocol on top of SSE which allows for core pushed based communication between the server and the client.\n// An event for patching HTML elements into the DOM.\nexport const EventTypePatchElements = \"datastar-patch-elements\"\n// An event for patching signals.\nexport const EventTypePatchSignals = \"datastar-patch-signals\"\n// #endregion\n\n// #endregion","import type { HTMLOrSVG } from '../engine/types'\n\nexport function isHTMLOrSVG(el: Node): el is HTMLOrSVG {\n  return el instanceof HTMLElement || el instanceof SVGElement\n}\n","export const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport function isEmpty(obj: Record<string, any>): boolean {\n  for (const prop in obj) {\n    if (Object.hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function updateLeaves(\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (\n  target: Record<string, any>,\n  paths: Record<string, any>,\n): Record<string, any> => {\n  for (const path in paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), target)\n    obj[lastKey] = paths[path]\n  }\n  return target\n}\n","import type { Modifiers } from '../engine/types'\n\nexport const isBoolString = (str: string) => str.trim() === 'true'\n\nexport const kebab = (str: string) =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string) =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string) => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string) =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = { kebab, snake, pascal }\n\nexport function modifyCasing(str: string, mods: Modifiers) {\n  for (const c of mods.get('case') || []) {\n    const fn = caseFns[c]\n    if (fn) str = fn(str)\n  }\n  return str\n}\n","import { snake } from '../utils/text'\nimport { DATASTAR } from './consts'\nimport type { InitContext, RuntimeContext } from './types'\n\nconst url = 'https://data-star.dev/errors'\n\ninterface Metadata {\n  error?: string\n  [key: string]: any\n}\n\nfunction dserr(type: string, reason: string, metadata: Metadata = {}) {\n  const e = new Error()\n  e.name = `${DATASTAR} ${type} error`\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${type}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nexport function internalErr(from: string, reason: string, args = {}) {\n  return dserr('internal', reason, Object.assign({ from }, args))\n}\n\nexport function initErr(ctx: InitContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n  }\n  return dserr('init', reason, Object.assign(errCtx, metadata))\n}\n\nexport function runtimeErr(ctx: RuntimeContext, reason: string, metadata = {}) {\n  const errCtx = {\n    plugin: {\n      name: ctx.plugin.name,\n      type: ctx.plugin.type,\n    },\n    element: {\n      id: ctx.el.id,\n      tag: ctx.el.tagName,\n    },\n    expression: {\n      rawKey: ctx.rawKey,\n      key: ctx.key,\n      value: ctx.value,\n      // validSignals:\n      fnContent: ctx.fnContent,\n    },\n  }\n  return dserr('runtime', reason, Object.assign(errCtx, metadata))\n}\n","import { DATASTAR } from './consts'\nexport type PluginType = 'attribute' | 'watcher' | 'action'\nexport type Requirement = 'allowed' | 'must' | 'denied' | 'exclusive'\n\n// export type ReactiveNode = Signal | Computed | Effect\n// export type Subscriber = Computed | Effect\nexport type OnRemovalFn = () => void\n\nexport type DatastarPlugin = AttributePlugin | WatcherPlugin | ActionPlugin\n\nexport const DATASTAR_SIGNAL_PATCH_EVENT = `${DATASTAR}-signal-patch`\nexport type JSONPatch = Record<string, any>\n\nexport interface CustomEventMap {\n  [DATASTAR_SIGNAL_PATCH_EVENT]: CustomEvent<JSONPatch>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\ndeclare global {\n  interface Document {\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n  }\n}\n\n// A plugin accessible via a `data-${name}` attribute on an element\nexport type AttributePlugin = {\n  type: 'attribute'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void // Called once on registration of the plugin\n  onLoad: (ctx: RuntimeContext) => OnRemovalFn | void // Return a function to be called on removal\n  keyReq?: Requirement // The rules for the key requirements\n  valReq?: Requirement // The rules for the value requirements\n  returnsValue?: boolean // If the expression returns a value\n  shouldEvaluate?: boolean // If the value should be evaluated\n  argNames?: string[] // argument names for the reactive expression\n}\n\n// A plugin that runs on the global scope of the Datastar instance\nexport type WatcherPlugin = {\n  type: 'watcher'\n  name: string // The name of the plugin\n  onGlobalInit?: (ctx: InitContext) => void\n}\n\nexport type ActionPlugins = Record<string, ActionPlugin>\nexport type ActionMethod = (ctx: RuntimeContext, ...args: any[]) => any\n\nexport type ActionPlugin = {\n  type: 'action'\n  name: string // The name of the plugin\n  fn: ActionMethod\n}\n\nexport type GlobalInitializer = (ctx: InitContext) => void\n\nexport type InitContext = {\n  plugin: DatastarPlugin // The plugin instance\n  actions: Readonly<ActionPlugins> // All registered actions\n  root: Record<string, any> // global signals and computed signals\n  filtered: (opts?: SignalFilterOptions, obj?: JSONPatch) => Record<string, any>\n  signal<T>(initialValue?: T | undefined): Signal<T> // creates a signal\n  computed<T>(getter: (previousValue?: T) => T): Computed<T> // creates a computed signal\n  effect(fn: (...args: any[]) => void): OnRemovalFn // creates an effect\n  mergePatch: (patch: any, args?: { ifMissing?: boolean }) => any\n  peek: <T>(fn: () => T) => T // returns the current state of the signal without subscribing\n  getPath: <T = any>(path: string) => T | undefined // get a value from the root\n  startBatch: () => void // starts a signal batch\n  endBatch: () => void // ends a signal batch\n  initErr: (reason: string, metadata?: object) => Error\n}\n\nexport type HTMLOrSVG = Element & (HTMLElement | SVGElement)\nexport type Modifiers = Map<string, Set<string>> // mod name -> tags\nexport type ReactiveExpressionFn = <T>(...argsThenDeps: any[]) => T // a reactive expression\n\nexport type RuntimeContext = InitContext & {\n  el: HTMLOrSVG // The element the attribute is on\n  rawKey: Readonly<string> // no parsing data-* key\n  key: Readonly<string> // data-* key without the prefix or tags\n  value: Readonly<string> // value of data-* attribute\n  mods: Modifiers // the modifiers and their tags\n  rx: ReactiveExpressionFn // function to generate a reactive expression\n  fnContent?: string // the content of the function\n  evt?: Event // the event that triggered the plugin\n  runtimeErr: (reason: string, metadata?: object) => Error\n}\n\nexport type RuntimeExpressionFunction = (\n  ctx: RuntimeContext,\n  ...args: any[]\n) => any\n\nexport type EventCallbackHandler = (...args: any[]) => void\n\nexport type SignalFilter = RegExp\nexport type SignalFilterOptions = {\n  include?: RegExp | string\n  exclude?: RegExp | string\n}\n\nexport type Signal<T = any> = {\n  (): T\n  (value: T): boolean\n}\n\nexport type Computed<T = any> = () => T\n\nexport type Effect = () => void\n","import { isHTMLOrSVG } from \"../utils/dom\";\nimport { isEmpty, isPojo, pathToObj } from \"../utils/paths\";\nimport { camel, snake } from \"../utils/text\";\nimport { DATASTAR, DSP, DSS } from \"./consts\";\nimport { initErr, runtimeErr } from \"./errors\";\nimport type {\n    ActionPlugins,\n    AttributePlugin,\n    Computed,\n    DatastarPlugin,\n    Effect,\n    HTMLOrSVG,\n    InitContext,\n    JSONPatch,\n    OnRemovalFn,\n    RuntimeContext,\n    RuntimeExpressionFunction,\n    Signal,\n    SignalFilterOptions,\n} from \"./types\";\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from \"./types\";\n\n/**\n * Custom signals implementation based on Alien Signals\n */\n\ninterface ReactiveNode {\n    deps_?: Link;\n    depsTail_?: Link;\n    subs_?: Link;\n    subsTail_?: Link;\n    flags_: ReactiveFlags;\n}\n\ninterface Link {\n    dep_: ReactiveNode;\n    sub_: ReactiveNode;\n    prevSub_?: Link;\n    nextSub_?: Link;\n    prevDep_?: Link;\n    nextDep_?: Link;\n}\n\ninterface Stack<T> {\n    value_: T;\n    prev_?: Stack<T>;\n}\n\nenum ReactiveFlags {\n    None = 0,\n    Mutable = 1 << 0,\n    Watching = 1 << 1,\n    RecursedCheck = 1 << 2,\n    Recursed = 1 << 3,\n    Dirty = 1 << 4,\n    Pending = 1 << 5,\n}\n\nenum EffectFlags {\n    Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n    fn_(): void;\n}\n\ninterface AlienComputed<T = any> extends ReactiveNode {\n    value_?: T;\n    getter(previousValue?: T): T;\n}\n\ninterface AlienSignal<T = any> extends ReactiveNode {\n    previousValue: T;\n    value_: T;\n}\n\nlet currentPatch: Record<string, any> = {};\nconst queuedEffects: (AlienEffect | undefined)[] = [];\nlet batchDepth = 0;\nlet notifyIndex = 0;\nlet queuedEffectsLength = 0;\nlet activeSub: ReactiveNode | undefined;\n\nconst startBatch = (): void => {\n    batchDepth++;\n};\n\nconst endBatch = (): void => {\n    if (!--batchDepth) {\n        flush();\n        dispatch();\n    }\n};\n\nconst signal = <T>(initialValue?: T): Signal<T> => {\n    return signalOper.bind(0, {\n        previousValue: initialValue,\n        value_: initialValue,\n        flags_: 1 satisfies ReactiveFlags.Mutable,\n    }) as Signal<T>;\n};\n\nconst computedSymbol = Symbol(\"computed\");\nconst computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n    const c = computedOper.bind(0, {\n        flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n        getter,\n    }) as Computed<T>;\n    // @ts-ignore\n    c[computedSymbol] = 1;\n    return c;\n};\n\nconst effect = (fn: () => void): Effect => {\n    const e: AlienEffect = {\n        fn_: fn,\n        flags_: 2 satisfies ReactiveFlags.Watching,\n    };\n    if (activeSub) {\n        link(e, activeSub);\n    }\n    const prev = setCurrentSub(e);\n    startBatch();\n    try {\n        e.fn_();\n    } finally {\n        endBatch();\n        setCurrentSub(prev);\n    }\n    return effectOper.bind(0, e);\n};\n\nconst peek = <T>(fn: () => T): T => {\n    const prev = setCurrentSub(undefined);\n    try {\n        return fn();\n    } finally {\n        setCurrentSub(prev);\n    }\n};\n\nconst flush = () => {\n    while (notifyIndex < queuedEffectsLength) {\n        const effect = queuedEffects[notifyIndex]!;\n        queuedEffects[notifyIndex++] = undefined;\n        run(effect, (effect.flags_ &= ~EffectFlags.Queued));\n    }\n    notifyIndex = 0;\n    queuedEffectsLength = 0;\n};\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n    if (\"getter\" in signal) {\n        return updateComputed(signal);\n    }\n    return updateSignal(signal, signal.value_);\n};\n\nconst setCurrentSub = (sub?: ReactiveNode): ReactiveNode | undefined => {\n    const prevSub = activeSub;\n    activeSub = sub;\n    return prevSub;\n};\n\nconst updateComputed = (c: AlienComputed): boolean => {\n    const prevSub = setCurrentSub(c);\n    startTracking(c);\n    try {\n        const oldValue = c.value_;\n        return oldValue !== (c.value_ = c.getter(oldValue));\n    } finally {\n        setCurrentSub(prevSub);\n        endTracking(c);\n    }\n};\n\nconst updateSignal = (s: AlienSignal, value: any): boolean => {\n    s.flags_ = 1 satisfies ReactiveFlags.Mutable;\n    return s.previousValue !== (s.previousValue = value);\n};\n\nconst notify = (e: AlienEffect): void => {\n    const flags = e.flags_;\n    if (!(flags & EffectFlags.Queued)) {\n        e.flags_ = flags | EffectFlags.Queued;\n        const subs = e.subs_;\n        if (subs) {\n            notify(subs.sub_ as AlienEffect);\n        } else {\n            queuedEffects[queuedEffectsLength++] = e;\n        }\n    }\n};\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n    if (\n        flags & (16 satisfies ReactiveFlags.Dirty) ||\n        (flags & (32 satisfies ReactiveFlags.Pending) &&\n            checkDirty(e.deps_!, e))\n    ) {\n        const prev = setCurrentSub(e);\n        startTracking(e);\n        startBatch();\n        try {\n            e.fn_();\n        } finally {\n            endBatch();\n            setCurrentSub(prev);\n            endTracking(e);\n        }\n        return;\n    }\n    if (flags & (32 satisfies ReactiveFlags.Pending)) {\n        e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending);\n    }\n    let link = e.deps_;\n    while (link) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n        if (depFlags & EffectFlags.Queued) {\n            run(\n                dep as AlienEffect,\n                (dep.flags_ = depFlags & ~EffectFlags.Queued)\n            );\n        }\n        link = link.nextDep_;\n    }\n};\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n    const flags = c.flags_;\n    if (\n        flags & (16 satisfies ReactiveFlags.Dirty) ||\n        (flags & (32 satisfies ReactiveFlags.Pending) &&\n            checkDirty(c.deps_!, c))\n    ) {\n        if (updateComputed(c)) {\n            const subs = c.subs_;\n            if (subs) {\n                shallowPropagate(subs);\n            }\n        }\n    } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n        c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending);\n    }\n    if (activeSub) {\n        link(c, activeSub);\n    }\n    return c.value_!;\n};\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n    if (value.length) {\n        const newValue = value[0];\n        if (s.value_ !== (s.value_ = newValue)) {\n            s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty;\n            const subs = s.subs_;\n            if (subs) {\n                propagate(subs);\n                if (!batchDepth) {\n                    flush();\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const currentValue = s.value_;\n    if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n        if (updateSignal(s, currentValue)) {\n            const subs_ = s.subs_;\n            if (subs_) {\n                shallowPropagate(subs_);\n            }\n        }\n    }\n    if (activeSub) {\n        link(s, activeSub);\n    }\n    return currentValue;\n};\n\nconst effectOper = (e: AlienEffect): void => {\n    let dep = e.deps_;\n    while (dep) {\n        dep = unlink(dep, e);\n    }\n    const sub = e.subs_;\n    if (sub) {\n        unlink(sub);\n    }\n    e.flags_ = 0 satisfies ReactiveFlags.None;\n};\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n    const prevDep = sub.depsTail_;\n    if (prevDep && prevDep.dep_ === dep) {\n        return;\n    }\n    let nextDep: Link | undefined;\n    const recursedCheck =\n        sub.flags_ & (4 satisfies ReactiveFlags.RecursedCheck);\n    if (recursedCheck) {\n        nextDep = prevDep ? prevDep.nextDep_ : sub.deps_;\n        if (nextDep && nextDep.dep_ === dep) {\n            sub.depsTail_ = nextDep;\n            return;\n        }\n    }\n    const prevSub = dep.subsTail_;\n    if (\n        prevSub &&\n        prevSub.sub_ === sub &&\n        (!recursedCheck || isValidLink(prevSub, sub))\n    ) {\n        return;\n    }\n    const newLink =\n        (sub.depsTail_ =\n        dep.subsTail_ =\n            {\n                dep_: dep,\n                sub_: sub,\n                prevDep_: prevDep,\n                nextDep_: nextDep,\n                prevSub_: prevSub,\n            });\n    if (nextDep) {\n        nextDep.prevDep_ = newLink;\n    }\n    if (prevDep) {\n        prevDep.nextDep_ = newLink;\n    } else {\n        sub.deps_ = newLink;\n    }\n    if (prevSub) {\n        prevSub.nextSub_ = newLink;\n    } else {\n        dep.subs_ = newLink;\n    }\n};\n\nconst unlink = (link: Link, sub_ = link.sub_): Link | undefined => {\n    const dep_ = link.dep_;\n    const prevDep_ = link.prevDep_;\n    const nextDep_ = link.nextDep_;\n    const nextSub_ = link.nextSub_;\n    const prevSub_ = link.prevSub_;\n    if (nextDep_) {\n        nextDep_.prevDep_ = prevDep_;\n    } else {\n        sub_.depsTail_ = prevDep_;\n    }\n    if (prevDep_) {\n        prevDep_.nextDep_ = nextDep_;\n    } else {\n        sub_.deps_ = nextDep_;\n    }\n    if (nextSub_) {\n        nextSub_.prevSub_ = prevSub_;\n    } else {\n        dep_.subsTail_ = prevSub_;\n    }\n    if (prevSub_) {\n        prevSub_.nextSub_ = nextSub_;\n    } else if (!(dep_.subs_ = nextSub_)) {\n        if (\"getter\" in dep_) {\n            let toRemove = dep_.deps_;\n            if (toRemove) {\n                dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty;\n                do {\n                    toRemove = unlink(toRemove, dep_);\n                } while (toRemove);\n            }\n        } else if (!(\"previousValue\" in dep_)) {\n            effectOper(dep_ as AlienEffect);\n        }\n    }\n    return nextDep_;\n};\n\nconst propagate = (link: Link): void => {\n    let next = link.nextSub_;\n    let stack: Stack<Link | undefined> | undefined;\n\n    top: while (true) {\n        const sub = link.sub_;\n\n        let flags = sub.flags_;\n\n        if (flags & (3 as ReactiveFlags.Mutable | ReactiveFlags.Watching)) {\n            if (\n                !(\n                    flags &\n                    (60 as\n                        | ReactiveFlags.RecursedCheck\n                        | ReactiveFlags.Recursed\n                        | ReactiveFlags.Dirty\n                        | ReactiveFlags.Pending)\n                )\n            ) {\n                sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending);\n            } else if (\n                !(\n                    flags &\n                    (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed)\n                )\n            ) {\n                flags = 0 satisfies ReactiveFlags.None;\n            } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n                sub.flags_ =\n                    (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n                    (32 satisfies ReactiveFlags.Pending);\n            } else if (\n                !(\n                    flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)\n                ) &&\n                isValidLink(link, sub)\n            ) {\n                sub.flags_ =\n                    flags |\n                    (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending);\n                flags &= 1 satisfies ReactiveFlags.Mutable;\n            } else {\n                flags = 0 satisfies ReactiveFlags.None;\n            }\n\n            if (flags & (2 satisfies ReactiveFlags.Watching)) {\n                notify(sub as AlienEffect);\n            }\n\n            if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n                const subSubs = sub.subs_;\n                if (subSubs) {\n                    link = subSubs;\n                    if (subSubs.nextSub_) {\n                        stack = { value_: next, prev_: stack };\n                        next = link.nextSub_;\n                    }\n                    continue;\n                }\n            }\n        }\n\n        if ((link = next!)) {\n            next = link.nextSub_;\n            continue;\n        }\n\n        while (stack) {\n            link = stack.value_!;\n            stack = stack.prev_;\n            if (link) {\n                next = link.nextSub_;\n                continue top;\n            }\n        }\n\n        break;\n    }\n};\n\nconst startTracking = (sub: ReactiveNode): void => {\n    sub.depsTail_ = undefined;\n    sub.flags_ =\n        (sub.flags_ &\n            ~(56 as\n                | ReactiveFlags.Recursed\n                | ReactiveFlags.Dirty\n                | ReactiveFlags.Pending)) |\n        (4 satisfies ReactiveFlags.RecursedCheck);\n};\n\nconst endTracking = (sub: ReactiveNode): void => {\n    const depsTail_ = sub.depsTail_;\n    let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_;\n    while (toRemove) {\n        toRemove = unlink(toRemove, sub);\n    }\n    sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck);\n};\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n    let stack: Stack<Link> | undefined;\n    let checkDepth = 0;\n\n    top: while (true) {\n        const dep = link.dep_;\n        const depFlags = dep.flags_;\n\n        let dirty = false;\n\n        if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n            dirty = true;\n        } else if (\n            (depFlags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n            (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n        ) {\n            if (update(dep as AlienSignal | AlienComputed)) {\n                const subs = dep.subs_!;\n                if (subs.nextSub_) {\n                    shallowPropagate(subs);\n                }\n                dirty = true;\n            }\n        } else if (\n            (depFlags &\n                (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n            (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n        ) {\n            if (link.nextSub_ || link.prevSub_) {\n                stack = { value_: link, prev_: stack };\n            }\n            link = dep.deps_!;\n            sub = dep;\n            ++checkDepth;\n            continue;\n        }\n\n        if (!dirty && link.nextDep_) {\n            link = link.nextDep_;\n            continue;\n        }\n\n        while (checkDepth) {\n            --checkDepth;\n            const firstSub = sub.subs_!;\n            const hasMultipleSubs = firstSub.nextSub_;\n            if (hasMultipleSubs) {\n                link = stack!.value_;\n                stack = stack!.prev_;\n            } else {\n                link = firstSub;\n            }\n            if (dirty) {\n                if (update(sub as AlienSignal | AlienComputed)) {\n                    if (hasMultipleSubs) {\n                        shallowPropagate(firstSub);\n                    }\n                    sub = link.sub_;\n                    continue;\n                }\n            } else {\n                sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending);\n            }\n            sub = link.sub_;\n            if (link.nextDep_) {\n                link = link.nextDep_;\n                continue top;\n            }\n            dirty = false;\n        }\n\n        return dirty;\n    }\n};\n\nconst shallowPropagate = (link: Link): void => {\n    do {\n        const sub = link.sub_;\n        const nextSub = link.nextSub_;\n        const subFlags = sub.flags_;\n        if (\n            (subFlags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n            (32 satisfies ReactiveFlags.Pending)\n        ) {\n            sub.flags_ = subFlags | (16 satisfies ReactiveFlags.Dirty);\n            if (subFlags & (2 satisfies ReactiveFlags.Watching)) {\n                notify(sub as AlienEffect);\n            }\n        }\n        link = nextSub!;\n    } while (link);\n};\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n    const depsTail = sub.depsTail_;\n    if (depsTail) {\n        let link = sub.deps_!;\n        do {\n            if (link === checkLink) {\n                return true;\n            }\n            if (link === depsTail) {\n                break;\n            }\n            link = link.nextDep_!;\n        } while (link);\n    }\n    return false;\n};\n\nconst getPath = <T = any>(path: string): T | undefined => {\n    let result = root;\n    const split = path.split(\".\");\n    for (const path of split) {\n        if (result == null || !Object.hasOwn(result, path)) {\n            return;\n        }\n        result = result[path];\n    }\n    return result as T;\n};\n\nexport const DELETE = Symbol(\"delete\");\nconst deep = (value: any, prefix = \"\"): any => {\n    const isArr = Array.isArray(value);\n    if (isArr || isPojo(value)) {\n        const deepObj = (isArr ? [] : {}) as Record<string, Signal>;\n        for (const key in value) {\n            deepObj[key] = signal(\n                deep((value as Record<string, Signal>)[key], `${prefix + key}.`)\n            );\n        }\n        const keys = signal(0);\n        return new Proxy(deepObj, {\n            get: (_, prop: string) => {\n                if (!(prop === \"toJSON\" && !Object.hasOwn(deepObj, prop))) {\n                    if (isArr && prop in Array.prototype) {\n                        keys();\n                        return deepObj[prop];\n                    } else {\n                        if (typeof prop === \"symbol\") {\n                            return deepObj[prop];\n                        }\n                        if (\n                            !Object.hasOwn(deepObj, prop) ||\n                            deepObj[prop]() == null\n                        ) {\n                            deepObj[prop] = signal(\"\");\n                            dispatch({ [prefix + prop]: \"\" });\n                            keys(keys() + 1);\n                        }\n                        return deepObj[prop]();\n                    }\n                }\n            },\n            set: (_, prop: string, newValue) => {\n                if (newValue === DELETE) {\n                    if (Object.hasOwn(deepObj, prop)) {\n                        delete deepObj[prop];\n                        dispatch({ [prefix + prop]: DELETE });\n                        keys(keys() + 1);\n                    }\n                } else {\n                    if (isArr && prop === \"length\") {\n                        deepObj[prop] = newValue;\n                        dispatch({ [prefix.slice(0, -1)]: deepObj });\n                        keys(keys() + 1);\n                    } else {\n                        if (Object.hasOwn(deepObj, prop)) {\n                            if (newValue == null) {\n                                if (deepObj[prop](null)) {\n                                    dispatch({ [prefix + prop]: null });\n                                }\n                            } else {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch({ [prefix + prop]: \"\" });\n                                } else {\n                                    if (\n                                        deepObj[prop](\n                                            deep(newValue, `${prefix + prop}.`)\n                                        )\n                                    ) {\n                                        dispatch({ [prefix + prop]: newValue });\n                                    }\n                                }\n                            }\n                        } else {\n                            if (newValue != null) {\n                                if (Object.hasOwn(newValue, computedSymbol)) {\n                                    deepObj[prop] = newValue;\n                                    dispatch({ [prefix + prop]: \"\" });\n                                } else {\n                                    deepObj[prop] = signal(\n                                        deep(newValue, `${prefix + prop}.`)\n                                    );\n                                    dispatch({ [prefix + prop]: newValue });\n                                }\n                                keys(keys() + 1);\n                            }\n                        }\n                    }\n                }\n\n                return true;\n            },\n            deleteProperty: (_, prop: string) => {\n                if (Object.hasOwn(deepObj, prop)) {\n                    if (deepObj[prop](null)) {\n                        dispatch({ [prefix + prop]: null });\n                    }\n                }\n\n                return true;\n            },\n            ownKeys: () => {\n                keys();\n                return Reflect.ownKeys(deepObj);\n            },\n            has(_, prop) {\n                keys();\n                return prop in deepObj;\n            },\n        });\n    }\n    return value;\n};\n\nconst dispatch = (obj?: Record<string, any>) => {\n    if (obj) {\n        pathToObj(currentPatch, obj);\n    }\n    if (!batchDepth && !isEmpty(currentPatch)) {\n        const oldPatch = currentPatch;\n        currentPatch = {};\n        document.dispatchEvent(\n            new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n                detail: oldPatch,\n            })\n        );\n    }\n};\n\nconst mergePatch = (\n    patch: Record<string, any>,\n    { ifMissing }: { ifMissing?: boolean } = {}\n): void => {\n    startBatch();\n    for (const key in patch) {\n        if (patch[key] == null) {\n            if (!ifMissing) {\n                delete root[key];\n            }\n        } else {\n            mergeInner(patch[key], key, root, \"\", ifMissing);\n        }\n    }\n    endBatch();\n};\n\nconst mergeInner = (\n    patch: any,\n    target: string,\n    targetParent: Record<string, any>,\n    prefix: string,\n    ifMissing: boolean | undefined\n): void => {\n    if (isPojo(patch)) {\n        if (\n            !(\n                Object.hasOwn(targetParent, target) &&\n                (isPojo(targetParent[target]) ||\n                    Array.isArray(targetParent[target]))\n            )\n        ) {\n            targetParent[target] = {};\n        }\n\n        for (const key in patch) {\n            if (patch[key] == null) {\n                if (!ifMissing) {\n                    delete targetParent[target][key];\n                }\n            } else {\n                mergeInner(\n                    patch[key],\n                    key,\n                    targetParent[target],\n                    `${prefix + target}.`,\n                    ifMissing\n                );\n            }\n        }\n    } else if (!(ifMissing && Object.hasOwn(targetParent, target))) {\n        targetParent[target] = patch;\n    }\n};\n\nfunction filtered(\n    { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n    obj: JSONPatch = root\n) {\n    // We need to find all valid signal paths in the object\n    const pathObj: Record<string, any> = {};\n    const stack: Array<[any, string]> = [[obj, \"\"]];\n\n    while (stack.length) {\n        const [node, prefix] = stack.pop()!;\n\n        for (const key in node) {\n            if (isPojo(node[key])) {\n                stack.push([node[key], `${prefix + key}.`]);\n            } else if (\n                toRegExp(include).test(prefix + key) &&\n                !toRegExp(exclude).test(prefix + key)\n            ) {\n                pathObj[prefix + key] = getPath(prefix + key);\n            }\n        }\n    }\n\n    return pathToObj({}, pathObj);\n}\n\nfunction toRegExp(val: string | RegExp): RegExp {\n    if (typeof val === \"string\") {\n        return RegExp(val.replace(/^\\/|\\/$/g, \"\"));\n    }\n\n    return val;\n}\n\nconst root: Record<string, any> = deep({});\n\n/**\n * Turn data-* attributes into reactive expressions\n * This is the core of the Datastar\n */\n\nconst actions: ActionPlugins = {};\nconst plugins: AttributePlugin[] = [];\nlet pluginRegexs: RegExp[] = [];\n\n// Map of cleanup functions by element, keyed by a dataset key-value hash\nconst removals = new Map<HTMLOrSVG, Map<string, OnRemovalFn>>();\n\nlet mutationObserver: MutationObserver | null = null;\n\nlet alias = \"\";\nexport function setAlias(value: string) {\n    alias = value;\n}\n\nexport function aliasify(name: string) {\n    return alias ? `data-${alias}-${name}` : `data-${name}`;\n}\n\nexport function load(...pluginsToLoad: DatastarPlugin[]) {\n    for (const plugin of pluginsToLoad) {\n        const ctx: InitContext = {\n            plugin,\n            actions,\n            root,\n            filtered,\n            signal,\n            computed,\n            effect,\n            mergePatch,\n            peek,\n            getPath,\n            startBatch,\n            endBatch,\n            initErr: 0 as any,\n        };\n        ctx.initErr = initErr.bind(0, ctx);\n\n        if (plugin.type === \"action\") {\n            actions[plugin.name] = plugin;\n        } else if (plugin.type === \"attribute\") {\n            plugins.push(plugin);\n            plugin.onGlobalInit?.(ctx);\n        } else if (plugin.type === \"watcher\") {\n            plugin.onGlobalInit?.(ctx);\n        } else {\n            throw ctx.initErr(\"InvalidPluginType\");\n        }\n    }\n\n    // Sort attribute plugins by descending length then alphabetically\n    plugins.sort((a, b) => {\n        const lenDiff = b.name.length - a.name.length;\n        if (lenDiff !== 0) return lenDiff;\n        return a.name.localeCompare(b.name);\n    });\n\n    pluginRegexs = plugins.map((plugin) =>\n        RegExp(`^${plugin.name}([A-Z]|_|$)`)\n    );\n}\n\nfunction applyEls(els: Iterable<HTMLOrSVG>): void {\n    const ignore = `[${aliasify(\"ignore\")}]`;\n    for (const el of els) {\n        if (!el.closest(ignore)) {\n            for (const key in el.dataset) {\n                applyAttributePlugin(el, key, el.dataset[key]!);\n            }\n        }\n    }\n}\n\nfunction cleanupEls(els: Iterable<HTMLOrSVG>): void {\n    for (const el of els) {\n        const cleanups = removals.get(el);\n        // If removals has el, delete it and run all cleanup functions\n        if (removals.delete(el)) {\n            for (const cleanup of cleanups!.values()) {\n                cleanup();\n            }\n            cleanups!.clear();\n        }\n    }\n}\n\n// Apply all plugins to the entire DOM or a provided element\nexport function apply(root: HTMLOrSVG = document.body) {\n    // Delay applying plugins to give custom plugins a chance to load\n    queueMicrotask(() => {\n        applyEls([root]);\n        applyEls(root.querySelectorAll<HTMLOrSVG>(\"*\"));\n\n        // Monitor the entire document body or a provided element for changes\n        // https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n        if (!mutationObserver) {\n            mutationObserver = new MutationObserver(observe);\n            mutationObserver.observe(root, {\n                subtree: true,\n                childList: true,\n                attributes: true,\n            });\n        }\n    });\n}\n\nfunction applyAttributePlugin(\n    el: HTMLOrSVG,\n    attrKey: string,\n    value: string\n): void {\n    if (attrKey.startsWith(alias)) {\n        const rawKey = camel(alias ? attrKey.slice(alias.length) : attrKey);\n        const plugin = plugins.find((_, i) => pluginRegexs[i].test(rawKey));\n        if (plugin) {\n            // Extract the key and modifiers\n            let [key, ...rawModifiers] = rawKey\n                .slice(plugin.name.length)\n                .split(/__+/);\n\n            const hasKey = !!key;\n            if (hasKey) {\n                key = camel(key);\n            }\n            const hasValue = !!value;\n\n            // Create the runtime context\n            const ctx: RuntimeContext = {\n                plugin,\n                actions,\n                root,\n                filtered,\n                signal,\n                computed,\n                effect,\n                mergePatch,\n                peek,\n                getPath,\n                startBatch,\n                endBatch,\n                initErr: 0 as any,\n                el,\n                rawKey,\n                key,\n                value,\n                mods: new Map(),\n                runtimeErr: 0 as any,\n                rx: 0 as any,\n            };\n            ctx.initErr = initErr.bind(0, ctx);\n            ctx.runtimeErr = runtimeErr.bind(0, ctx);\n            if (\n                plugin.shouldEvaluate === undefined ||\n                plugin.shouldEvaluate === true\n            ) {\n                ctx.rx = generateReactiveExpression(ctx);\n            }\n\n            // Check the requirements\n            const keyReq = plugin.keyReq || \"allowed\";\n            if (hasKey) {\n                if (keyReq === \"denied\") {\n                    throw ctx.runtimeErr(`${plugin.name}KeyNotAllowed`);\n                }\n            } else if (keyReq === \"must\") {\n                throw ctx.runtimeErr(`${plugin.name}KeyRequired`);\n            }\n\n            const valReq = plugin.valReq || \"allowed\";\n            if (hasValue) {\n                if (valReq === \"denied\") {\n                    throw ctx.runtimeErr(`${plugin.name}ValueNotAllowed`);\n                }\n            } else if (valReq === \"must\") {\n                throw ctx.runtimeErr(`${plugin.name}ValueRequired`);\n            }\n\n            // Check for exclusive requirements\n            if (keyReq === \"exclusive\" || valReq === \"exclusive\") {\n                if (hasKey && hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyAndValueProvided`);\n                }\n                if (!hasKey && !hasValue) {\n                    throw ctx.runtimeErr(`${plugin.name}KeyOrValueRequired`);\n                }\n            }\n\n            for (const rawMod of rawModifiers) {\n                const [label, ...mod] = rawMod.split(\".\");\n                ctx.mods.set(\n                    camel(label),\n                    new Set(mod.map((t) => t.toLowerCase()))\n                );\n            }\n\n            const cleanup = plugin.onLoad(ctx);\n            if (cleanup) {\n                let cleanups = removals.get(el);\n                if (cleanups) {\n                    cleanups.get(rawKey)?.();\n                } else {\n                    cleanups = new Map();\n                    removals.set(el, cleanups);\n                }\n                cleanups.set(rawKey, cleanup);\n            }\n        }\n    }\n}\n\n// Set up a mutation observer to run plugin removal and apply functions\nfunction observe(mutations: MutationRecord[]) {\n    const ignore = `[${aliasify(\"ignore\")}]`;\n\n    for (const {\n        target,\n        type,\n        attributeName,\n        addedNodes,\n        removedNodes,\n    } of mutations) {\n        if (type === \"childList\") {\n            for (const node of removedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    cleanupEls([node]);\n                    cleanupEls(node.querySelectorAll<HTMLOrSVG>(\"*\"));\n                }\n            }\n\n            for (const node of addedNodes) {\n                if (isHTMLOrSVG(node)) {\n                    applyEls([node]);\n                    applyEls(node.querySelectorAll<HTMLOrSVG>(\"*\"));\n                }\n            }\n        } else if (type === \"attributes\") {\n            // If el has a parent with data-ignore, skip it\n            if (isHTMLOrSVG(target) && !target.closest(ignore)) {\n                const key = camel(attributeName!.slice(5));\n                const value = target.getAttribute(attributeName!);\n                if (value === null) {\n                    const cleanups = removals.get(target);\n                    if (cleanups) {\n                        cleanups.get(key)?.();\n                        cleanups.delete(key);\n                    }\n                } else {\n                    applyAttributePlugin(target, key, value);\n                }\n            }\n        }\n    }\n}\n\nfunction generateReactiveExpression(\n    ctx: RuntimeContext\n): RuntimeExpressionFunction {\n    let expr = \"\";\n\n    const attrPlugin = (ctx.plugin as AttributePlugin) || undefined;\n\n    // plugin is guaranteed to be an attribute plugin\n    if (attrPlugin?.returnsValue) {\n        // This regex allows Datastar expressions to support nested\n        // regex and strings that contain ; without breaking.\n        //\n        // Each of these regex defines a block type we want to match\n        // (importantly we ignore the content within these blocks):\n        //\n        // regex            \\/(\\\\\\/|[^\\/])*\\/\n        // double quotes      \"(\\\\\"|[^\\\"])*\"\n        // single quotes      '(\\\\'|[^'])*'\n        // ticks              `(\\\\`|[^`])*`\n        // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n        //\n        // The iife support is (intentionally) limited. It only supports\n        // function and arrow syntax with no arguments, and no nested IIFEs.\n        //\n        // We also want to match the non delimiter part of statements\n        // note we only support ; statement delimiters:\n        //\n        // [^;]\n        //\n        const statementRe =\n            /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm;\n        const statements = ctx.value.trim().match(statementRe);\n        if (statements) {\n            const lastIdx = statements.length - 1;\n            const last = statements[lastIdx].trim();\n            if (!last.startsWith(\"return\")) {\n                statements[lastIdx] = `return (${last});`;\n            }\n            expr = statements.join(\";\\n\");\n        }\n    } else {\n        expr = ctx.value.trim();\n    }\n\n    // Replace signal references with bracket notation\n    // Examples:\n    //   $count          → $['count']\n    //   $count--        → $['count']--\n    //   $count++        → $['count']++\n    //   $count += 5     → $['count'] += 5\n    //   $foo = 5        → $['foo'] = 5\n    //   $foo.bar        → $['foo']['bar']\n    //   $foo-bar        → $['foo-bar']\n    //   $foo.bar-baz    → $['foo']['bar-baz']\n    //   $foo-$bar       → $['foo']-$['bar']\n    //   $arr[$index]    → $['arr'][$['index']]\n    //   $['foo']        → $['foo']\n    //   $foo[obj.bar]   → $['foo'][obj.bar]\n    //   $foo['bar.baz'] → $['foo']['bar.baz']\n    //   $1              → $['1']\n    //   $123            → $['123']\n    //   $foo.0.name     → $['foo']['0']['name']\n    //   $foo.0.1.2.bar.0 → $['foo']['0']['1']['2']['bar']['0']\n\n    // Transform all signal patterns\n    expr = expr\n        // $['x'] → $x (normalize existing bracket notation)\n        .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, \"$$$1\")\n        // $x → $['x'] (including dots and hyphens)\n        .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) => {\n            const parts = signalName.split(\".\");\n            return parts.reduce(\n                (acc: string, part: string) => `${acc}['${part}']`,\n                \"$\"\n            );\n        })\n        // $ inside brackets: [$x] → [$['x']]\n        .replace(\n            /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n            (_, varName) => `[$['${varName.slice(1)}']]`\n        );\n\n    // Ignore any escaped values\n    const escaped = new Map<string, string>();\n    const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, \"gm\");\n    let counter = 0;\n    for (const match of expr.matchAll(escapeRe)) {\n        const k = match[1];\n        const v = `dsEscaped${counter++}`;\n        escaped.set(v, k);\n        expr = expr.replace(DSP + k + DSS, v);\n    }\n\n    const nameGen = (prefix: string, name: string) => {\n        return `${prefix}${snake(name).replaceAll(/\\./g, \"_\")}`;\n    };\n\n    // Replace any action calls\n    const actionsCalled = new Set<string>();\n    const actionsRe = RegExp(`@(${Object.keys(actions).join(\"|\")})\\\\(`, \"gm\");\n    const actionMatches = [...expr.matchAll(actionsRe)];\n    const actionNames = new Set<string>();\n    const actionFns = new Set<(...args: any[]) => any>();\n    if (actionMatches.length) {\n        const actionPrefix = `${DATASTAR}Act_`;\n        for (const match of actionMatches) {\n            const actionName = match[1];\n            const action = actions[actionName];\n            if (!action) {\n                continue;\n            }\n            actionsCalled.add(actionName);\n\n            const name = nameGen(actionPrefix, actionName);\n\n            // Add ctx to action calls\n            expr = expr.replace(`@${actionName}(`, `${name}(`);\n            actionNames.add(name);\n            actionFns.add((...args: any[]) => action.fn(ctx, ...args));\n        }\n    }\n\n    // Replace any escaped values\n    for (const [k, v] of escaped) {\n        expr = expr.replace(k, v);\n    }\n\n    ctx.fnContent = expr;\n\n    try {\n        const fn = Function(\n            \"el\",\n            \"$\",\n            ...(attrPlugin?.argNames || []),\n            ...actionNames,\n            expr\n        );\n        return (...args: any[]) => {\n            try {\n                return fn(ctx.el, root, ...args, ...actionFns);\n            } catch (e: any) {\n                throw ctx.runtimeErr(\"ExecuteExpression\", {\n                    error: e.message,\n                });\n            }\n        };\n    } catch (error: any) {\n        throw ctx.runtimeErr(\"GenerateExpression\", {\n            error: error.message,\n        });\n    }\n}\n","// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport type { ActionPlugin } from '../../engine/types'\n\nexport const Peek: ActionPlugin = {\n  type: 'action',\n  name: 'peek',\n  fn: ({ peek }, fn: () => any) => {\n    return peek(fn)\n  },\n}\n","// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const SetAll: ActionPlugin = {\n  type: 'action',\n  name: 'setAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    value: any,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, () => value)\n      mergePatch(masked)\n    })\n  },\n}\n","// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport type {\n  ActionPlugin,\n  RuntimeContext,\n  SignalFilterOptions,\n} from '../../engine/types'\nimport { updateLeaves } from '../../utils/paths'\n\nexport const ToggleAll: ActionPlugin = {\n  type: 'action',\n  name: 'toggleAll',\n  fn: (\n    { filtered, mergePatch, peek }: RuntimeContext,\n    filter: SignalFilterOptions,\n  ) => {\n    peek(() => {\n      const masked = filtered(filter)\n      updateLeaves(masked, (oldValue: any) => !oldValue)\n      mergePatch(masked)\n    })\n  },\n}\n","// Icon: material-symbols:send\n// Slug: Dispatches custom browser events for component communication.\n// Description: Dispatches CustomEvents globally or to specific elements, enabling event-driven reactive patterns like Livewire.\n\nimport type { ActionPlugin } from '../../../datastar/engine/types';\n\n/**\n * Dispatch Action - Event Communication System\n *\n * Mirrors Livewire's dispatch system, enabling both frontend and backend\n * to trigger custom events for component communication.\n *\n * Usage:\n * @dispatch('event-name')                                  // Global dispatch\n * @dispatch('event-name', {data: 'value'})                // With data\n * @dispatch('event-name', {id: 123}, {selector: '#target'}) // Targeted\n *\n * Options:\n * - selector: CSS selector for targeted dispatch (multiple elements supported)\n * - window: Force window dispatch (default: true if no selector)\n * - bubbles: Event bubbles (default: true)\n * - cancelable: Event can be canceled (default: true)\n * - composed: Event composes through shadow DOM (default: true)\n */\nexport const Dispatch: ActionPlugin = {\n    type: 'action',\n    name: 'dispatch',\n    fn: (\n        { el },\n        eventName: string,\n        data?: any,\n        options?: {\n            selector?: string;\n            window?: boolean;\n            bubbles?: boolean;\n            cancelable?: boolean;\n            composed?: boolean;\n        }\n    ) => {\n        // Validate event name\n        if (!eventName || typeof eventName !== 'string') {\n            console.error(\n                '[Hyper Dispatch] Invalid event name. Must be a non-empty string.',\n                { eventName }\n            );\n            return;\n        }\n\n        // Default options\n        const opts = {\n            selector: options?.selector,\n            window: options?.window ?? (!options?.selector), // Default to window if no selector\n            bubbles: options?.bubbles ?? true,\n            cancelable: options?.cancelable ?? true,\n            composed: options?.composed ?? true,\n        };\n\n        // Create CustomEvent\n        const event = new CustomEvent(eventName, {\n            detail: data || {},\n            bubbles: opts.bubbles,\n            cancelable: opts.cancelable,\n            composed: opts.composed,\n        });\n\n        // Targeted dispatch\n        if (opts.selector) {\n            const targets = document.querySelectorAll(opts.selector);\n\n            if (targets.length === 0) {\n                console.warn(\n                    `[Hyper Dispatch] No elements found for selector: ${opts.selector}`,\n                    { eventName, selector: opts.selector }\n                );\n                return;\n            }\n\n            targets.forEach((target) => {\n                target.dispatchEvent(new CustomEvent(eventName, {\n                    detail: data || {},\n                    bubbles: opts.bubbles,\n                    cancelable: opts.cancelable,\n                    composed: opts.composed,\n                }));\n            });\n\n            return;\n        }\n\n        // Global dispatch (window)\n        if (opts.window) {\n            window.dispatchEvent(event);\n            return;\n        }\n\n        // Element dispatch (fallback to current element)\n        el.dispatchEvent(event);\n    },\n};\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/actions/fileUrl.ts\n\n// Icon: material-symbols:attachment\n// Slug: Converts file sources to valid HTML src/href URLs with smart fallbacks.\n// Description: Handles base64 arrays from file binding and provides fallbacks. File paths are auto-converted by Laravel backend.\n\nimport type {\n    ActionPlugin,\n    RuntimeContext,\n} from \"../../../datastar/engine/types\";\n\n/**\n * FileUrl Action - Simplified and Reliable\n *\n * Now much simpler since Laravel handles path-to-URL conversion.\n * Frontend only needs to handle:\n * - Base64 arrays from Datastar file inputs\n * - URLs (already converted by Laravel)\n * - Fallbacks for missing/empty data\n *\n * Usage Examples:\n * @fileUrl($profilePicture)                           // Auto-detect with fallback\n * @fileUrl($document, {fallback: '/default.pdf'})     // Custom fallback\n * @fileUrl('/storage/file.jpg')                       // URL passthrough\n * @fileUrl($avatar, {defaultMime: 'image/png'})       // Custom MIME for base64\n */\nexport const FileUrl: ActionPlugin = {\n    type: \"action\",\n    name: \"fileUrl\",\n    fn: (\n        _ctx: RuntimeContext,\n        fileSource: any,\n        options?: {\n            fallback?: string;\n            defaultMime?: string;\n            mimeSignal?: string; // Name of companion MIME signal\n        }\n    ): string => {\n        const opts = options || {};\n        const fallback = opts.fallback || \"\";\n        const defaultMime = opts.defaultMime || \"application/octet-stream\";\n        const mimeSignal = opts.mimeSignal;\n\n        // Handle null, undefined, or empty values\n        if (fileSource == null) {\n            return fallback;\n        }\n\n        // Handle arrays (from Datastar file binding)\n        if (Array.isArray(fileSource)) {\n            // Empty array means no file selected\n            if (fileSource.length === 0) {\n                return fallback;\n            }\n\n            const base64Content = fileSource[0];\n            if (!base64Content || typeof base64Content !== \"string\") {\n                return fallback;\n            }\n\n            // Determine MIME type\n            let mimeType = defaultMime;\n\n            // Try to get MIME from companion signal if specified\n            if (mimeSignal && typeof window !== \"undefined\") {\n                const mimeArray = ((window as any).$ || {})[mimeSignal];\n                if (Array.isArray(mimeArray) && mimeArray.length > 0) {\n                    mimeType = mimeArray[0] || defaultMime;\n                }\n            }\n\n            // Construct data URL\n            return `data:${mimeType};base64,${base64Content}`;\n        }\n\n        // Handle strings (URLs, paths, data URLs)\n        if (typeof fileSource === \"string\") {\n            const trimmed = fileSource.trim();\n\n            // Empty string\n            if (!trimmed) {\n                return fallback;\n            }\n\n            // Laravel should have converted file paths to proper URLs\n            // We just return whatever string we got\n            return trimmed;\n        }\n\n        // Handle unexpected types gracefully\n        if (typeof fileSource === \"object\") {\n            console.warn(\n                \"FileUrl action received unexpected object:\",\n                fileSource\n            );\n        }\n\n        return fallback;\n    },\n};\n","// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Attr: AttributePlugin = {\n  type: 'attribute',\n  name: 'attr',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, key, rx }) => {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    key = kebab(key)\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx<string>()\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx<Record<string, any>>()\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesn’t already exist) and sets up two-way data binding between it and an element’s value.\n\nimport { aliasify } from '../../engine/engine'\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nexport const Bind: AttributePlugin = {\n  type: 'attribute',\n  name: 'bind',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    value,\n    effect,\n    mergePatch,\n    runtimeErr,\n    getPath,\n  }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const contents: string[] = []\n            const mimes: string[] = []\n            const names: string[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw runtimeErr('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw runtimeErr('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      contents.push(match.groups.contents)\n                      mimes.push(match.groups.mime)\n                      names.push(f.name)\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePatch(\n                pathToObj(\n                  {},\n                  {\n                    [signalName]: contents,\n                    [`${signalName}Mimes`]: mimes,\n                    [`${signalName}Names`]: names,\n                  },\n                ),\n              )\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const inputs = document.querySelectorAll(\n        `[${aliasify('bind')}-${key}],[${aliasify('bind')}=\"${value}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const pathObj: Record<string, string> = {}\n      let i = 0\n      for (const input of inputs) {\n        pathObj[`${path}.${i}`] = get(input, 'none')\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePatch(pathToObj({}, { [path]: get(el, type) }), {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePatch(pathToObj({}, { [path]: value }))\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n}\n","// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\n\nexport const Class: AttributePlugin = {\n  type: 'attribute',\n  name: 'class',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, mods, rx }) => {\n    if (key) {\n      key = modifyCasing(kebab(key), mods)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx<boolean>() }\n        : rx<Record<string, boolean>>()\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n}\n","// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Computed: AttributePlugin = {\n  type: 'attribute',\n  name: 'computed',\n  keyReq: 'must',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, computed, mergePatch }) => {\n    mergePatch(pathToObj({}, { [modifyCasing(key, mods)]: computed(rx) }))\n  },\n}\n","// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Effect: AttributePlugin = {\n  type: 'attribute',\n  name: 'effect',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ effect, rx }) => effect(rx),\n}\n","import { DATASTAR } from '../../engine/consts'\nimport type { HTMLOrSVG } from '../../engine/types'\n\nexport const DATASTAR_FETCH_EVENT = `${DATASTAR}-fetch`\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nexport interface DatastarFetchEvent {\n  type: string\n  el: HTMLOrSVG\n  argsRaw: Record<string, string>\n}\n\nexport interface CustomEventMap {\n  [DATASTAR_FETCH_EVENT]: CustomEvent<DatastarFetchEvent>\n}\nexport type WatcherFn<K extends keyof CustomEventMap> = (\n  this: Document,\n  ev: CustomEventMap[K],\n) => void\n\ndeclare global {\n  interface Document {\n    //adds definition to Document, but you can do the same with HTMLElement\n    addEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    removeEventListener<K extends keyof CustomEventMap>(\n      type: K,\n      listener: WatcherFn<K>,\n    ): void\n    dispatchEvent<K extends keyof CustomEventMap>(ev: CustomEventMap[K]): void\n  }\n}\n\nexport function datastarSSEEventWatcher(\n  eventType: string,\n  fn: (argsRaw: Record<string, string>) => void,\n) {\n  document.addEventListener(\n    DATASTAR_FETCH_EVENT,\n    (event: CustomEvent<DatastarFetchEvent>) => {\n      if (event.detail.type === eventType) {\n        const { argsRaw } = event.detail\n        fn(argsRaw)\n      }\n    },\n  )\n}\n","// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\nimport {\n  DATASTAR_FETCH_EVENT,\n  type DatastarFetchEvent,\n  FINISHED,\n  STARTED,\n} from '../backend/shared'\n\nexport const Indicator: AttributePlugin = {\n  type: 'attribute',\n  name: 'indicator',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, mergePatch, value }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: false }), { ifMissing: true })\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePatch(pathToObj({}, { [signalName]: true }))\n          break\n        case FINISHED:\n          mergePatch(pathToObj({}, { [signalName]: false }))\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePatch(pathToObj({}, { [signalName]: false }))\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n}\n","// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport type { AttributePlugin, SignalFilterOptions } from '../../engine/types'\nimport { jsStrToObject } from '../../utils/text'\n\nexport const JsonSignals: AttributePlugin = {\n  type: 'attribute',\n  name: 'jsonSignals',\n  keyReq: 'denied',\n  onLoad: ({ el, effect, value, filtered, mods }) => {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","export function tagToMs(args: Set<string>) {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport function tagHas(tags: Set<string>, tag: string, defaultValue = false) {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport function tagFirst(tags?: Set<string>, defaultValue = ''): string {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n","import type { EventCallbackHandler, Modifiers } from '../engine/types'\nimport { tagHas, tagToMs } from './tags'\n\nexport function delay(\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport function debounce(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n    }, wait)\n  }\n}\n\nexport function throttle(\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      waiting = false\n      if (trailing) {\n        callback(...args)\n      }\n    }, wait)\n  }\n}\n\nexport function modifyTiming(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrail', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trail', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n","import type { EventCallbackHandler, Modifiers } from '../engine/types'\n\nexport interface DocumentSupportingViewTransitionAPI {\n  startViewTransition(\n    updateCallback: () => Promise<void> | void,\n  ): IViewTransition\n}\n\nexport interface IViewTransition {\n  finished: Promise<void>\n  ready: Promise<void>\n  updateCallbackDone: Promise<void>\n  skipTransition(): void\n}\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport function modifyViewTransition(\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n","// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '../../engine/types'\nimport { kebab, modifyCasing } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\nimport { DATASTAR_FETCH_EVENT } from '../backend/shared'\n\nexport const On: AttributePlugin = {\n  type: 'attribute',\n  name: 'on',\n  keyReq: 'must',\n  valReq: 'must',\n  argNames: ['evt'],\n  onLoad: (ctx) => {\n    const { el, key, mods, rx, startBatch, endBatch } = ctx\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n        // Return if not a trusted event, not a custom event and no `trusted` modifier exists\n        if (\n          !(evt.isTrusted || evt instanceof CustomEvent || mods.has('trusted'))\n        ) {\n          return\n        }\n        ctx.evt = evt\n      }\n      startBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    // Default to kebab-case and allow modifying\n    let eventName = kebab(key)\n    eventName = modifyCasing(eventName, mods)\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n}\n","// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport type { AttributePlugin, HTMLOrSVG } from '../../engine/types'\nimport { modifyTiming } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nexport const OnIntersect: AttributePlugin = {\n  type: 'attribute',\n  name: 'onIntersect',\n  keyReq: 'denied',\n  onLoad: ({ el, mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyTiming(callback, mods)\n    callback = modifyViewTransition(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n}\n","// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagHas, tagToMs } from '../../utils/tags'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnInterval: AttributePlugin = {\n  type: 'attribute',\n  name: 'onInterval',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ mods, rx, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n}\n","// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { tagToMs } from '../../utils/tags'\nimport { delay } from '../../utils/timing'\nimport { modifyViewTransition } from '../../utils/view-transitions'\n\nexport const OnLoad: AttributePlugin = {\n  type: 'attribute',\n  name: 'onLoad',\n  keyReq: 'denied',\n  valReq: 'must',\n  onLoad: ({ rx, mods, startBatch, endBatch }) => {\n    let callback = () => {\n      startBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n    }\n    // Delay the callback regardless of whether the modifier is set so that other plugins are processed first.\n    callback = delay(callback, wait)\n    callback()\n  },\n}\n","// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport {\n  type AttributePlugin,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n  type JSONPatch,\n  type SignalFilterOptions,\n} from '../../engine/types'\nimport { isEmpty } from '../../utils/paths'\nimport { jsStrToObject } from '../../utils/text'\nimport { modifyTiming } from '../../utils/timing'\n\nexport const OnSignalPatch: AttributePlugin = {\n  type: 'attribute',\n  name: 'onSignalPatch',\n  valReq: 'must',\n  argNames: ['patch'],\n  returnsValue: true,\n  onLoad: ({\n    el,\n    key,\n    mods,\n    plugin,\n    rx,\n    filtered,\n    runtimeErr,\n    startBatch,\n    endBatch,\n  }) => {\n    // Throw an error if the key exists and is not `filter`\n    if (!!key && key !== 'filter') {\n      throw runtimeErr(`${plugin.name}KeyNotAllowed`)\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          startBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n}\n","// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n  type: 'attribute',\n  name: 'ref',\n  keyReq: 'exclusive',\n  valReq: 'exclusive',\n  shouldEvaluate: false,\n  onLoad: ({ el, key, mods, value, mergePatch }) => {\n    const signalName = key ? modifyCasing(key, mods) : value\n\n    mergePatch(pathToObj({}, { [signalName]: el }))\n  },\n}\n","// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nexport const Show: AttributePlugin = {\n  type: 'attribute',\n  name: 'show',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { pathToObj } from '../../utils/paths'\nimport { modifyCasing } from '../../utils/text'\n\nexport const Signals: AttributePlugin = {\n  type: 'attribute',\n  name: 'signals',\n  returnsValue: true,\n  onLoad: ({ key, mods, rx, mergePatch }) => {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePatch(pathToObj({}, { [key]: rx() }), { ifMissing })\n    } else {\n      const patch = rx<Record<string, any>>()\n      const pathObj: Record<string, any> = {}\n      for (const key in patch) {\n        pathObj[key] = patch[key]\n      }\n      mergePatch(pathToObj({}, pathObj), { ifMissing })\n    }\n  },\n}\n","// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport type { AttributePlugin } from '../../engine/types'\nimport { kebab } from '../../utils/text'\n\nexport const Style: AttributePlugin = {\n  type: 'attribute',\n  name: 'style',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ key, el, effect, rx }) => {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    key &&= kebab(key)\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx<Record<string, any>>()\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n}\n","// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport type { AttributePlugin } from '../../engine/types'\n\nexport const Text: AttributePlugin = {\n  type: 'attribute',\n  name: 'text',\n  keyReq: 'denied',\n  valReq: 'must',\n  returnsValue: true,\n  onLoad: ({ el, effect, rx }) => {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n}\n","//==========================================================================================\n// Icon: material-symbols:error-outline\n// Slug: Shows validation error for a field.\n// Description: Displays the first validation error message for a specified field from the errors signal.\n\nimport type { AttributePlugin } from \"../../../datastar/engine/types\";\nimport { pathToObj } from \"../../../datastar/utils/paths\";\n\nexport const Error: AttributePlugin = {\n    type: \"attribute\",\n    name: \"error\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: ({ el, value, effect, computed, getPath, mergePatch }) => {\n        const fieldName = value.trim();\n\n        // Ensure the 'errors' signal exists and is initialized as an empty object\n        // This works like the bind plugin - creates the signal if missing\n        mergePatch(pathToObj({}, { errors: {} }), { ifMissing: true });\n\n        // Create a computed that reactively reads the error for this field\n        const errorComputed = computed(() => {\n            const errors = getPath(\"errors\");\n            if (errors && errors[fieldName]) {\n                const fieldErrors = errors[fieldName];\n                if (Array.isArray(fieldErrors) && fieldErrors.length > 0) {\n                    return fieldErrors[0];\n                } else if (typeof fieldErrors === \"string\") {\n                    return fieldErrors;\n                }\n            }\n            return null;\n        });\n\n        // Effect that updates the DOM when the error changes\n        const cleanup = effect(() => {\n            const errorMessage = errorComputed();\n\n            if (errorMessage) {\n                el.style.removeProperty(\"display\");\n                el.textContent = errorMessage;\n            } else {\n                el.style.setProperty(\"display\", \"none\");\n                el.textContent = \"\";\n            }\n        });\n\n        return cleanup;\n    },\n};\n//=======================================================================================\n","// Icon: material-symbols:repeat\n// Slug: Iterates over an array or object with efficient diffing.\n// Description: Production-ready loop directive with keyed diffing, zero signal pollution, and full Datastar reactivity integration.\n\nimport type {\n    AttributePlugin,\n    HTMLOrSVG,\n} from \"../../../datastar/engine/types\";\nimport { apply } from \"../../../datastar/engine/engine\";\n\n/**\n * ARCHITECTURE: Clean Loop Implementation\n *\n * PRINCIPLES:\n * 1. NO SIGNAL POLLUTION - Only source signals exist (e.g., $users)\n * 2. Direct mapping: iterator \"user\" → source path \"users.0\", \"users.1\", etc.\n * 3. Datastar's Proxy-based reactivity handles all property mutations\n * 4. Keyed diffing reuses DOM elements, retransforming indices on position changes\n * 5. Efficient change detection: no-change, simple-add, simple-remove, complex\n */\n\ninterface IterationState {\n    prevKeys: any[];\n    lookup: Map<any, LoopElement>;\n    template: HTMLTemplateElement;\n    templateContent: DocumentFragment;\n    iteratorNames: ParsedExpression;\n    keyExpression: string | null;\n    effectCleanup: (() => void) | null;\n    sourceSignalPath: string;\n    isNormalized: boolean;\n    iterationId: string;\n}\n\ninterface LoopElement {\n    el: HTMLOrSVG;\n    key: any;\n    index: number;\n}\n\ninterface ParsedExpression {\n    item: string;\n    index?: string;\n    collection?: string;\n    items: string;\n}\n\nconst iterationStates = new WeakMap<HTMLOrSVG, IterationState>();\n\nexport const For: AttributePlugin = {\n    type: \"attribute\",\n    name: \"for\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: (ctx) => {\n        const { el, value, mods, effect, getPath, runtimeErr, startBatch, endBatch, peek } = ctx;\n\n        // Validate template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw runtimeErr(\"ForMustBeOnTemplate\", {\n                message: \"data-for must be used on <template> elements\",\n            });\n        }\n\n        // Parse expression: \"user in $users\", \"[name, email] in $users\", \"item, index in $items\"\n        const parsed = parseExpression(value);\n        if (!parsed) {\n            throw runtimeErr(\"InvalidForExpression\", {\n                expression: value,\n                expected: 'Format: \"item in $items\", \"[name, age] in $users\", \"item, index in $items\"',\n            });\n        }\n\n        // Get key expression from data-for__key modifier\n        const keyMod = mods.get(\"key\");\n        const keyExpression = keyMod && keyMod.size > 0 ? Array.from(keyMod)[0] : null;\n\n        // Setup\n        const template = el as HTMLTemplateElement;\n        template.style.display = \"none\";\n        const templateContent = template.content.cloneNode(true) as DocumentFragment;\n\n        const sourceSignalPath = parsed.items;\n        const sourceData = getPath(sourceSignalPath);\n        const isNormalized = shouldNormalizeData(sourceData);\n\n        // Generate unique iteration ID for this data-for instance\n        const iterationId = `__for_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n        const state: IterationState = {\n            prevKeys: [],\n            lookup: new Map(),\n            template,\n            templateContent,\n            iteratorNames: parsed,\n            keyExpression,\n            effectCleanup: null,\n            sourceSignalPath,\n            isNormalized,\n            iterationId,\n        };\n\n        iterationStates.set(el, state);\n\n        // Create reactive effect that tracks source signal\n        const effectCleanup = effect(() => {\n            // Access source signal reactively through getPath\n            // This properly triggers Datastar's reactive tracking\n            const sourceData = getPath(sourceSignalPath);\n\n            // For arrays, track structure changes AND deep properties (for objects only)\n            if (Array.isArray(sourceData)) {\n                const reactiveArray = ctx.root[sourceSignalPath];\n\n                // Track deep properties ONLY for object items (not primitives)\n                // This enables reactive updates like: $users[0].name = 'New Name'\n                if (reactiveArray && reactiveArray.length > 0) {\n                    const firstItem = reactiveArray[0];\n                    // Only track deep if items are objects (not strings/numbers)\n                    if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                        for (const key in reactiveArray) {\n                            const item = reactiveArray[key];\n                            void item; // Track array structure\n                            // Track all object properties for reactivity\n                            if (item && typeof item === 'object') {\n                                for (const prop in item) {\n                                    void item[prop];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            const items = normalizeData(sourceData);\n\n            const newArrayWithKeys = items.map((item, index) => ({\n                item,\n                index,\n                key: evaluateKey(keyExpression, item, index),\n            }));\n\n            // Prevent tracking during DOM updates (critical for performance)\n            peek(() => {\n                startBatch();\n                try {\n                    diffAndUpdate(newArrayWithKeys, state, ctx);\n                } finally {\n                    endBatch();\n                }\n            });\n        });\n\n        state.effectCleanup = effectCleanup;\n\n        return () => {\n            cleanup(state);\n            iterationStates.delete(el);\n        };\n    },\n};\n\n/**\n * Parse for expression\n */\nfunction parseExpression(expression: string): ParsedExpression | null {\n    const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    const stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n    const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n\n    const match = expression.match(forAliasRE);\n    if (!match) return null;\n\n    let itemsExpr = match[2].trim();\n    if (itemsExpr.startsWith(\"$\")) {\n        itemsExpr = itemsExpr.slice(1);\n    }\n\n    const result: ParsedExpression = {\n        item: \"\",\n        items: itemsExpr,\n    };\n\n    let item = match[1].replace(stripParensRE, \"\").trim();\n    const iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n        result.item = item.replace(forIteratorRE, \"\").trim();\n        result.index = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n            result.collection = iteratorMatch[2].trim();\n        }\n    } else {\n        result.item = item;\n    }\n\n    return result;\n}\n\n/**\n * Diff and update DOM with keyed diffing\n */\nfunction diffAndUpdate(\n    newArrayWithKeys: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    // Handle duplicate keys\n    const seen = new Set();\n    const finalArray = newArrayWithKeys.map((data, i) => {\n        let finalKey = data.key;\n        if (seen.has(finalKey)) {\n            finalKey = `${finalKey}_dup_${i}`;\n        }\n        seen.add(finalKey);\n        return { ...data, key: finalKey };\n    });\n\n    const newKeys = finalArray.map(d => d.key);\n    const prevKeys = state.prevKeys;\n\n    // Detect change type\n    const changeType = detectChange(prevKeys, newKeys);\n\n    if (changeType === 'no-change') {\n        // NO-CHANGE: Keys haven't changed, but properties might have\n        // Sync ephemeral signals from source for DISPLAY properties (data-text, etc.)\n        // Bindings (data-bind) update ephemeral signals directly, but display\n        // properties need to be synced when source properties change\n        if (!state.isNormalized && finalArray.length > 0) {\n            // Check if this is an object array (first item is an object)\n            const firstItem = finalArray[0].item;\n            if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                for (const itemData of finalArray) {\n                    const loopEl = state.lookup.get(itemData.key);\n                    if (loopEl) {\n                        const sanitizedKey = sanitizeKey(itemData.key);\n                        // Sync ephemeral signal with latest source data\n                        ctx.mergePatch({\n                            [state.iterationId]: {\n                                [sanitizedKey]: itemData.item\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        return;\n    } else if (changeType === 'simple-add') {\n        handleAdd(finalArray, state, ctx);\n    } else if (changeType === 'simple-remove') {\n        handleRemove(prevKeys, newKeys, state, ctx, finalArray);\n    } else {\n        handleReorder(finalArray, state, ctx);\n    }\n\n    state.prevKeys = [...newKeys];\n}\n\n/**\n * Detect change type for optimized updates\n */\nfunction detectChange(prevKeys: any[], newKeys: any[]): 'no-change' | 'simple-add' | 'simple-remove' | 'complex' {\n    if (prevKeys.length === newKeys.length && prevKeys.every((k, i) => k === newKeys[i])) {\n        return 'no-change';\n    }\n\n    if (prevKeys.length < newKeys.length) {\n        if (prevKeys.every((k, i) => k === newKeys[i])) {\n            return 'simple-add';\n        }\n    }\n\n    if (prevKeys.length > newKeys.length) {\n        const newSet = new Set(newKeys);\n        if (!newKeys.some(k => !new Set(prevKeys).has(k))) {\n            let newIdx = 0;\n            for (const pk of prevKeys) {\n                if (newSet.has(pk)) {\n                    if (newKeys[newIdx] !== pk) return 'complex';\n                    newIdx++;\n                }\n            }\n            return 'simple-remove';\n        }\n    }\n\n    return 'complex';\n}\n\n/**\n * Handle simple additions\n */\nfunction handleAdd(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const startIdx = state.prevKeys.length;\n    let prevEl: HTMLOrSVG = state.template;\n\n    if (startIdx > 0) {\n        const lastKey = state.prevKeys[startIdx - 1];\n        const last = state.lookup.get(lastKey);\n        if (last) prevEl = last.el;\n    }\n\n    for (let i = startIdx; i < data.length; i++) {\n        const item = data[i];\n        const loopEl = createElement(item, state, ctx);\n        state.lookup.set(item.key, loopEl);\n        prevEl.after(loopEl.el);\n        prevEl = loopEl.el;\n        queueMicrotask(() => apply(loopEl.el));\n    }\n}\n\n/**\n * Handle simple removals\n */\nfunction handleRemove(\n    prevKeys: any[],\n    newKeys: any[],\n    state: IterationState,\n    ctx: any,\n    data: Array<{ item: any; index: number; key: any }>\n) {\n    const newSet = new Set(newKeys);\n\n    // Remove elements no longer in new keys\n    for (const key of prevKeys) {\n        if (!newSet.has(key)) {\n            const loopEl = state.lookup.get(key);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(key);\n            }\n        }\n    }\n\n    // Update indices for remaining elements\n    for (const itemData of data) {\n        const loopEl = state.lookup.get(itemData.key);\n        if (loopEl && loopEl.index !== itemData.index) {\n            loopEl.index = itemData.index;\n\n            // Update index in ephemeral signal for reactive updates\n            if (!state.isNormalized) {\n                const sanitizedKey = sanitizeKey(itemData.key);\n                const currentData = ctx.root[state.iterationId]?.[sanitizedKey];\n                if (currentData !== undefined) {\n                    ctx.mergePatch({\n                        [state.iterationId]: {\n                            [`${sanitizedKey}__index`]: itemData.index\n                        }\n                    });\n                }\n            }\n        }\n    }\n}\n\n/**\n * Handle complex changes with smart reordering\n */\nfunction handleReorder(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const newSet = new Set(data.map(d => d.key));\n\n    // Remove elements no longer in new keys\n    for (const pk of state.prevKeys) {\n        if (!newSet.has(pk)) {\n            const loopEl = state.lookup.get(pk);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(pk);\n            }\n        }\n    }\n\n    // Reorder/create elements\n    let prevEl: HTMLOrSVG = state.template;\n    for (const item of data) {\n        const existing = state.lookup.get(item.key);\n\n        if (existing) {\n            // Reuse element - update index in ephemeral signal if it changed\n            if (existing.index !== item.index) {\n                existing.index = item.index;\n\n                // Update index in ephemeral signal for reactive updates\n                if (!state.isNormalized) {\n                    const sanitizedKey = sanitizeKey(item.key);\n                    const currentData = ctx.root[state.iterationId]?.[sanitizedKey];\n                    if (currentData !== undefined) {\n                        ctx.mergePatch({\n                            [state.iterationId]: {\n                                [`${sanitizedKey}__index`]: item.index\n                            }\n                        });\n                    }\n                }\n            }\n\n            if (existing.el.previousElementSibling !== prevEl) {\n                prevEl.after(existing.el);\n            }\n            prevEl = existing.el;\n        } else {\n            // Create new element\n            const loopEl = createElement(item, state, ctx);\n            state.lookup.set(item.key, loopEl);\n            prevEl.after(loopEl.el);\n            prevEl = loopEl.el;\n            queueMicrotask(() => apply(loopEl.el));\n        }\n    }\n}\n\n/**\n * Create new loop element with EPHEMERAL SIGNALS\n *\n * CRITICAL: Use ephemeral signals (keyed by item key) to prevent source signal corruption\n */\nfunction createElement(\n    itemData: { item: any; index: number; key: any },\n    state: IterationState,\n    ctx: any\n): LoopElement {\n    const { templateContent, sourceSignalPath, iteratorNames, isNormalized, iterationId } = state;\n\n    const clone = templateContent.cloneNode(true) as DocumentFragment;\n    const el = clone.firstElementChild as HTMLOrSVG;\n\n    // Map iterator to ephemeral signal path (keyed by item key to prevent corruption)\n    let signalPath = sourceSignalPath;\n    let indexSignalPath: string | null = null;\n    if (!isNormalized) {\n        // For arrays: Create ephemeral signal keyed by unique key\n        // This prevents corruption of source signal\n        const sanitizedKey = sanitizeKey(itemData.key);\n        signalPath = `${iterationId}.${sanitizedKey}`;\n        indexSignalPath = `${iterationId}.${sanitizedKey}__index`;\n\n        // Create ephemeral signals for item and index\n        ctx.mergePatch({\n            [iterationId]: {\n                [sanitizedKey]: itemData.item,\n                [`${sanitizedKey}__index`]: itemData.index\n            }\n        });\n    }\n\n    transformElement(el, iteratorNames, itemData.index, signalPath, indexSignalPath, isNormalized, itemData.item);\n\n    return {\n        el,\n        key: itemData.key,\n        index: itemData.index,\n    };\n}\n\n/**\n * Sanitize key for use as signal path\n */\nfunction sanitizeKey(key: any): string {\n    return String(key).replace(/[^a-zA-Z0-9_]/g, '_');\n}\n\n/**\n * Transform element attributes\n */\nfunction transformElement(\n    el: HTMLOrSVG,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n) {\n    const process = (elem: Element): void => {\n        Array.from(elem.attributes).forEach((attr) => {\n            if (attr.name.startsWith(\"data-\") && attr.value) {\n                attr.value = transformExpression(\n                    attr.value,\n                    attr.name,\n                    iterators,\n                    index,\n                    signalPath,\n                    indexSignalPath,\n                    isNormalized,\n                    value\n                );\n            }\n        });\n\n        if (elem instanceof HTMLTemplateElement && elem.content) {\n            Array.from(elem.content.children).forEach(child => process(child));\n        } else {\n            Array.from(elem.children).forEach(child => process(child));\n        }\n    };\n\n    process(el);\n}\n\n/**\n * Transform expression\n */\nfunction transformExpression(\n    expr: string,\n    attrName: string,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n): string {\n    let result = expr;\n\n    // Determine if signal name or expression\n    const isSignalName = /^(bind|ref|indicator|signals|computed)/.test(attrName.replace(/^data-/, \"\"));\n\n    // Protect string literals\n    const literals: string[] = [];\n    result = result\n        .replace(/'(?:[^'\\\\]|\\\\.)*'/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/\"(?:[^\"\\\\]|\\\\.)*\"/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/`(?:[^`\\\\]|\\\\.)*`/g, m => (literals.push(m), `__LIT${literals.length - 1}__`));\n\n    // Transform index - use reactive signal if available, otherwise literal\n    if (iterators.index) {\n        if (indexSignalPath && !isNormalized) {\n            // Use reactive index signal with $ prefix for expressions\n            const prefix = isSignalName ? \"\" : \"$\";\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), prefix + indexSignalPath);\n        } else {\n            // Fallback to literal index for normalized data\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), index.toString());\n        }\n    }\n\n    // Transform collection\n    if (iterators.collection) {\n        const prefix = isSignalName ? \"\" : \"$\";\n        result = result.replace(new RegExp(`\\\\b${esc(iterators.collection)}\\\\b`, \"g\"), prefix + signalPath);\n    }\n\n    // Transform item\n    if (isDestructured(iterators.item)) {\n        const vars = extractVars(iterators.item);\n        const isArrayDestructuring = iterators.item.trim().startsWith('[');\n\n        vars.forEach((v, idx) => {\n            let varSignalPath: string;\n            let varValue: any;\n\n            if (isArrayDestructuring) {\n                // Array destructuring: [x, y] → signalPath.0, signalPath.1\n                varSignalPath = `${signalPath}.${idx}`;\n                varValue = Array.isArray(value) ? value[idx] : value;\n            } else {\n                // Object destructuring: {name, price} → signalPath.name, signalPath.price\n                varSignalPath = `${signalPath}.${v}`;\n                varValue = value && typeof value === 'object' ? value[v] : value;\n            }\n\n            result = transformVar(result, v, varSignalPath, isSignalName, isNormalized, varValue, iterators);\n        });\n    } else {\n        result = transformVar(result, iterators.item, signalPath, isSignalName, isNormalized, value, iterators);\n    }\n\n    // Restore literals\n    result = result.replace(/__LIT(\\d+)__/g, (_, i) => literals[parseInt(i)]);\n\n    return result;\n}\n\n/**\n * Transform variable\n */\nfunction transformVar(\n    expr: string,\n    varName: string,\n    signalPath: string,\n    isSignalName: boolean,\n    isNormalized: boolean,\n    value: any,\n    _iterators: ParsedExpression\n): string {\n    if (isNormalized) {\n        // Value-based: replace with literal value\n        return expr.replace(new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"), JSON.stringify(value));\n    }\n\n    const prefix = isSignalName ? \"\" : \"$\";\n\n    // Property access: varName.prop → signalPath.prop\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\.([a-zA-Z_][a-zA-Z0-9_.]*)\\\\b`, \"g\"),\n        `${prefix}${signalPath}.$1`\n    );\n\n    // Standalone: varName → signalPath\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"),\n        prefix + signalPath\n    );\n\n    return expr;\n}\n\n/**\n * Utilities\n */\nfunction shouldNormalizeData(data: any): boolean {\n    return typeof data === \"number\" || (data && typeof data === \"object\" && !Array.isArray(data));\n}\n\nfunction normalizeData(data: any): any[] {\n    if (data == null) return [];\n    if (Array.isArray(data)) return data;\n    if (typeof data === \"number\") return Array.from({ length: data }, (_, i) => i + 1);\n    if (typeof data === \"object\") return Object.entries(data);\n    return [data];\n}\n\nfunction evaluateKey(keyExpr: string | null, item: any, index: number): any {\n    if (!keyExpr) {\n        if (item && typeof item === \"object\") {\n            if (\"id\" in item && item.id != null) return item.id;\n            if (\"uuid\" in item && item.uuid != null) return item.uuid;\n            if (\"key\" in item && item.key != null) return item.key;\n        }\n        return index;\n    }\n\n    if (keyExpr === \"index\") return index;\n\n    if (keyExpr.includes('.')) {\n        const parts = keyExpr.split('.');\n        let val = item;\n        for (const part of parts) {\n            if (val && typeof val === \"object\" && part in val) {\n                val = val[part];\n            } else {\n                return index;\n            }\n        }\n        return val !== undefined && val !== null ? val : index;\n    }\n\n    if (item && typeof item === \"object\" && keyExpr in item) {\n        const keyVal = item[keyExpr];\n        return keyVal !== undefined && keyVal !== null ? keyVal : index;\n    }\n\n    return index;\n}\n\nfunction isDestructured(item: string): boolean {\n    return /^\\[.*\\]$/.test(item) || /^\\{.*\\}$/.test(item);\n}\n\nfunction extractVars(item: string): string[] {\n    return item\n        .replace(/[\\[\\]\\{\\}]/g, \"\")\n        .split(\",\")\n        .map(i => i.trim());\n}\n\nfunction esc(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nfunction cleanup(state: IterationState) {\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    state.lookup.forEach(loopEl => loopEl.el.remove());\n    state.lookup.clear();\n    state.prevKeys.length = 0;\n}\n","// Icon: material-symbols:check-circle-outline\n// Slug: Conditionally renders elements based on expression.\n// Description: Implements conditional rendering like Alpine.js x-if - must be on <template> with single root element. Uses computed wrapper for proper reactivity with Datastar's signal system.\n\nimport type { AttributePlugin, HTMLOrSVG } from \"../../../datastar/engine/types\";\nimport { apply } from \"../../../datastar/engine\";\n\n/**\n * State management interface for each data-if instance\n */\ninterface IfState {\n    renderedElement: Element | null;\n    isRendered: boolean;\n    commentMarker: Comment;\n    effectCleanup: (() => void) | null;\n    ifId: string;\n}\n\n// WeakMap to store if state per element\nconst ifStates = new WeakMap<HTMLOrSVG, IfState>();\nlet ifCounter = 0;\n\nexport const If: AttributePlugin = {\n    type: \"attribute\",\n    name: \"if\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: true,\n    returnsValue: true,\n    onLoad: ({ el, effect, rx, runtimeErr, computed }) => {\n        // VALIDATION: Must be on template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw runtimeErr(\"IfMustBeOnTemplate\", {\n                message: \"data-if must be used on <template> elements\",\n            });\n        }\n\n        // VALIDATION: Template must have single root element (Alpine.js requirement)\n        const templateContent = el.content;\n        const rootElements = Array.from(templateContent.children);\n        if (rootElements.length !== 1) {\n            throw runtimeErr(\"IfTemplateMustHaveSingleRoot\", {\n                count: rootElements.length,\n                message:\n                    \"data-if template must contain exactly one root element\",\n            });\n        }\n\n        const template = el;\n        const container = template.parentElement!;\n\n        // Hide template element\n        template.style.display = \"none\";\n\n        // ALPINE.JS PATTERN: Create comment marker for reliable positioning\n        const ifId = `__if_${++ifCounter}`;\n        const commentMarker = document.createComment(`Datastar if ${ifId}`);\n        container.insertBefore(commentMarker, template.nextSibling);\n\n        // Initialize state tracking with WeakMap (data-for pattern)\n        const state: IfState = {\n            renderedElement: null,\n            isRendered: false,\n            commentMarker,\n            effectCleanup: null,\n            ifId,\n        };\n\n        ifStates.set(el, state);\n\n        try {\n            // COMPUTED WRAPPER: Re-evaluate expression reactively (data-for pattern)\n            // This ensures proper subscription even when signals are deleted/recreated by Datastar\n            const conditionComputed = computed(() => {\n                return rx(); // Evaluate reactive expression inside computed\n            });\n\n            // DATASTAR REACTIVE EFFECT: Conditional rendering\n            const effectCleanup = effect(() => {\n                const shouldRender = !!conditionComputed();\n\n                // State transition: false -> true (RENDER)\n                if (shouldRender && !state.isRendered) {\n                    state.renderedElement = renderElement(\n                        template,\n                        state.commentMarker\n                    );\n                    state.isRendered = true;\n                }\n                // State transition: true -> false (CLEANUP)\n                else if (!shouldRender && state.isRendered) {\n                    if (state.renderedElement) {\n                        cleanupElement(state.renderedElement);\n                        state.renderedElement = null;\n                    }\n                    state.isRendered = false;\n                }\n            });\n\n            state.effectCleanup = effectCleanup;\n\n            // Return cleanup function (called when plugin is removed)\n            return () => {\n                cleanupIfInstance(state);\n                ifStates.delete(el);\n            };\n        } catch (error) {\n            // Cleanup on error\n            const instanceState = ifStates.get(el);\n            if (instanceState) {\n                cleanupIfInstance(instanceState);\n                ifStates.delete(el);\n            }\n            throw error;\n        }\n    },\n};\n\n/**\n * RENDER FUNCTION: Clone template and insert into DOM\n * Follows data-for pattern with queueMicrotask for Datastar processing\n */\nfunction renderElement(\n    template: HTMLTemplateElement,\n    commentMarker: Comment\n): Element {\n    // Clone template content\n    const clone = template.content.cloneNode(true) as DocumentFragment;\n    const element = clone.firstElementChild as Element;\n\n    // Insert element into DOM after the comment marker\n    commentMarker.parentNode!.insertBefore(element, commentMarker.nextSibling);\n\n    // Apply Datastar processing to generated element\n    // Use queueMicrotask to ensure DOM is ready (data-for pattern)\n    queueMicrotask(() => {\n        apply(element as HTMLElement);\n    });\n\n    return element;\n}\n\n/**\n * CLEANUP FUNCTION: Remove element from DOM\n * Datastar's mutation observer handles attribute cleanup\n */\nfunction cleanupElement(element: Element): void {\n    element.remove();\n}\n\n/**\n * COMPREHENSIVE CLEANUP: Clean up entire if instance\n * Follows data-for's comprehensive cleanup pattern\n */\nfunction cleanupIfInstance(state: IfState): void {\n    // Cleanup reactive effect\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    // Remove rendered element if present\n    if (state.renderedElement) {\n        cleanupElement(state.renderedElement);\n        state.renderedElement = null;\n    }\n\n    // Remove comment marker\n    if (state.commentMarker && state.commentMarker.parentNode) {\n        state.commentMarker.remove();\n    }\n\n    // Reset state\n    state.isRendered = false;\n}\n","import {\n    DATASTAR,\n    DATASTAR_REQUEST,\n    DefaultSseRetryDurationMs,\n    EventTypePatchElements,\n    EventTypePatchSignals,\n} from \"../../../engine/consts\";\n// Factory for creating HTTP method action plugins\nimport type {\n    ActionPlugin,\n    HTMLOrSVG,\n    RuntimeContext,\n    SignalFilterOptions,\n} from \"../../../engine/types\";\nimport { kebab } from \"../../../utils/text\";\nimport {\n    DATASTAR_FETCH_EVENT,\n    type DatastarFetchEvent,\n    ERROR,\n    FINISHED,\n    RETRIES_FAILED,\n    RETRYING,\n    STARTED,\n} from \"../shared\";\n\n// Global store for active SSE controllers per element\nconst fetchAbortControllers = new WeakMap<HTMLOrSVG, AbortController>();\n\n// Helper to create HTTP method plugins with consistent structure\nexport const createHttpMethod = (\n    name: string,\n    method: string\n): ActionPlugin => ({\n    type: \"action\",\n    name,\n    fn: async (ctx, url: string, args: FetchArgs) => {\n        const { el } = ctx;\n\n        const requestCancellation = args?.requestCancellation ?? \"auto\";\n        const controller =\n            requestCancellation instanceof AbortController\n                ? requestCancellation\n                : new AbortController();\n        const isDisabled = requestCancellation === \"disabled\";\n        if (!isDisabled) {\n            fetchAbortControllers.get(el)?.abort();\n        }\n\n        if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n            fetchAbortControllers.set(el, controller);\n        }\n\n        try {\n            await fetcher(ctx, method, url, args, controller.signal);\n        } finally {\n            if (fetchAbortControllers.get(el) === controller) {\n                fetchAbortControllers.delete(el);\n            }\n        }\n    },\n});\n\nconst dispatchFetch = (\n    type: string,\n    el: HTMLOrSVG,\n    argsRaw: Record<string, string>\n) =>\n    document.dispatchEvent(\n        new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n            detail: { type, el, argsRaw },\n        })\n    );\n\nconst isWrongContent = (err: any) => `${err}`.includes(\"text/event-stream\");\n\ntype ResponseOverrides =\n    | {\n          selector?: string;\n          mode?: string;\n          useViewTransition?: boolean;\n      }\n    | {\n          onlyIfMissing?: boolean;\n      };\n\nexport type FetchArgs = {\n    headers?: Record<string, string>;\n    openWhenHidden?: boolean;\n    retryInterval?: number;\n    retryScaler?: number;\n    retryMaxWaitMs?: number;\n    retryMaxCount?: number;\n    responseOverrides?: ResponseOverrides;\n    contentType?: \"json\" | \"form\";\n    filterSignals?: SignalFilterOptions;\n    selector?: string;\n    requestCancellation?: \"auto\" | \"disabled\" | AbortController;\n};\n\nconst fetcher = async (\n    { el, evt, filtered, runtimeErr }: RuntimeContext,\n    method: string,\n    url: string,\n    {\n        selector,\n        headers: userHeaders,\n        contentType = \"json\",\n        filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n        openWhenHidden = false,\n        retryInterval = DefaultSseRetryDurationMs,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n    }: FetchArgs = {},\n    abort?: AbortSignal\n) => {\n    const action = method.toLowerCase();\n    let cleanupFn = () => {};\n    try {\n        if (!url?.length) {\n            throw runtimeErr(\"FetchNoUrlProvided\", { action });\n        }\n\n        const initialHeaders: Record<string, any> = {\n            Accept: \"text/event-stream, text/html, application/json\",\n            [DATASTAR_REQUEST]: true,\n        };\n        if (contentType === \"json\") {\n            initialHeaders[\"Content-Type\"] = \"application/json\";\n        }\n        const headers = Object.assign({}, initialHeaders, userHeaders);\n\n        // We ignore the content-type header if using form data\n        // if missing the boundary will be set automatically\n\n        const req: FetchEventSourceInit = {\n            method,\n            headers,\n            openWhenHidden,\n            retryInterval,\n            retryScaler,\n            retryMaxWaitMs,\n            retryMaxCount,\n            signal: abort,\n            onopen: async (response: Response) => {\n                if (response.status >= 400)\n                    dispatchFetch(ERROR, el, {\n                        status: response.status.toString(),\n                    });\n            },\n            onmessage: (evt) => {\n                if (!evt.event.startsWith(DATASTAR)) return;\n                const type = evt.event;\n                const argsRawLines: Record<string, string[]> = {};\n\n                for (const line of evt.data.split(\"\\n\")) {\n                    const i = line.indexOf(\" \");\n                    const k = line.slice(0, i);\n                    const v = line.slice(i + 1);\n                    (argsRawLines[k] ||= []).push(v);\n                }\n\n                const argsRaw = Object.fromEntries(\n                    Object.entries(argsRawLines).map(([k, v]) => [\n                        k,\n                        v.join(\"\\n\"),\n                    ])\n                );\n\n                dispatchFetch(type, el, argsRaw);\n            },\n            onerror: (error) => {\n                if (isWrongContent(error)) {\n                    // don't retry if the content-type is wrong\n                    throw runtimeErr(\"InvalidContentType\", { url });\n                }\n                // do nothing and it will retry\n                if (error) {\n                    console.error(error.message);\n                    dispatchFetch(RETRYING, el, { message: error.message });\n                }\n            },\n        };\n\n        const urlInstance = new URL(url, window.location.href);\n        const queryParams = new URLSearchParams(urlInstance.search);\n\n        if (contentType === \"json\") {\n            const res = JSON.stringify(filtered({ include, exclude }));\n            if (method === \"GET\") {\n                queryParams.set(DATASTAR, res);\n            } else {\n                req.body = res;\n            }\n        } else if (contentType === \"form\") {\n            const formEl = (\n                selector ? document.querySelector(selector) : el.closest(\"form\")\n            ) as HTMLFormElement;\n            if (!formEl) {\n                throw runtimeErr(\n                    selector ? \"FetchFormNotFound\" : \"FetchClosestFormNotFound\",\n                    { action, selector }\n                );\n            }\n\n            // Validate the form\n            if (!formEl.checkValidity()) {\n                formEl.reportValidity();\n                cleanupFn();\n                return;\n            }\n\n            // Collect the form data\n\n            const formData = new FormData(formEl);\n            let submitter = el as HTMLElement | null;\n\n            if (el === formEl && evt instanceof SubmitEvent) {\n                // Get the submitter from the event\n                submitter = evt.submitter;\n            } else {\n                // Prevent the form being submitted\n                const preventDefault = (evt: Event) => evt.preventDefault();\n                formEl.addEventListener(\"submit\", preventDefault);\n                cleanupFn = () =>\n                    formEl.removeEventListener(\"submit\", preventDefault);\n            }\n\n            // Append the value of the form submitter if it is a button with a name\n            if (submitter instanceof HTMLButtonElement) {\n                const name = submitter.getAttribute(\"name\");\n                if (name) formData.append(name, submitter.value);\n            }\n\n            const multipart =\n                formEl.getAttribute(\"enctype\") === \"multipart/form-data\";\n            // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n            if (!multipart) {\n                headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            }\n\n            const formParams = new URLSearchParams(formData as any);\n            if (method === \"GET\") {\n                for (const [key, value] of formParams) {\n                    queryParams.append(key, value);\n                }\n            } else if (multipart) {\n                // Upload progress events are only available for: HTTPS connections (required for streaming uploads) with Multipart form data uploads\n                if (\n                    __USE_UPLOAD_PROGRESS__ &&\n                    urlInstance.protocol === \"https:\"\n                ) {\n                    const boundary = `----FormDataBoundary${Math.random()\n                        .toString(36)\n                        .substring(2, 11)}`;\n                    const encoder = new TextEncoder();\n\n                    // Calculate total size\n                    let total = 0;\n                    const parts: Array<{\n                        field: string;\n                        value: string | File;\n                    }> = [];\n\n                    for (const [name, value] of formData) {\n                        parts.push({ field: name, value });\n                        total += encoder.encode(`--${boundary}\\r\\n`).byteLength;\n\n                        if (value instanceof File) {\n                            total += encoder.encode(\n                                `Content-Disposition: form-data; name=\"${name}\"; filename=\"${value.name}\"\\r\\n` +\n                                    `Content-Type: ${\n                                        value.type || \"application/octet-stream\"\n                                    }\\r\\n\\r\\n`\n                            ).byteLength;\n                            total += value.size + 2;\n                        } else {\n                            total += encoder.encode(\n                                `Content-Disposition: form-data; name=\"${name}\"\\r\\n\\r\\n${value}\\r\\n`\n                            ).byteLength;\n                        }\n                    }\n                    total += encoder.encode(`--${boundary}--\\r\\n`).byteLength;\n\n                    let loaded = 0;\n\n                    req.body = new ReadableStream({\n                        async start(controller) {\n                            const write = (data: Uint8Array) => {\n                                controller.enqueue(data);\n                                loaded += data.byteLength;\n\n                                const progress = Math.round(\n                                    (loaded / total) * 100\n                                );\n                                dispatchFetch(\"upload-progress\", el, {\n                                    progress: progress.toString(),\n                                    loaded: loaded.toString(),\n                                    total: total.toString(),\n                                });\n                            };\n\n                            dispatchFetch(\"upload-progress\", el, {\n                                progress: \"0\",\n                                loaded: \"0\",\n                                total: total.toString(),\n                            });\n\n                            try {\n                                for (const { field, value } of parts) {\n                                    write(encoder.encode(`--${boundary}\\r\\n`));\n\n                                    if (value instanceof File) {\n                                        write(\n                                            encoder.encode(\n                                                `Content-Disposition: form-data; name=\"${field}\"; filename=\"${value.name}\"\\r\\n` +\n                                                    `Content-Type: ${\n                                                        value.type ||\n                                                        \"application/octet-stream\"\n                                                    }\\r\\n\\r\\n`\n                                            )\n                                        );\n\n                                        const reader = value\n                                            .stream()\n                                            .getReader();\n                                        try {\n                                            while (true) {\n                                                const { done, value: chunk } =\n                                                    await reader.read();\n                                                if (done) break;\n                                                write(chunk);\n                                            }\n                                        } finally {\n                                            reader.releaseLock();\n                                        }\n                                        write(encoder.encode(\"\\r\\n\"));\n                                    } else {\n                                        write(\n                                            encoder.encode(\n                                                `Content-Disposition: form-data; name=\"${field}\"\\r\\n\\r\\n${value}\\r\\n`\n                                            )\n                                        );\n                                    }\n                                }\n\n                                write(encoder.encode(`--${boundary}--\\r\\n`));\n\n                                if (loaded < total) {\n                                    dispatchFetch(\"upload-progress\", el, {\n                                        progress: \"100\",\n                                        loaded: total.toString(),\n                                        total: total.toString(),\n                                    });\n                                }\n\n                                controller.close();\n                            } catch (error) {\n                                controller.error(error);\n                            }\n                        },\n                    });\n\n                    // Override content-type header with the boundary\n                    headers[\n                        \"Content-Type\"\n                    ] = `multipart/form-data; boundary=${boundary}`;\n                    // Set duplex mode for streaming uploads\n                    (req as any).duplex = \"half\";\n                } else {\n                    req.body = formData;\n                }\n            } else {\n                req.body = formParams;\n            }\n        } else {\n            throw runtimeErr(\"FetchInvalidContentType\", {\n                action,\n                contentType,\n            });\n        }\n\n        dispatchFetch(STARTED, el, {});\n        urlInstance.search = queryParams.toString();\n\n        try {\n            await fetchEventSource(urlInstance.toString(), el, req);\n        } catch (error) {\n            if (!isWrongContent(error)) {\n                throw runtimeErr(\"FetchFailed\", { method, url, error });\n            }\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they haven’t\n            // set the content-type to text/event-stream\n        }\n    } finally {\n        dispatchFetch(FINISHED, el, {});\n        cleanupFn();\n    }\n};\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n    id: string;\n    event: string;\n    data: string;\n    retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nasync function getBytes(\n    stream: ReadableStream<Uint8Array>,\n    onChunk: (arr: Uint8Array) => void\n): Promise<void> {\n    const reader = stream.getReader();\n    let result = await reader.read();\n    while (!result.done) {\n        onChunk(result.value);\n        result = await reader.read();\n    }\n}\n\nfunction getLines(onLine: (line: Uint8Array, fieldLength: number) => void) {\n    let buffer: Uint8Array | undefined;\n    let position: number; // current read position\n    let fieldLength: number; // length of the `field` portion of the line\n    let discardTrailingNewline = false;\n\n    // return a function that can process each incoming byte chunk:\n    return function onChunk(arr: Uint8Array) {\n        if (!buffer) {\n            buffer = arr;\n            position = 0;\n            fieldLength = -1;\n        } else {\n            // we're still parsing the old line. Append the new bytes into buffer:\n            buffer = concat(buffer, arr);\n        }\n\n        const bufLength = buffer.length;\n        let lineStart = 0; // index where the current line starts\n        while (position < bufLength) {\n            if (discardTrailingNewline) {\n                if (buffer[position] === 10) lineStart = ++position; // skip to next char\n                discardTrailingNewline = false;\n            }\n\n            // start looking forward till the end of line:\n            let lineEnd = -1; // index of the \\r or \\n char\n            for (; position < bufLength && lineEnd === -1; ++position) {\n                switch (buffer[position]) {\n                    case 58: // :\n                        if (fieldLength === -1) {\n                            // first colon in line\n                            fieldLength = position - lineStart;\n                        }\n                        break;\n                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:\n                    // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n                    case 13: // \\r\n                        discardTrailingNewline = true;\n                    case 10: // \\n\n                        lineEnd = position;\n                        break;\n                }\n            }\n\n            if (lineEnd === -1) break; // Wait for the next arr and then continue parsing\n\n            // we've reached the line end, send it out:\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n            lineStart = position; // we're now on the next line\n            fieldLength = -1;\n        }\n\n        if (lineStart === bufLength)\n            buffer = undefined; // we've finished reading it\n        else if (lineStart) {\n            // Create a new view into buffer beginning at lineStart so we don't\n            // need to copy over the previous lines when we get the new arr:\n            buffer = buffer.subarray(lineStart);\n            position -= lineStart;\n        }\n    };\n}\n\nfunction getMessages(\n    onId: (id: string) => void,\n    onRetry: (retry: number) => void,\n    onMessage?: (msg: EventSourceMessage) => void\n) {\n    let message = newMessage();\n    const decoder = new TextDecoder();\n\n    // return a function that can process each incoming line buffer:\n    return function onLine(line: Uint8Array, fieldLength: number) {\n        if (!line.length) {\n            // empty line denotes end of message. Trigger the callback and start a new message:\n            onMessage?.(message);\n            message = newMessage();\n        } else if (fieldLength > 0) {\n            // exclude comments and lines with no values\n            // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n            const field = decoder.decode(line.subarray(0, fieldLength));\n            const valueOffset =\n                fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\n            const value = decoder.decode(line.subarray(valueOffset));\n\n            switch (field) {\n                case \"data\":\n                    message.data = message.data\n                        ? `${message.data}\\n${value}`\n                        : value;\n                    break;\n                case \"event\":\n                    message.event = value;\n                    break;\n                case \"id\":\n                    onId((message.id = value));\n                    break;\n                case \"retry\": {\n                    const retry = +value;\n                    if (!Number.isNaN(retry)) {\n                        // per spec, ignore non-integers\n                        onRetry((message.retry = retry));\n                    }\n                    break;\n                }\n            }\n        }\n    };\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n    const res = new Uint8Array(a.length + b.length);\n    res.set(a);\n    res.set(b, a.length);\n    return res;\n};\n\nconst newMessage = (): EventSourceMessage => ({\n    // data, event, and id must be initialized to empty strings:\n    // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n    // retry should be initialized to undefined so we return a consistent shape\n    // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n});\n\ninterface FetchEventSourceInit extends RequestInit {\n    headers?: Record<string, string>;\n    onopen?: (response: Response) => Promise<void>;\n    onmessage?: (ev: EventSourceMessage) => void;\n    onclose?: () => void;\n    onerror?: (err: any) => number | null | undefined | void;\n    openWhenHidden?: boolean;\n    fetch?: typeof fetch;\n    retryInterval?: number;\n    retryScaler?: number;\n    retryMaxWaitMs?: number;\n    retryMaxCount?: number;\n    overrides?: ResponseOverrides;\n}\n\nfunction fetchEventSource(\n    input: RequestInfo,\n    el: HTMLOrSVG,\n    {\n        signal: inputSignal,\n        headers: inputHeaders,\n        onopen: inputOnOpen,\n        onmessage,\n        onclose,\n        onerror,\n        openWhenHidden,\n        fetch: inputFetch,\n        retryInterval = 1_000,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n        overrides,\n        ...rest\n    }: FetchEventSourceInit\n) {\n    return new Promise<void>((resolve, reject) => {\n        // make a copy of the input headers since we may modify it below:\n        const headers: Record<string, string> = {\n            ...inputHeaders,\n        };\n\n        let curRequestController: AbortController;\n        function onVisibilityChange() {\n            curRequestController.abort(); // close existing request on every visibility change\n            if (!document.hidden) create(); // page is now visible again, recreate request.\n        }\n\n        if (!openWhenHidden) {\n            document.addEventListener(\"visibilitychange\", onVisibilityChange);\n        }\n\n        let retryTimer = 0;\n        function dispose() {\n            document.removeEventListener(\n                \"visibilitychange\",\n                onVisibilityChange\n            );\n            window.clearTimeout(retryTimer);\n            curRequestController.abort();\n        }\n\n        // if the incoming signal aborts, dispose resources and resolve:\n        inputSignal?.addEventListener(\"abort\", () => {\n            dispose();\n            resolve(); // don't waste time constructing/logging errors\n        });\n\n        const fetch = inputFetch || window.fetch;\n        const onopen = inputOnOpen || (() => {});\n\n        let retries = 0;\n        let baseRetryInterval = retryInterval;\n        async function create() {\n            curRequestController = new AbortController();\n            try {\n                const response = await fetch(input, {\n                    ...rest,\n                    headers,\n                    signal: curRequestController.signal,\n                });\n\n                // on successful connection, reset the retry logic\n                retries = 0;\n                retryInterval = baseRetryInterval;\n\n                await onopen(response);\n\n                const dispatchNonSSE = async (\n                    dispatchType: string,\n                    response: Response,\n                    name: string,\n                    overrides?: ResponseOverrides,\n                    ...argNames: string[]\n                ) => {\n                    const argsRaw: Record<string, string> = {\n                        [name]: await response.text(),\n                    };\n                    for (const n of argNames) {\n                        let v = response.headers.get(`datastar-${kebab(n)}`);\n                        if (overrides) {\n                            const o = (overrides as any)[n];\n                            if (o)\n                                v =\n                                    typeof o === \"string\"\n                                        ? o\n                                        : JSON.stringify(o);\n                        }\n                        if (v) argsRaw[n] = v;\n                    }\n\n                    dispatchFetch(dispatchType, el, argsRaw);\n                    dispose();\n                    resolve();\n                };\n\n                const ct = response.headers.get(\"Content-Type\");\n                if (ct?.includes(\"text/html\")) {\n                    return await dispatchNonSSE(\n                        EventTypePatchElements,\n                        response,\n                        \"elements\",\n                        overrides,\n                        \"selector\",\n                        \"mode\",\n                        \"useViewTransition\"\n                    );\n                }\n\n                if (ct?.includes(\"application/json\")) {\n                    return await dispatchNonSSE(\n                        EventTypePatchSignals,\n                        response,\n                        \"signals\",\n                        overrides,\n                        \"onlyIfMissing\"\n                    );\n                }\n\n                if (ct?.includes(\"text/javascript\")) {\n                    const script = document.createElement(\"script\");\n                    const scriptAttributesHeader = response.headers.get(\n                        \"datastar-script-attributes\"\n                    );\n\n                    if (scriptAttributesHeader) {\n                        for (const [name, value] of Object.entries(\n                            JSON.parse(scriptAttributesHeader)\n                        )) {\n                            script.setAttribute(name, value as string);\n                        }\n                    }\n                    script.textContent = await response.text();\n                    document.head.appendChild(script);\n                    dispose();\n                    return;\n                }\n\n                await getBytes(\n                    response.body!,\n                    getLines(\n                        getMessages(\n                            (id) => {\n                                if (id) {\n                                    // signals the id and send it back on the next retry:\n                                    headers[\"last-event-id\"] = id;\n                                } else {\n                                    // don't send the last-event-id header anymore:\n                                    delete headers[\"last-event-id\"];\n                                }\n                            },\n                            (retry) => {\n                                baseRetryInterval = retryInterval = retry;\n                            },\n                            onmessage\n                        )\n                    )\n                );\n\n                onclose?.();\n                dispose();\n                resolve();\n            } catch (err) {\n                if (!curRequestController.signal.aborted) {\n                    // if we haven’t aborted the request ourselves:\n                    try {\n                        // check if we need to retry:\n                        const interval: any = onerror?.(err) || retryInterval;\n                        window.clearTimeout(retryTimer);\n                        retryTimer = window.setTimeout(create, interval);\n                        retryInterval = Math.min(\n                            retryInterval * retryScaler,\n                            retryMaxWaitMs\n                        ); // exponential backoff\n                        if (++retries >= retryMaxCount) {\n                            dispatchFetch(RETRIES_FAILED, el, {});\n                            // we should not retry anymore:\n                            dispose();\n                            reject(\"Max retries reached.\"); // Max retries reached, check your server or network connection\n                        } else {\n                            console.error(\n                                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`\n                            );\n                        }\n                    } catch (innerErr) {\n                        // we should not retry anymore:\n                        dispose();\n                        reject(innerErr);\n                    }\n                }\n            }\n        }\n\n        create();\n    });\n}\n","// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request.\n// Description: Sends a `DELETE` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const DELETE = createHttpMethod('delete', 'DELETE')\n","// Icon: ic:baseline-get-app\n// Slug: Sends a `GET` request.\n// Description: Sends a `GET` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const GET = createHttpMethod('get', 'GET')\n","// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request.\n// Description: Sends a `PATCH` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PATCH = createHttpMethod('patch', 'PATCH')\n","// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request.\n// Description: Sends a `POST` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const POST = createHttpMethod('post', 'POST')\n","// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request.\n// Description: Sends a `PUT` request to the backend using `fetch`.\n\nimport { createHttpMethod } from './fetch'\n\nexport const PUT = createHttpMethod('put', 'PUT')\n","/**\n * Laravel CSRF Token Utilities\n * Handles automatic CSRF token injection for Laravel routes\n */\n\n/**\n * Get CSRF token from Laravel's meta tag\n */\nexport function getCSRFToken(): string | null {\n    const metaTag = document.querySelector('meta[name=\"csrf-token\"]');\n    return metaTag?.getAttribute(\"content\") || null;\n}\n\n/**\n * Check if user already provided CSRF token manually\n */\nexport function hasManualCSRF(\n    userHeaders: Record<string, string> = {}\n): boolean {\n    const csrfHeaders = [\"X-CSRF-TOKEN\", \"x-csrf-token\", \"X-Csrf-Token\"];\n    return csrfHeaders.some((header) => userHeaders[header]);\n}\n\n/**\n * Get CSRF headers for Laravel routes (only if not manually provided)\n */\nexport function getCSRFHeaders(\n    userHeaders: Record<string, string> = {}\n): Record<string, string> {\n    if (hasManualCSRF(userHeaders)) {\n        return {}; // Don't override manual CSRF\n    }\n\n    const csrfToken = getCSRFToken();\n    return csrfToken ? { \"X-CSRF-TOKEN\": csrfToken } : {};\n}\n","// hyper-ext/plugins/backend/actions/fetch-laravel.ts\nimport type { ActionPlugin } from \"../../../../datastar/engine/types\";\nimport {\n    createHttpMethod,\n    type FetchArgs,\n} from \"../../../../datastar/plugins/backend/actions/fetch\";\nimport { getCSRFHeaders } from \"../../../utils/csrf\";\n\n/**\n * Factory for creating Laravel-aware HTTP method plugins with auto-CSRF injection\n * Enhances base Datastar fetch with Laravel CSRF token handling\n */\nexport const createHttpMethodWithCSRF = (\n    name: string,\n    method: string\n): ActionPlugin => {\n    const basePlugin = createHttpMethod(name, method);\n\n    return {\n        ...basePlugin,\n        fn: async (ctx, url: string, args: FetchArgs) => {\n            // Enhance args with CSRF headers\n            const enhancedArgs = {\n                ...args,\n                headers: {\n                    ...args?.headers,\n                    ...getCSRFHeaders(args?.headers),\n                },\n            };\n\n            // Delegate to base plugin with enhanced args\n            return basePlugin.fn(ctx, url, enhancedArgs);\n        },\n    };\n};\n","// Icon: ri:signpost-fill\n// Slug: Sends a `POST` request with Laravel CSRF token.\n// Description: Sends a `POST` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const POSTX = createHttpMethodWithCSRF(\"postx\", \"POST\");\n","// Icon: material-symbols:arrows-input\n// Slug: Sends a `PUT` request with Laravel CSRF token.\n// Description: Sends a `PUT` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const PUTX = createHttpMethodWithCSRF(\"putx\", \"PUT\");\n","// Icon: fluent:patch-24-filled\n// Slug: Sends a `PATCH` request with Laravel CSRF token.\n// Description: Sends a `PATCH` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const PATCHX = createHttpMethodWithCSRF(\"patchx\", \"PATCH\");\n","// Icon: material-symbols:delete-outline\n// Slug: Sends a `DELETE` request with Laravel CSRF token.\n// Description: Sends a `DELETE` request to Laravel routes with automatic CSRF token injection.\n\nimport { createHttpMethodWithCSRF } from \"./fetch-laravel\";\n\nexport const DELETEX = createHttpMethodWithCSRF(\"deletex\", \"DELETE\");\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/actions/navigate.ts\n// Icon: material-symbols:navigation\n// Slug: Enhanced navigate action with JSON query support and consistent behavior.\n// Description: Professional navigate action that supports both string URLs and JSON query objects.\n\nimport type {\n    ActionPlugin,\n    RuntimeContext,\n} from \"../../../../datastar/engine/types\";\n\n/**\n * Enhanced Navigate Action - Professional Navigation with JSON Support\n *\n * Provides consistent navigation behavior between frontend expressions and backend responses.\n * Supports both traditional URL strings and JSON query parameter objects.\n *\n * USAGE EXAMPLES:\n *\n * Traditional URL Navigation:\n * @navigate('/dashboard')                              // Basic navigation\n * @navigate('/users', 'main')                         // Navigation with key\n * @navigate('/contacts?search=john', 'filters')       // URL with query params\n *\n * JSON Query Navigation (NEW):\n * @navigate({search: 'john', page: 1}, 'filters')                    // JSON queries\n * @navigate({search: 'john', page: 1}, 'filters', {merge: true})     // JSON with merge\n * @navigate({}, 'clear')                                             // Clear all queries\n *\n * Advanced Options:\n * @navigate('/users', 'main', {merge: false})                       // Explicit no merge\n * @navigate('/users', 'main', {only: ['search', 'category']})       // Only preserve specific\n * @navigate('/users', 'main', {except: ['page']})                   // Preserve except specific\n * @navigate('/users', 'main', {replace: true})                      // Replace instead of push\n *\n * Mixed Usage:\n * @navigate('/contacts', 'main', {queries: {search: $searchTerm}, merge: true})\n */\nexport const NavigateAction: ActionPlugin = {\n    type: \"action\",\n    name: \"navigate\",\n    fn: (\n        ctx: RuntimeContext,\n        urlOrQueries: string | Record<string, any>,\n        key: string = \"true\",\n        options: NavigateOptions = {}\n    ): void => {\n        // Input validation\n        if (!urlOrQueries) {\n            throw ctx.runtimeErr(\"NavigateUrlRequired\", {\n                received: String(urlOrQueries),\n            });\n        }\n\n        if (typeof key !== \"string\") {\n            throw ctx.runtimeErr(\"NavigateKeyMustBeString\", {\n                received: String(key),\n            });\n        }\n\n        try {\n            // Process the URL based on input type\n            const finalUrl = processNavigationInput(urlOrQueries, options);\n\n            // Ensure hyperNavigate is available\n            if (typeof (window as any).hyperNavigate !== \"function\") {\n                console.error(\n                    \"hyperNavigate is not available. Ensure GlobalNavigate watcher is loaded.\"\n                );\n                window.location.href = finalUrl;\n                return;\n            }\n\n            // Execute navigation\n            (window as any).hyperNavigate(finalUrl, key);\n\n            // Handle browser history if specified\n            if (options.replace) {\n                setTimeout(() => {\n                    history.replaceState(null, \"\", finalUrl);\n                }, 0);\n            }\n        } catch (error) {\n            console.error(\"Navigate action failed:\", error);\n\n            // Fallback to standard navigation\n            const fallbackUrl =\n                typeof urlOrQueries === \"string\"\n                    ? urlOrQueries\n                    : `${window.location.pathname}?${buildQueryString(\n                          urlOrQueries\n                      )}`;\n            window.location.href = fallbackUrl;\n        }\n    },\n};\n\n/**\n * Navigation options interface - matches both frontend and backend\n */\ninterface NavigateOptions {\n    merge?: boolean; // Whether to merge with existing query parameters\n    only?: string[]; // Only preserve these query parameters\n    except?: string[]; // Preserve all query parameters except these\n    replace?: boolean; // Use replaceState instead of pushState\n    queries?: Record<string, any>; // Additional queries to merge (when urlOrQueries is a path)\n}\n\n/**\n * Process navigation input based on type and options\n */\nfunction processNavigationInput(\n    urlOrQueries: string | Record<string, any>,\n    options: NavigateOptions\n): string {\n    if (typeof urlOrQueries === \"string\") {\n        // Traditional string URL\n        return processStringUrl(urlOrQueries, options);\n    } else {\n        // JSON query object\n        return processJsonQueries(urlOrQueries, options);\n    }\n}\n\n/**\n * Process traditional string URL with options\n */\nfunction processStringUrl(url: string, options: NavigateOptions): string {\n    // Handle additional queries option\n    if (options.queries && Object.keys(options.queries).length > 0) {\n        url = mergeQueriesIntoUrl(url, options.queries);\n    }\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(url, options.only, options.except);\n    }\n\n    return url;\n}\n\n/**\n * Process JSON query object into URL\n */\nfunction processJsonQueries(\n    queries: Record<string, any>,\n    options: NavigateOptions\n): string {\n    // Build base URL from current location\n    const currentPath = window.location.pathname;\n    const queryString = buildQueryString(queries);\n\n    const baseUrl = queryString ? `${currentPath}?${queryString}` : currentPath;\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(baseUrl, options.only, options.except);\n    }\n\n    return baseUrl;\n}\n\n/**\n * Determine if merge logic should be applied\n */\nfunction shouldApplyMerge(options: NavigateOptions): boolean {\n    // Explicit merge setting takes precedence\n    if (options.merge !== undefined) {\n        return options.merge;\n    }\n\n    // Implied merge when using only/except\n    if (options.only || options.except) {\n        return true;\n    }\n\n    // Default: no merge (explicit behavior)\n    return false;\n}\n\n/**\n * Build query string from object, handling various value types\n */\nfunction buildQueryString(queries: Record<string, any>): string {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(queries)) {\n        if (value === null || value === undefined) {\n            // Skip null/undefined values\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            // Handle arrays (for multi-select, checkboxes, etc.)\n            value.forEach((item) => {\n                if (item !== null && item !== undefined && item !== \"\") {\n                    params.append(key, String(item));\n                }\n            });\n        } else if (value === \"\" || String(value).trim() === \"\") {\n            // Skip empty strings\n            continue;\n        } else {\n            // Handle primitive values\n            params.set(key, String(value));\n        }\n    }\n\n    return params.toString();\n}\n\n/**\n * Merge additional queries into existing URL\n */\nfunction mergeQueriesIntoUrl(\n    url: string,\n    additionalQueries: Record<string, any>\n): string {\n    try {\n        let targetUrl: URL;\n\n        if (url.startsWith(\"?\")) {\n            targetUrl = new URL(\n                `${window.location.pathname}${url}`,\n                window.location.origin\n            );\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n        } else {\n            targetUrl = new URL(url, window.location.origin);\n        }\n\n        // Add additional queries\n        for (const [key, value] of Object.entries(additionalQueries)) {\n            if (value === null || value === undefined || value === \"\") {\n                targetUrl.searchParams.delete(key);\n            } else if (Array.isArray(value)) {\n                targetUrl.searchParams.delete(key);\n                value.forEach((item) => {\n                    if (item !== null && item !== undefined && item !== \"\") {\n                        targetUrl.searchParams.append(key, String(item));\n                    }\n                });\n            } else {\n                targetUrl.searchParams.set(key, String(value));\n            }\n        }\n\n        return `${targetUrl.pathname}${targetUrl.search}`;\n    } catch (error) {\n        console.warn(\"Error merging queries into URL:\", error);\n        return url;\n    }\n}\n\n/**\n * Merge query parameters with current URL - consistent with attribute plugin\n */\nfunction mergeQueryParameters(\n    url: string,\n    only?: string[],\n    except?: string[]\n): string {\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL (same logic as attribute plugin)\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = only\n                ? only.includes(key)\n                : !except || !except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error merging query parameters:\", error);\n        return url;\n    }\n}\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Traditional string navigation\n * @navigate('/users')                                    // Clean navigation\n * @navigate('/users?active=true', 'main')               // With queries\n *\n * // JSON query navigation\n * @navigate({search: $searchTerm, page: 1})             // Pure queries\n * @navigate({category: 'work'}, 'filters')              // With key\n *\n * // Advanced options\n * @navigate('/users', 'main', {\n *   queries: {search: $searchTerm},\n *   merge: true,\n *   except: ['page']\n * })\n *\n * // Clear all queries\n * @navigate({})                                         // Clear everything\n * @navigate('/')                                        // Clean slate\n *\n * // Array handling\n * @navigate({tags: ['php', 'laravel'], status: 'active'})  // Multi-value params\n */\n","// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport {\n  DefaultElementPatchMode,\n  ElementPatchModeAfter,\n  ElementPatchModeAppend,\n  ElementPatchModeBefore,\n  ElementPatchModeInner,\n  ElementPatchModeOuter,\n  ElementPatchModePrepend,\n  ElementPatchModeRemove,\n  ElementPatchModeReplace,\n  EventTypePatchElements,\n} from '../../../engine/consts'\nimport { aliasify } from '../../../engine/engine'\nimport type { InitContext, WatcherPlugin } from '../../../engine/types'\nimport { kebab } from '../../../utils/text'\nimport { supportsViewTransitions } from '../../../utils/view-transitions'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchElements: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchElements,\n  async onGlobalInit(ctx) {\n    datastarSSEEventWatcher(EventTypePatchElements, (args) => {\n      if (\n        supportsViewTransitions &&\n        args.useViewTransition?.trim() === 'true'\n      ) {\n        document.startViewTransition(() => onPatchElements(ctx, args))\n      } else {\n        onPatchElements(ctx, args)\n      }\n    })\n  },\n}\n\nfunction onPatchElements(\n  ctx: InitContext,\n  {\n    elements = '',\n    selector,\n    mode = DefaultElementPatchMode,\n  }: Record<string, string>,\n) {\n  const { initErr } = ctx\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${elements}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (\n    !selector &&\n    (mode === ElementPatchModeOuter || mode === ElementPatchModeReplace)\n  ) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.error(\n            initErr('NoTargetsFound', {\n              id: child.id,\n            }),\n          )\n          continue\n        }\n      }\n\n      applyToTargets(ctx, mode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.error(\n        initErr('NoTargetsFound', {\n          selector: selector,\n        }),\n      )\n      return\n    }\n\n    applyToTargets(ctx, mode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nfunction execute(target: Element): void {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nfunction applyToTargets(\n  { initErr }: InitContext,\n  mode: string,\n  element: DocumentFragment | Element,\n  capturedTargets: Iterable<Element>,\n) {\n  for (const target of capturedTargets) {\n    const cloned = element.cloneNode(true) as Element\n    if (mode === ElementPatchModeRemove) {\n      target.remove()\n    } else if (\n      mode === ElementPatchModeOuter ||\n      mode === ElementPatchModeInner\n    ) {\n      morph(target, cloned, mode)\n      execute(target)\n    } else {\n      execute(cloned)\n      if (mode === ElementPatchModeReplace) {\n        target.replaceWith(cloned)\n      } else if (mode === ElementPatchModePrepend) {\n        target.prepend(cloned)\n      } else if (mode === ElementPatchModeAppend) {\n        target.append(cloned)\n      } else if (mode === ElementPatchModeBefore) {\n        target.before(cloned)\n      } else if (mode === ElementPatchModeAfter) {\n        target.after(cloned)\n      } else {\n        throw initErr('InvalidPatchMode', { mode })\n      }\n    }\n  }\n}\n\nconst oldIdTagNameMap = new Map<string, string>()\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nfunction morph(\n  oldElt: Element,\n  newContent: DocumentFragment | Element,\n  mode: typeof ElementPatchModeInner | typeof ElementPatchModeOuter,\n): void {\n  const ignore = aliasify('ignore-morph')\n  if (\n    (oldElt.hasAttribute(ignore) &&\n      newContent instanceof HTMLElement &&\n      newContent.hasAttribute(ignore)) ||\n    oldElt.parentElement?.closest(`[${ignore}]`)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  oldIdTagNameMap.clear()\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  duplicateIds.clear()\n\n  // Computes a map of nodes to all IDs contained within that node (inclusive of the node).\n  // This map can be used to ask if two nodes have intersecting sets of IDs,\n  // which allows for a looser definition of \"matching\" than traditional ID matching,\n  // and allows child nodes to contribute to a parent nodes matching.\n  // const idMap = new Map<Node, Set<string>>()\n  ctxIdMap.clear()\n\n  populateIdMapWithTree(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    oldIdElements,\n  )\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    mode === 'outer' ? oldElt.parentElement! : oldElt,\n    normalizedElt,\n    mode === 'outer' ? (oldElt as Node) : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nfunction morphChildren(\n  oldParent: Element, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // @ts-ignore\n    const ncId = newChild.id\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(ncId)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n\n      const movedChild = window[ncId] as unknown as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(ncId)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nfunction findBestMatch(\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null {\n  let bestMatch = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we haven’t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    // if the current node contains active element, stop looking for better future matches,\n    // because if one is found, this node will be moved to the pantry, re-parenting it and thus losing focus\n    if (cursor.contains(document.activeElement)) break\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\nfunction isSoftMatch(oldNode: Node, newNode: Node): boolean {\n  // ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\n  const oldId = (oldNode as Element).id\n  return (\n    oldNode.nodeType === newNode.nodeType &&\n    (oldNode as Element).tagName === (newNode as Element).tagName &&\n    // If oldElt has an `id` with possible state and it doesn’t match newElt.id then avoid morphing.\n    // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n    // its not persistent, and new nodes can't have any hidden state.\n    (!oldId || oldId === (newNode as Element).id)\n  )\n}\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nfunction removeNode(node: Node) {\n  // are we going to id set match this later?\n  if (ctxIdMap.has(node)) {\n    // skip callbacks and move to pantry\n    moveBefore(ctxPantry, node, null)\n  } else {\n    // remove for realsies\n    node.parentNode?.removeChild(node)\n  }\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-ignore\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nfunction morphNode(\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node {\n  // syncs the oldNode to the newNode, copying over all attributes and\n  // inner element state from the newNode to the oldNode\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const ignore = aliasify('ignore-morph')\n    if (\n      (oldNode as Element).hasAttribute(ignore) &&\n      (newNode as Element).hasAttribute(ignore)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldNode instanceof HTMLInputElement &&\n      newNode instanceof HTMLInputElement &&\n      newNode.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newNode.getAttribute('value') !== oldNode.getAttribute('value')) {\n        oldNode.value = newNode.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldNode instanceof HTMLTextAreaElement &&\n      newNode instanceof HTMLTextAreaElement\n    ) {\n      const newValue = newNode.value\n      if (newValue !== oldNode.value) {\n        oldNode.value = newValue\n      }\n      if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n        oldNode.firstChild.nodeValue = newValue\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasify('preserve-attr')) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of (newNode as Element).attributes) {\n      if (\n        (oldNode as Element).getAttribute(name) !== value &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).setAttribute(name, value)\n      }\n    }\n\n    const oldAttrs = (oldNode as Element).attributes\n    for (let i = oldAttrs.length - 1; i >= 0; i--) {\n      const { name } = oldAttrs[i]\n      if (\n        !(newNode as Element).hasAttribute(name) &&\n        !preserveAttrs.includes(kebab(name))\n      ) {\n        ;(oldNode as Element).removeAttribute(name)\n      }\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  if (!oldNode.isEqualNode(newNode)) {\n    morphChildren(oldNode as Element, newNode as Element)\n  }\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nfunction populateIdMapWithTree(\n  root: Element | null,\n  elements: Element[] | NodeListOf<Element>,\n) {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesn’t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n","// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport {\n  DefaultPatchSignalsOnlyIfMissing,\n  EventTypePatchSignals,\n} from '../../../engine/consts'\nimport type { WatcherPlugin } from '../../../engine/types'\nimport { isBoolString, jsStrToObject } from '../../../utils/text'\nimport { datastarSSEEventWatcher } from '../shared'\n\nexport const PatchSignals: WatcherPlugin = {\n  type: 'watcher',\n  name: EventTypePatchSignals,\n  onGlobalInit: (ctx) =>\n    datastarSSEEventWatcher(\n      EventTypePatchSignals,\n      ({\n        signals: raw = '{}',\n        onlyIfMissing: onlyIfMissingRaw = `${DefaultPatchSignalsOnlyIfMissing}`,\n      }) =>\n        ctx.mergePatch(jsStrToObject(raw), {\n          ifMissing: isBoolString(onlyIfMissingRaw),\n        }),\n    ),\n}\n","// hyper-front/src/hyper-ext/plugins/backend/watchers/popstateHandler.ts\n// Icon: material-symbols:history\n// Slug: Handles browser back/forward navigation intelligently.\n// Description: Smart popstate handler that respects navigation state and opt-in behavior.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\n// Global flag OUTSIDE the function - proper scope!\nlet popstateInitialized = false;\n\nexport const PopstateHandler: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"popstateHandler\",\n    onGlobalInit: () => {\n        // Only initialize once globally\n        if (!popstateInitialized) {\n            popstateInitialized = true;\n\n            window.addEventListener(\"popstate\", function (event) {\n                // Check if we have any elements with data-navigate on the page\n                const hasNavigateElements =\n                    document.querySelector(\"[data-navigate]\");\n\n                // If no navigation elements exist, just reload (original behavior)\n                if (!hasNavigateElements) {\n                    window.location.reload();\n                    return;\n                }\n\n                // If we have navigation elements, try reactive navigation\n                // Check if hyperNavigate is available (it should be via GlobalNavigate watcher)\n                if (typeof (window as any).hyperNavigate === \"function\") {\n                    // Determine appropriate navigation key based on state or default\n                    const navigationKey =\n                        event.state?.navigationKey || \"popstate\";\n                    (window as any).hyperNavigate(\n                        window.location.href,\n                        navigationKey\n                    );\n                } else {\n                    // Fallback to reload if hyperNavigate isn't available yet\n                    window.location.reload();\n                }\n            });\n        }\n    },\n};\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/globalNavigate.ts\n// Icon: material-symbols:public\n// Slug: Enhanced global navigation with comprehensive options support.\n// Description: Provides consistent navigation API across all frontend/backend interactions.\n\nimport type { WatcherPlugin } from \"../../../../datastar/engine/types\";\n\n// Global flag to ensure this runs only once\nlet globalNavigateSetup = false;\n\nexport const GlobalNavigate: WatcherPlugin = {\n    type: \"watcher\",\n    name: \"globalNavigate\",\n    onGlobalInit: (ctx) => {\n        // Only initialize once globally\n        if (!globalNavigateSetup) {\n            globalNavigateSetup = true;\n            setupEnhancedGlobalNavigation(ctx);\n        }\n    },\n};\n\n/**\n * Navigation options interface - matches backend exactly\n */\ninterface NavigationOptions {\n    merge?: boolean; // Whether to merge with existing query parameters\n    only?: string[]; // Only preserve these query parameters\n    except?: string[]; // Preserve all query parameters except these\n    replace?: boolean; // Use replaceState instead of pushState\n}\n\n/**\n * Set up enhanced global navigation functions with comprehensive options support\n *\n * Provides perfect consistency between:\n * - Frontend: data-navigate, @navigate()\n * - Backend: hyper()->navigate(), hyper()->navigateWith(), etc.\n */\nfunction setupEnhancedGlobalNavigation(ctx: any) {\n    const { actions, startBatch, endBatch } = ctx;\n\n    /**\n     * Enhanced navigation with comprehensive options support\n     *\n     * @param url Target URL or query object\n     * @param key Navigation key for Datastar routing\n     * @param options Navigation options (merge, only, except, replace)\n     */\n    const navigateWithOptions = (\n        url: string,\n        key: string = \"true\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            startBatch();\n\n            // Get the GET action from Datastar's action registry\n            const getAction = actions.get || actions.GET;\n\n            if (!getAction) {\n                throw new Error(\n                    \"GET action not found in Datastar actions registry\"\n                );\n            }\n\n            // Prepare fetch arguments with navigate headers\n            const fetchArgs = {\n                headers: {\n                    \"HYPER-NAVIGATE\": \"true\",\n                    \"HYPER-NAVIGATE-KEY\": key,\n                },\n            };\n\n            // Create proper runtime context\n            const runtimeCtx = {\n                ...ctx,\n                el: document.body,\n            };\n\n            // Call GET action using Datastar's infrastructure\n            getAction.fn(runtimeCtx, url, fetchArgs);\n\n            // Handle browser history\n            setTimeout(() => {\n                if (options.replace) {\n                    history.replaceState(null, \"\", url);\n                } else {\n                    history.pushState(null, \"\", url);\n                }\n            }, 0);\n        } catch (error) {\n            console.error(\"Enhanced navigate failed:\", error);\n            // Fallback to normal navigation\n            window.location.href = url;\n        } finally {\n            endBatch();\n        }\n    };\n\n    /**\n     * BASIC NAVIGATION FUNCTIONS\n     */\n\n    // Basic hyperNavigate - backward compatible\n    (window as any).hyperNavigate = (url: string, key: string = \"true\") => {\n        navigateWithOptions(url, key, {});\n    };\n\n    // Enhanced navigation with options - used by backend\n    (window as any).hyperNavigateWithOptions = navigateWithOptions;\n\n    /**\n     * SPECIALIZED NAVIGATION FUNCTIONS\n     */\n\n    // Navigate with explicit merge behavior\n    (window as any).hyperNavigateWith = (\n        url: string,\n        key: string = \"true\",\n        merge: boolean = false,\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge });\n    };\n\n    // Navigate and merge with current parameters\n    (window as any).hyperNavigateMerge = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge: true });\n    };\n\n    // Navigate with clean slate (no merging)\n    (window as any).hyperNavigateClean = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, merge: false });\n    };\n\n    // Navigate preserving only specific parameters\n    (window as any).hyperNavigateOnly = (\n        url: string,\n        only: string[],\n        key: string = \"true\"\n    ) => {\n        navigateWithOptions(url, key, { merge: true, only });\n    };\n\n    // Navigate preserving all except specific parameters\n    (window as any).hyperNavigateExcept = (\n        url: string,\n        except: string[],\n        key: string = \"true\"\n    ) => {\n        navigateWithOptions(url, key, { merge: true, except });\n    };\n\n    // Navigate using replaceState\n    (window as any).hyperNavigateReplace = (\n        url: string,\n        key: string = \"true\",\n        options: Partial<NavigationOptions> = {}\n    ) => {\n        navigateWithOptions(url, key, { ...options, replace: true });\n    };\n\n    /**\n     * ENHANCED BACK/REFRESH FUNCTIONS\n     */\n\n    // Enhanced hyperBack with options support\n    (window as any).hyperBackWithOptions = (\n        fallbackUrl: string = \"/\",\n        key: string = \"back\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            let backUrl = fallbackUrl;\n\n            // Try to get the previous URL from browser history\n            if (\n                document.referrer &&\n                document.referrer !== window.location.href\n            ) {\n                const referrerUrl = new URL(document.referrer);\n                const currentUrl = new URL(window.location.href);\n\n                // Only use referrer if it's from the same origin\n                if (referrerUrl.origin === currentUrl.origin) {\n                    backUrl = document.referrer;\n                }\n            }\n\n            // Navigate reactively with the specified options\n            navigateWithOptions(backUrl, key, options);\n        } catch (error) {\n            console.error(\"Enhanced hyperBack failed:\", error);\n            // Fallback to simple history.back()\n            if (history.length > 1) {\n                history.back();\n            } else {\n                window.location.href = fallbackUrl;\n            }\n        }\n    };\n\n    // Enhanced hyperRefresh with options support\n    (window as any).hyperRefreshWithOptions = (\n        key: string = \"refresh\",\n        options: NavigationOptions = {}\n    ) => {\n        try {\n            const currentUrl = window.location.href;\n            navigateWithOptions(currentUrl, key, options);\n        } catch (error) {\n            console.error(\"Enhanced hyperRefresh failed:\", error);\n            // Fallback to regular refresh\n            window.location.reload();\n        }\n    };\n\n    /**\n     * CONVENIENCE FUNCTIONS\n     */\n\n    // Update current page queries\n    (window as any).hyperUpdateQueries = (\n        queries: Record<string, any>,\n        key: string = \"update\",\n        merge: boolean = true\n    ) => {\n        const currentPath = window.location.pathname;\n        const queryString = buildQueryString(queries);\n        const url = queryString ? `${currentPath}?${queryString}` : currentPath;\n\n        navigateWithOptions(url, key, { merge });\n    };\n\n    // Clear specific query parameters\n    (window as any).hyperClearQueries = (\n        paramNames: string[],\n        key: string = \"clear\"\n    ) => {\n        const clearQueries = paramNames.reduce((acc, name) => {\n            acc[name] = null;\n            return acc;\n        }, {} as Record<string, null>);\n\n        (window as any).hyperUpdateQueries(clearQueries, key, true);\n    };\n\n    // Reset pagination while preserving filters\n    (window as any).hyperResetPagination = (key: string = \"pagination\") => {\n        (window as any).hyperUpdateQueries({ page: 1 }, key, true);\n    };\n\n    /**\n     * BACKWARD COMPATIBILITY FUNCTIONS\n     */\n\n    // Backward compatible hyperBack (without options)\n    (window as any).hyperBack = (\n        fallbackUrl: string = \"/\",\n        key: string = \"back\"\n    ) => {\n        (window as any).hyperBackWithOptions(fallbackUrl, key, { merge: true });\n    };\n\n    // Backward compatible hyperRefresh (without options)\n    (window as any).hyperRefresh = (key: string = \"refresh\") => {\n        (window as any).hyperRefreshWithOptions(key, { merge: true });\n    };\n\n    // Simple reload function for hard refreshes\n    (window as any).hyperReload = () => {\n        window.location.reload();\n    };\n\n    /**\n     * DEBUGGING HELPERS\n     */\n\n    // Log current navigation state\n    (window as any).hyperDebugNavigation = () => {\n        console.group(\"🧭 Hyper Navigation Debug\");\n        console.log(\"Current URL:\", window.location.href);\n        console.log(\"Current Path:\", window.location.pathname);\n        console.log(\"Current Query:\", window.location.search);\n        console.log(\n            \"Current Queries:\",\n            Object.fromEntries(new URLSearchParams(window.location.search))\n        );\n        console.log(\"Referrer:\", document.referrer);\n        console.log(\"History Length:\", history.length);\n        console.groupEnd();\n    };\n}\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Build query string from object, handling various value types\n */\nfunction buildQueryString(queries: Record<string, any>): string {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(queries)) {\n        if (value === null || value === undefined) {\n            // Skip null/undefined values - they clear parameters\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            // Handle arrays (for multi-select, checkboxes, etc.)\n            value.forEach((item) => {\n                if (item !== null && item !== undefined && item !== \"\") {\n                    params.append(key, String(item));\n                }\n            });\n        } else if (value === \"\" || String(value).trim() === \"\") {\n            // Skip empty strings\n            continue;\n        } else {\n            // Handle primitive values\n            params.set(key, String(value));\n        }\n    }\n\n    return params.toString();\n}\n\n/**\n * EXPOSED API SUMMARY\n *\n * Basic Navigation:\n * - hyperNavigate(url, key?)\n * - hyperNavigateWithOptions(url, key?, options?)\n *\n * Explicit Control:\n * - hyperNavigateWith(url, key?, merge?, options?)\n * - hyperNavigateMerge(url, key?, options?)\n * - hyperNavigateClean(url, key?, options?)\n * - hyperNavigateOnly(url, only[], key?)\n * - hyperNavigateExcept(url, except[], key?)\n * - hyperNavigateReplace(url, key?, options?)\n *\n * Enhanced Back/Refresh:\n * - hyperBackWithOptions(fallback?, key?, options?)\n * - hyperRefreshWithOptions(key?, options?)\n *\n * Convenience:\n * - hyperUpdateQueries(queries{}, key?, merge?)\n * - hyperClearQueries(names[], key?)\n * - hyperResetPagination(key?)\n *\n * Utilities:\n * - hyperReload()\n * - hyperDebugNavigation()\n *\n * Backward Compatible:\n * - hyperBack(fallback?, key?)\n * - hyperRefresh(key?)\n */\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/attributes/navigate.ts\n// Icon: material-symbols:navigation\n// Slug: Enhanced reactive navigation with Datastar-standard modifiers.\n// Description: Professional navigation with explicit merge control and standard modifier support.\n\nimport type { AttributePlugin } from \"../../../datastar/engine/types\";\n\n/**\n * Enhanced Navigate Attribute - Professional Navigation System\n *\n * Follows Datastar modifier conventions for explicit, predictable navigation.\n * No more \"smart defaults\" - developers control exactly what happens.\n *\n * MODIFIER EXAMPLES:\n * data-navigate=\"true\"                                    // Basic navigation (no merge)\n * data-navigate__key.sidebar=\"true\"                       // Navigation with key\n * data-navigate__merge=\"true\"                            // Explicit merge behavior\n * data-navigate__merge__key.main=\"true\"                  // Merge with key\n * data-navigate__only.search,category=\"true\"             // Only preserve specific params\n * data-navigate__except.page=\"true\"                      // Preserve all except specific\n * data-navigate__replace=\"true\"                          // Replace instead of push history\n * data-navigate__debounce.300ms=\"true\"                   // Debounce navigation\n *\n * COMPLEX EXAMPLES:\n * data-navigate__merge__except.page__debounce.500ms=\"true\"    // Comprehensive control\n * data-navigate__key.filters__only.search,category=\"true\"     // Granular parameter control\n */\nexport const Navigate: AttributePlugin = {\n    type: \"attribute\",\n    name: \"navigate\",\n    keyReq: \"denied\",\n    valReq: \"must\",\n    shouldEvaluate: false,\n    onLoad: (ctx) => {\n        const { el, value, mods, runtimeErr } = ctx;\n\n        // Parse navigation configuration from modifiers\n        const navigateConfig = parseNavigateModifiers(mods, value.trim());\n\n        if (!navigateConfig) {\n            throw runtimeErr(\"InvalidNavigateConfiguration\", {\n                value,\n                modifiers: Array.from(mods.keys()),\n            });\n        }\n\n        // Create timing wrapper if specified\n        const executeNavigation = navigateConfig.timing\n            ? createTimingWrapper(handleNavigation, navigateConfig.timing)\n            : handleNavigation;\n\n        // Create click handler\n        const handleClick = (event: Event) => {\n            const target = event.target as HTMLElement;\n            const link = target.closest(\"a[href]\") as HTMLAnchorElement;\n\n            if (!link || !shouldInterceptNavigation(link)) {\n                return;\n            }\n\n            event.preventDefault();\n            executeNavigation(link.href, navigateConfig);\n        };\n\n        // Create form submit handler for GET forms\n        const handleSubmit = (event: Event) => {\n            const form = event.target as HTMLFormElement;\n\n            if (!shouldInterceptFormSubmit(form)) {\n                return;\n            }\n\n            event.preventDefault();\n\n            const formData = new FormData(form);\n            const url = new URL(form.action, window.location.href);\n\n            // Add form data to URL params\n            for (const [key, value] of formData.entries()) {\n                if (typeof value === \"string\") {\n                    url.searchParams.set(key, value);\n                }\n            }\n\n            executeNavigation(url.toString(), navigateConfig);\n        };\n\n        // Attach event listeners\n        el.addEventListener(\"click\", handleClick);\n        el.addEventListener(\"submit\", handleSubmit);\n\n        return () => {\n            el.removeEventListener(\"click\", handleClick);\n            el.removeEventListener(\"submit\", handleSubmit);\n        };\n    },\n};\n\n/**\n * Navigation configuration interface\n */\ninterface NavigateConfig {\n    key: string;\n    merge: boolean;\n    only?: string[];\n    except?: string[];\n    replace?: boolean;\n    timing?: TimingConfig;\n}\n\ninterface TimingConfig {\n    type: \"debounce\" | \"throttle\" | \"delay\";\n    duration: number;\n    leading?: boolean;\n}\n\n/**\n * Parse Datastar modifiers into navigation configuration\n *\n * SUPPORTED MODIFIERS:\n * - __key.{keyname} → Sets navigation key\n * - __merge → Enable query parameter merging\n * - __only.{param1,param2} → Only preserve specific parameters\n * - __except.{param1,param2} → Preserve all except specific parameters\n * - __replace → Use replaceState instead of pushState\n * - __debounce.{duration}ms → Debounce navigation\n * - __throttle.{duration}ms → Throttle navigation\n * - __delay.{duration}ms → Simple delay\n */\nfunction parseNavigateModifiers(\n    mods: Map<string, Set<string>>,\n    value: string\n): NavigateConfig | null {\n    if (!value || value.trim() === \"\") {\n        return null;\n    }\n\n    const config: NavigateConfig = {\n        key: \"true\", // Default key\n        merge: false, // EXPLICIT: No more smart defaults!\n        replace: false,\n    };\n\n    // Parse modifiers\n    for (const [modName, modTags] of mods) {\n        switch (modName) {\n            case \"key\":\n                // __key.sidebar → key = \"sidebar\"\n                config.key = modTags.size > 0 ? Array.from(modTags)[0] : \"true\";\n                break;\n\n            case \"merge\":\n                // __merge → merge = true\n                config.merge = true;\n                break;\n\n            case \"only\":\n                // __only.search,category → only = [\"search\", \"category\"]\n                config.only = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"except\":\n                // __except.page → except = [\"page\"]\n                config.except = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"replace\":\n                // __replace → replace = true\n                config.replace = true;\n                break;\n\n            case \"debounce\":\n                // __debounce.300ms → debounce for 300ms\n                config.timing = parseTimingModifier(\"debounce\", modTags);\n                break;\n\n            case \"throttle\":\n                // __throttle.500ms → throttle for 500ms\n                config.timing = parseTimingModifier(\"throttle\", modTags);\n                break;\n\n            case \"delay\":\n                // __delay.1s → simple delay for 1s\n                config.timing = parseTimingModifier(\"delay\", modTags);\n                break;\n        }\n    }\n\n    // Validation: cannot use both only and except\n    if (config.only && config.except) {\n        console.warn(\n            \"Navigate: Cannot use both __only and __except modifiers. Using __only.\"\n        );\n        delete config.except;\n    }\n\n    return config;\n}\n\n/**\n * Parse timing modifier tags into timing configuration\n */\nfunction parseTimingModifier(\n    type: \"debounce\" | \"throttle\" | \"delay\",\n    tags: Set<string>\n): TimingConfig | undefined {\n    const tagArray = Array.from(tags);\n\n    // Find duration tag (e.g., \"300ms\", \"1s\", \"1000\")\n    const durationTag = tagArray.find((tag) => /^\\d+(?:ms|s)?$/.test(tag));\n    if (!durationTag) {\n        console.warn(\n            `Navigate: Invalid ${type} timing - no duration specified`\n        );\n        return undefined;\n    }\n\n    // Parse duration\n    let duration: number;\n    if (durationTag.endsWith(\"ms\")) {\n        duration = parseInt(durationTag.slice(0, -2));\n    } else if (durationTag.endsWith(\"s\")) {\n        duration = parseInt(durationTag.slice(0, -1)) * 1000;\n    } else {\n        duration = parseInt(durationTag); // Assume milliseconds\n    }\n\n    return {\n        type,\n        duration,\n        leading: tagArray.includes(\"leading\"),\n    };\n}\n\n/**\n * Create timing wrapper for navigation function\n */\nfunction createTimingWrapper(\n    fn: (url: string, config: NavigateConfig) => void,\n    timing: TimingConfig\n): (url: string, config: NavigateConfig) => void {\n    switch (timing.type) {\n        case \"debounce\":\n            return createDebounce(fn, timing.duration, timing.leading);\n\n        case \"throttle\":\n            return createThrottle(fn, timing.duration, timing.leading);\n\n        case \"delay\":\n            return createDelay(fn, timing.duration);\n\n        default:\n            return fn;\n    }\n}\n\n/**\n * Simple debounce implementation\n */\nfunction createDebounce<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number,\n    leading?: boolean\n): T {\n    let timeout: ReturnType<typeof setTimeout> | undefined;\n    let hasRun = false;\n\n    return ((...args: Parameters<T>) => {\n        const callNow = leading && !hasRun;\n\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            hasRun = false;\n            if (!leading) fn(...args);\n        }, delay);\n\n        if (callNow) {\n            hasRun = true;\n            fn(...args);\n        }\n    }) as T;\n}\n\n/**\n * Simple throttle implementation\n */\nfunction createThrottle<T extends (...args: any[]) => void>(\n    fn: T,\n    limit: number,\n    leading?: boolean\n): T {\n    let inThrottle = false;\n    let lastArgs: Parameters<T> | null = null;\n\n    return ((...args: Parameters<T>) => {\n        if (!inThrottle) {\n            if (leading !== false) {\n                fn(...args);\n            }\n            inThrottle = true;\n\n            setTimeout(() => {\n                inThrottle = false;\n                if (lastArgs && leading === false) {\n                    fn(...lastArgs);\n                    lastArgs = null;\n                }\n            }, limit);\n        } else {\n            lastArgs = args;\n        }\n    }) as T;\n}\n\n/**\n * Simple delay implementation\n */\nfunction createDelay<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number\n): T {\n    return ((...args: Parameters<T>) => {\n        setTimeout(() => fn(...args), delay);\n    }) as T;\n}\n\n/**\n * Handle navigation with configuration\n */\nfunction handleNavigation(url: string, config: NavigateConfig): void {\n    try {\n        // Process URL with merge configuration\n        const finalUrl = processUrlWithMergeConfig(url, config);\n\n        // Ensure hyperNavigate is available\n        if (typeof (window as any).hyperNavigate !== \"function\") {\n            console.error(\n                \"hyperNavigate not available. Falling back to standard navigation.\"\n            );\n            window.location.href = finalUrl;\n            return;\n        }\n\n        // Use global hyperNavigate\n        (window as any).hyperNavigate(finalUrl, config.key);\n\n        // Handle browser history\n        if (config.replace) {\n            history.replaceState(null, \"\", finalUrl);\n        } else {\n            // hyperNavigate already handles pushState, but we ensure consistency\n            setTimeout(() => {\n                if (window.location.href !== finalUrl) {\n                    history.pushState(null, \"\", finalUrl);\n                }\n            }, 0);\n        }\n    } catch (error) {\n        console.error(\"Navigation failed:\", error);\n        window.location.href = url;\n    }\n}\n\n/**\n * Process URL with merge configuration - EXPLICIT and PREDICTABLE\n */\nfunction processUrlWithMergeConfig(\n    url: string,\n    config: NavigateConfig\n): string {\n    // If no merging, return URL as-is\n    if (!config.merge) {\n        return url;\n    }\n\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = config.only\n                ? config.only.includes(key)\n                : !config.except || !config.except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                // Remove empty parameters\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error processing URL merge:\", error);\n        return url;\n    }\n}\n\n/**\n * Determine if we should intercept navigation for this link\n */\nfunction shouldInterceptNavigation(link: HTMLAnchorElement): boolean {\n    // Skip external links\n    try {\n        const url = new URL(link.href, window.location.href);\n        if (url.origin !== window.location.origin) {\n            return false;\n        }\n    } catch {\n        return false;\n    }\n\n    // Skip download links\n    if (link.hasAttribute(\"download\")) {\n        return false;\n    }\n\n    // Skip explicitly opted-out links\n    if (link.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Determine if we should intercept form submission\n */\nfunction shouldInterceptFormSubmit(form: HTMLFormElement): boolean {\n    // Only handle GET forms\n    if (form.method.toLowerCase() !== \"get\") {\n        return false;\n    }\n\n    // Skip explicitly opted-out forms\n    if (form.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n","import { ResponseInterceptor } from \"../plugins/backend/watchers/responseInterceptor\";\nimport { apply, load, setAlias } from \"../../datastar/engine\";\n\n// Import all your plugins...\nimport { Peek } from \"../../datastar/plugins/actions/peek\";\nimport { SetAll } from \"../../datastar/plugins/actions/setAll\";\nimport { ToggleAll } from \"../../datastar/plugins/actions/toggleAll\";\nimport { Dispatch } from \"../plugins/actions/dispatch\";\nimport { FileUrl } from \"../plugins/actions/fileUrl\";\nimport { Attr } from \"../../datastar/plugins/attributes/attr\";\nimport { Bind } from \"../../datastar/plugins/attributes/bind\";\nimport { Class } from \"../../datastar/plugins/attributes/class\";\nimport { Computed } from \"../../datastar/plugins/attributes/computed\";\nimport { Effect } from \"../../datastar/plugins/attributes/effect\";\nimport { Indicator } from \"../../datastar/plugins/attributes/indicator\";\nimport { JsonSignals } from \"../../datastar/plugins/attributes/jsonSignals\";\nimport { On } from \"../../datastar/plugins/attributes/on\";\nimport { OnIntersect } from \"../../datastar/plugins/attributes/onIntersect\";\nimport { OnInterval } from \"../../datastar/plugins/attributes/onInterval\";\nimport { OnLoad } from \"../../datastar/plugins/attributes/onLoad\";\nimport { OnSignalPatch } from \"../../datastar/plugins/attributes/onSignalPatch\";\nimport { Ref } from \"../../datastar/plugins/attributes/ref\";\nimport { Show } from \"../../datastar/plugins/attributes/show\";\nimport { Signals } from \"../../datastar/plugins/attributes/signals\";\nimport { Style } from \"../../datastar/plugins/attributes/style\";\nimport { Text } from \"../../datastar/plugins/attributes/text\";\nimport { Error } from \"../plugins/attributes/error\";\nimport { For } from \"../plugins/attributes/for\";\nimport { If } from \"../plugins/attributes/if\";\nimport { DELETE } from \"../../datastar/plugins/backend/actions/delete\";\nimport { GET } from \"../../datastar/plugins/backend/actions/get\";\nimport { PATCH } from \"../../datastar/plugins/backend/actions/patch\";\nimport { POST } from \"../../datastar/plugins/backend/actions/post\";\nimport { PUT } from \"../../datastar/plugins/backend/actions/put\";\nimport { POSTX } from \"../plugins/backend/actions/postx\";\nimport { PUTX } from \"../plugins/backend/actions/putx\";\nimport { PATCHX } from \"../plugins/backend/actions/patchx\";\nimport { DELETEX } from \"../plugins/backend/actions/deletex\";\nimport { NavigateAction } from \"../plugins/backend/actions/navigate\";\nimport { PatchElements } from \"../../datastar/plugins/backend/watchers/patchElements\";\nimport { PatchSignals } from \"../../datastar/plugins/backend/watchers/patchSignals\";\nimport { PopstateHandler } from \"../plugins/backend/watchers/popstateHandler\";\nimport { GlobalNavigate } from \"../plugins/backend/watchers/globalNavigate\";\nimport { Navigate } from \"../plugins/attributes/navigate\";\n\nload(\n    // Backend actions\n    GET,\n    POST,\n    PUT,\n    PATCH,\n    DELETE,\n    // Backend actions - Laravel with CSRF\n    POSTX,\n    PUTX,\n    PATCHX,\n    DELETEX,\n    NavigateAction,\n    // Backend watchers\n    ResponseInterceptor,\n    PatchElements,\n    PatchSignals,\n    PopstateHandler,\n    GlobalNavigate,\n\n    // Attributes\n    Attr,\n    Bind,\n    Class,\n    Computed,\n    Effect,\n    Error,\n    For,\n    If,\n    Indicator,\n    JsonSignals,\n    Navigate,\n    On,\n    OnIntersect,\n    OnInterval,\n    OnLoad,\n    OnSignalPatch,\n    Ref,\n    Show,\n    Signals,\n    Style,\n    Text,\n    // Actions\n    Dispatch,\n    Peek,\n    SetAll,\n    ToggleAll,\n    FileUrl\n);\n\napply();\n\nexport { apply, load, setAlias };\n"],"names":["url","scripts","effect","signal","link","path","DELETE","cleanup","root","peek","filtered","mergePatch","key","update","runtimeErr","getPath","el","type","value","syncSignal","computed","startBatch","endBatch","apply","Error","sourceData","evt","response","overrides","buildQueryString","initErr","actions","delay"],"mappings":"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"}