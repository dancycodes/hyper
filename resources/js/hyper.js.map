{"version":3,"file":"hyper.js","sources":["../src/datastar/engine/consts.ts","../src/datastar/utils/text.ts","../src/datastar/utils/polyfills.ts","../src/datastar/utils/paths.ts","../src/datastar/engine/signals.ts","../src/datastar/utils/dom.ts","../src/datastar/engine/engine.ts","../src/datastar/plugins/actions/peek.ts","../src/datastar/plugins/actions/setAll.ts","../src/datastar/plugins/actions/toggleAll.ts","../src/datastar/plugins/actions/fetch.ts","../src/datastar/plugins/attributes/attr.ts","../src/datastar/plugins/attributes/bind.ts","../src/datastar/plugins/attributes/class.ts","../src/datastar/plugins/attributes/computed.ts","../src/datastar/plugins/attributes/effect.ts","../src/datastar/plugins/attributes/indicator.ts","../src/datastar/plugins/attributes/jsonSignals.ts","../src/datastar/utils/tags.ts","../src/datastar/utils/timing.ts","../src/datastar/utils/view-transitions.ts","../src/datastar/plugins/attributes/on.ts","../src/datastar/plugins/attributes/onIntersect.ts","../src/datastar/plugins/attributes/onInterval.ts","../src/datastar/plugins/attributes/init.ts","../src/datastar/plugins/attributes/onSignalPatch.ts","../src/datastar/plugins/attributes/ref.ts","../src/datastar/plugins/attributes/show.ts","../src/datastar/plugins/attributes/signals.ts","../src/datastar/plugins/attributes/style.ts","../src/datastar/plugins/attributes/text.ts","../src/datastar/engine/morph.ts","../src/datastar/plugins/watchers/patchElements.ts","../src/datastar/plugins/watchers/patchSignals.ts","../src/hyper-ext/plugins/actions/dispatch.ts","../src/hyper-ext/plugins/actions/fileUrl.ts","../src/hyper-ext/plugins/actions/back.ts","../src/hyper-ext/plugins/actions/refresh.ts","../src/hyper-ext/plugins/actions/reload.ts","../src/hyper-ext/plugins/attributes/error.ts","../src/hyper-ext/plugins/attributes/for.ts","../src/hyper-ext/plugins/attributes/if.ts","../src/hyper-ext/plugins/attributes/navigate.ts","../src/hyper-ext/utils/csrf.ts","../src/hyper-ext/plugins/backend/actions/fetch-laravel.ts","../src/hyper-ext/plugins/backend/actions/postx.ts","../src/hyper-ext/plugins/backend/actions/putx.ts","../src/hyper-ext/plugins/backend/actions/patchx.ts","../src/hyper-ext/plugins/backend/actions/deletex.ts","../src/hyper-ext/plugins/backend/actions/navigate.ts","../src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts","../src/hyper-ext/plugins/backend/watchers/globalNavigate.ts","../src/hyper-ext/bundles/hyper.ts"],"sourcesContent":["const lol = /ðŸ–•JS_DSðŸš€/.source\nexport const DSP = lol.slice(0, 5)\nexport const DSS = lol.slice(4)\nexport const DATASTAR_FETCH_EVENT = 'datastar-fetch'\nexport const DATASTAR_SIGNAL_PATCH_EVENT = 'datastar-signal-patch'\n","import type { Modifiers } from '@engine/types'\n\nexport const kebab = (str: string): string =>\n  str\n    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n    .replace(/([a-z])([0-9]+)/gi, '$1-$2')\n    .replace(/([0-9]+)([a-z])/gi, '$1-$2')\n    .toLowerCase()\n\nexport const camel = (str: string): string =>\n  kebab(str).replace(/-./g, (x) => x[1].toUpperCase())\n\nexport const snake = (str: string): string => kebab(str).replace(/-/g, '_')\n\nexport const pascal = (str: string): string =>\n  camel(str).replace(/(^.|(?<=\\.).)/g, (x) => x[0].toUpperCase())\n\nexport const jsStrToObject = (raw: string) => {\n  try {\n    return JSON.parse(raw)\n  } catch {\n    // If JSON parsing fails, try to evaluate as a JavaScript object\n    // This is less safe and should be used with caution\n    return Function(`return (${raw})`)()\n  }\n}\n\nconst caseFns: Record<string, (s: string) => string> = {\n  camel: (str) => str.replace(/-[a-z]/g, (x) => x[1].toUpperCase()),\n  snake: (str) => str.replace(/-/g, '_'),\n  pascal: (str) => str[0].toUpperCase() + caseFns.camel(str.slice(1)),\n}\n\nexport const modifyCasing = (\n  str: string,\n  mods: Modifiers,\n  defaultCase = 'camel',\n): string => {\n  for (const c of mods.get('case') || [defaultCase]) {\n    str = caseFns[c]?.(str) || str\n  }\n  return str\n}\n\nexport const aliasify = (name: string) =>\n  ALIAS ? `data-${ALIAS}-${name}` : `data-${name}`\n","export const hasOwn: (obj: object, prop: PropertyKey) => boolean =\n  // @ts-expect-error\n  Object.hasOwn ?? Object.prototype.hasOwnProperty.call\n","import type { Paths } from '@engine/types'\nimport { hasOwn } from '@utils/polyfills'\n\nexport const isPojo = (obj: any): obj is Record<string, any> =>\n  obj !== null &&\n  typeof obj === 'object' &&\n  (Object.getPrototypeOf(obj) === Object.prototype ||\n    Object.getPrototypeOf(obj) === null)\n\nexport const isEmpty = (obj: Record<string, any>): boolean => {\n  for (const prop in obj) {\n    if (hasOwn(obj, prop)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const updateLeaves = (\n  obj: Record<string, any>,\n  fn: (oldValue: any) => any,\n) => {\n  for (const key in obj) {\n    const val = obj[key]\n    if (isPojo(val) || Array.isArray(val)) {\n      updateLeaves(val, fn)\n    } else {\n      obj[key] = fn(val)\n    }\n  }\n}\n\nexport const pathToObj = (paths: Paths): Record<string, any> => {\n  const result: Record<string, any> = {}\n  for (const [path, value] of paths) {\n    const keys = path.split('.')\n    const lastKey = keys.pop()!\n    const obj = keys.reduce((acc, key) => (acc[key] ??= {}), result)\n    obj[lastKey] = value\n  }\n  return result\n}\n","import { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport type {\n  Computed,\n  Effect,\n  JSONPatch,\n  MergePatchArgs,\n  Paths,\n  Signal,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { isPojo, pathToObj } from '@utils/paths'\nimport { hasOwn } from '@utils/polyfills'\n\ninterface ReactiveNode {\n  deps_?: Link\n  depsTail_?: Link\n  subs_?: Link\n  subsTail_?: Link\n  flags_: ReactiveFlags\n}\n\ninterface Link {\n  version_: number\n  dep_: ReactiveNode\n  sub_: ReactiveNode\n  prevSub_?: Link\n  nextSub_?: Link\n  prevDep_?: Link\n  nextDep_?: Link\n}\n\ninterface Stack<T> {\n  value_: T\n  prev_?: Stack<T>\n}\n\nenum ReactiveFlags {\n  None = 0,\n  Mutable = 1 << 0,\n  Watching = 1 << 1,\n  RecursedCheck = 1 << 2,\n  Recursed = 1 << 3,\n  Dirty = 1 << 4,\n  Pending = 1 << 5,\n}\n\nenum EffectFlags {\n  Queued = 1 << 6,\n}\n\ninterface AlienEffect extends ReactiveNode {\n  fn_(): void\n}\n\ninterface AlienComputed<T = unknown> extends ReactiveNode {\n  value_?: T\n  getter(previousValue?: T): T\n}\n\ninterface AlienSignal<T = unknown> extends ReactiveNode {\n  previousValue: T\n  value_: T\n}\n\nconst currentPatch: Paths = []\nconst queuedEffects: (AlienEffect | undefined)[] = []\nlet batchDepth = 0\nlet notifyIndex = 0\nlet queuedEffectsLength = 0\nlet prevSub: ReactiveNode | undefined\nlet activeSub: ReactiveNode | undefined\nlet version = 0\n\nexport const beginBatch = (): void => {\n  batchDepth++\n}\n\nexport const endBatch = (): void => {\n  if (!--batchDepth) {\n    flush()\n    dispatch()\n  }\n}\n\nexport const startPeeking = (sub?: ReactiveNode): void => {\n  prevSub = activeSub\n  activeSub = sub\n}\n\nexport const stopPeeking = (): void => {\n  activeSub = prevSub\n  prevSub = undefined\n}\n\nexport const signal = <T>(initialValue?: T): Signal<T> => {\n  return signalOper.bind(0, {\n    previousValue: initialValue,\n    value_: initialValue,\n    flags_: 1 satisfies ReactiveFlags.Mutable,\n  }) as Signal<T>\n}\n\nconst computedSymbol = Symbol('computed')\nexport const computed = <T>(getter: (previousValue?: T) => T): Computed<T> => {\n  const c = computedOper.bind(0, {\n    flags_: 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty,\n    getter,\n  }) as Computed<T>\n  // @ts-expect-error\n  c[computedSymbol] = 1\n  return c\n}\n\nexport const effect = (fn: () => void): Effect => {\n  const e: AlienEffect = {\n    fn_: fn,\n    flags_: 2 satisfies ReactiveFlags.Watching,\n  }\n  if (activeSub) {\n    link(e, activeSub)\n  }\n  startPeeking(e)\n  beginBatch()\n  try {\n    e.fn_()\n  } finally {\n    endBatch()\n    stopPeeking()\n  }\n  return effectOper.bind(0, e)\n}\n\nconst flush = () => {\n  while (notifyIndex < queuedEffectsLength) {\n    const effect = queuedEffects[notifyIndex]!\n    queuedEffects[notifyIndex++] = undefined\n    run(effect, (effect.flags_ &= ~EffectFlags.Queued))\n  }\n  notifyIndex = 0\n  queuedEffectsLength = 0\n}\n\nconst update = (signal: AlienSignal | AlienComputed): boolean => {\n  if ('getter' in signal) {\n    return updateComputed(signal)\n  }\n  return updateSignal(signal, signal.value_)\n}\n\nconst updateComputed = (c: AlienComputed): boolean => {\n  startPeeking(c)\n  startTracking(c)\n  try {\n    const oldValue = c.value_\n    return oldValue !== (c.value_ = c.getter(oldValue))\n  } finally {\n    stopPeeking()\n    endTracking(c)\n  }\n}\n\nconst updateSignal = <T>(s: AlienSignal<T>, value: T): boolean => {\n  s.flags_ = 1 satisfies ReactiveFlags.Mutable\n  return s.previousValue !== (s.previousValue = value)\n}\n\nconst notify = (e: AlienEffect): void => {\n  const flags = e.flags_\n  if (!(flags & EffectFlags.Queued)) {\n    e.flags_ = flags | EffectFlags.Queued\n    const subs = e.subs_\n    if (subs) {\n      notify(subs.sub_ as AlienEffect)\n    } else {\n      queuedEffects[queuedEffectsLength++] = e\n    }\n  }\n}\n\nconst run = (e: AlienEffect, flags: ReactiveFlags): void => {\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(e.deps_!, e))\n  ) {\n    startPeeking(e)\n    startTracking(e)\n    beginBatch()\n    try {\n      e.fn_()\n    } finally {\n      endBatch()\n      stopPeeking()\n      endTracking(e)\n    }\n    return\n  }\n  if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    e.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  let link = e.deps_\n  while (link) {\n    const dep = link.dep_\n    const depFlags = dep.flags_\n    if (depFlags & EffectFlags.Queued) {\n      run(dep as AlienEffect, (dep.flags_ = depFlags & ~EffectFlags.Queued))\n    }\n    link = link.nextDep_\n  }\n}\n\nconst signalOper = <T>(s: AlienSignal<T>, ...value: [T]): T | boolean => {\n  if (value.length) {\n    if (s.value_ !== (s.value_ = value[0])) {\n      s.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n      const subs = s.subs_\n      if (subs) {\n        propagate(subs)\n        if (!batchDepth) {\n          flush()\n        }\n      }\n      return true\n    }\n    return false\n  }\n  const currentValue = s.value_\n  if (s.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n    if (updateSignal(s, currentValue)) {\n      const subs_ = s.subs_\n      if (subs_) {\n        shallowPropagate(subs_)\n      }\n    }\n  }\n  if (activeSub) {\n    link(s, activeSub)\n  }\n  return currentValue\n}\n\nconst computedOper = <T>(c: AlienComputed<T>): T => {\n  const flags = c.flags_\n  if (\n    flags & (16 satisfies ReactiveFlags.Dirty) ||\n    (flags & (32 satisfies ReactiveFlags.Pending) && checkDirty(c.deps_!, c))\n  ) {\n    if (updateComputed(c)) {\n      const subs = c.subs_\n      if (subs) {\n        shallowPropagate(subs)\n      }\n    }\n  } else if (flags & (32 satisfies ReactiveFlags.Pending)) {\n    c.flags_ = flags & ~(32 satisfies ReactiveFlags.Pending)\n  }\n  if (activeSub) {\n    link(c, activeSub)\n  }\n  return c.value_!\n}\n\nconst effectOper = (e: AlienEffect): void => {\n  let dep = e.deps_\n  while (dep) {\n    dep = unlink(dep, e)\n  }\n  const sub = e.subs_\n  if (sub) {\n    unlink(sub)\n  }\n  e.flags_ = 0 satisfies ReactiveFlags.None\n}\n\nconst link = (dep: ReactiveNode, sub: ReactiveNode): void => {\n  const prevDep = sub.depsTail_\n  if (prevDep && prevDep.dep_ === dep) {\n    return\n  }\n  const nextDep = prevDep ? prevDep.nextDep_ : sub.deps_\n  if (nextDep && nextDep.dep_ === dep) {\n    nextDep.version_ = version\n    sub.depsTail_ = nextDep\n    return\n  }\n  const prevSub = dep.subsTail_\n  if (prevSub && prevSub.version_ === version && prevSub.sub_ === sub) {\n    return\n  }\n  const newLink =\n    (sub.depsTail_ =\n    dep.subsTail_ =\n      {\n        version_: version,\n        dep_: dep,\n        sub_: sub,\n        prevDep_: prevDep,\n        nextDep_: nextDep,\n        prevSub_: prevSub,\n      })\n  if (nextDep) {\n    nextDep.prevDep_ = newLink\n  }\n  if (prevDep) {\n    prevDep.nextDep_ = newLink\n  } else {\n    sub.deps_ = newLink\n  }\n  if (prevSub) {\n    prevSub.nextSub_ = newLink\n  } else {\n    dep.subs_ = newLink\n  }\n}\n\nconst unlink = (link: Link, sub = link.sub_): Link | undefined => {\n  const dep_ = link.dep_\n  const prevDep_ = link.prevDep_\n  const nextDep_ = link.nextDep_\n  const nextSub_ = link.nextSub_\n  const prevSub_ = link.prevSub_\n  if (nextDep_) {\n    nextDep_.prevDep_ = prevDep_\n  } else {\n    sub.depsTail_ = prevDep_\n  }\n  if (prevDep_) {\n    prevDep_.nextDep_ = nextDep_\n  } else {\n    sub.deps_ = nextDep_\n  }\n  if (nextSub_) {\n    nextSub_.prevSub_ = prevSub_\n  } else {\n    dep_.subsTail_ = prevSub_\n  }\n  if (prevSub_) {\n    prevSub_.nextSub_ = nextSub_\n  } else if (!(dep_.subs_ = nextSub_)) {\n    if ('getter' in dep_) {\n      let toRemove = dep_.deps_\n      if (toRemove) {\n        dep_.flags_ = 17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty\n        do {\n          toRemove = unlink(toRemove, dep_)\n        } while (toRemove)\n      }\n    } else if (!('previousValue' in dep_)) {\n      effectOper(dep_ as AlienEffect)\n    }\n  }\n  return nextDep_\n}\n\nconst propagate = (link: Link): void => {\n  let next = link.nextSub_\n  let stack: Stack<Link | undefined> | undefined\n\n  top: while (true) {\n    const sub = link.sub_\n\n    let flags = sub.flags_\n\n    if (\n      !(\n        flags &\n        (60 as\n          | ReactiveFlags.RecursedCheck\n          | ReactiveFlags.Recursed\n          | ReactiveFlags.Dirty\n          | ReactiveFlags.Pending)\n      )\n    ) {\n      sub.flags_ = flags | (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (12 as ReactiveFlags.RecursedCheck | ReactiveFlags.Recursed))\n    ) {\n      flags = 0 satisfies ReactiveFlags.None\n    } else if (!(flags & (4 satisfies ReactiveFlags.RecursedCheck))) {\n      sub.flags_ =\n        (flags & ~(8 satisfies ReactiveFlags.Recursed)) |\n        (32 satisfies ReactiveFlags.Pending)\n    } else if (\n      !(flags & (48 as ReactiveFlags.Dirty | ReactiveFlags.Pending)) &&\n      isValidLink(link, sub)\n    ) {\n      sub.flags_ =\n        flags | (40 as ReactiveFlags.Recursed | ReactiveFlags.Pending)\n      flags &= 1 satisfies ReactiveFlags.Mutable\n    } else {\n      flags = 0 satisfies ReactiveFlags.None\n    }\n\n    if (flags & (2 satisfies ReactiveFlags.Watching)) {\n      notify(sub as AlienEffect)\n    }\n\n    if (flags & (1 satisfies ReactiveFlags.Mutable)) {\n      const subSubs = sub.subs_\n      if (subSubs) {\n        const nextSub = (link = subSubs).nextSub_\n        if (nextSub) {\n          stack = { value_: next, prev_: stack }\n          next = nextSub\n        }\n        continue\n      }\n    }\n\n    if ((link = next!)) {\n      next = link.nextSub_\n      continue\n    }\n\n    while (stack) {\n      link = stack.value_!\n      stack = stack.prev_\n      if (link) {\n        next = link.nextSub_\n        continue top\n      }\n    }\n\n    break\n  }\n}\n\nconst startTracking = (sub: ReactiveNode): void => {\n  version++\n  sub.depsTail_ = undefined\n  sub.flags_ =\n    (sub.flags_ &\n      ~(56 as\n        | ReactiveFlags.Recursed\n        | ReactiveFlags.Dirty\n        | ReactiveFlags.Pending)) |\n    (4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst endTracking = (sub: ReactiveNode): void => {\n  const depsTail_ = sub.depsTail_\n  let toRemove = depsTail_ ? depsTail_.nextDep_ : sub.deps_\n  while (toRemove) {\n    toRemove = unlink(toRemove, sub)\n  }\n  sub.flags_ &= ~(4 satisfies ReactiveFlags.RecursedCheck)\n}\n\nconst checkDirty = (link: Link, sub: ReactiveNode): boolean => {\n  let stack: Stack<Link> | undefined\n  let checkDepth = 0\n  let dirty = false\n\n  top: while (true) {\n    const dep = link.dep_\n    const flags = dep.flags_\n\n    if (sub.flags_ & (16 satisfies ReactiveFlags.Dirty)) {\n      dirty = true\n    } else if (\n      (flags & (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)) ===\n      (17 as ReactiveFlags.Mutable | ReactiveFlags.Dirty)\n    ) {\n      if (update(dep as AlienSignal | AlienComputed)) {\n        const subs = dep.subs_!\n        if (subs.nextSub_) {\n          shallowPropagate(subs)\n        }\n        dirty = true\n      }\n    } else if (\n      (flags & (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)) ===\n      (33 as ReactiveFlags.Mutable | ReactiveFlags.Pending)\n    ) {\n      if (link.nextSub_ || link.prevSub_) {\n        stack = { value_: link, prev_: stack }\n      }\n      link = dep.deps_!\n      sub = dep\n      ++checkDepth\n      continue\n    }\n\n    if (!dirty) {\n      const nextDep = link.nextDep_\n      if (nextDep) {\n        link = nextDep\n        continue\n      }\n    }\n\n    while (checkDepth--) {\n      const firstSub = sub.subs_!\n      const hasMultipleSubs = firstSub.nextSub_\n      if (hasMultipleSubs) {\n        link = stack!.value_\n        stack = stack!.prev_\n      } else {\n        link = firstSub\n      }\n      if (dirty) {\n        if (update(sub as AlienSignal | AlienComputed)) {\n          if (hasMultipleSubs) {\n            shallowPropagate(firstSub)\n          }\n          sub = link.sub_\n          continue\n        }\n        dirty = false\n      } else {\n        sub.flags_ &= ~(32 satisfies ReactiveFlags.Pending)\n      }\n      sub = link.sub_\n      if (link.nextDep_) {\n        link = link.nextDep_\n        continue top\n      }\n    }\n\n    return dirty\n  }\n}\n\nconst shallowPropagate = (link: Link): void => {\n  do {\n    const sub = link.sub_\n    const flags = sub.flags_\n    if (\n      (flags & (48 as ReactiveFlags.Pending | ReactiveFlags.Dirty)) ===\n      (32 satisfies ReactiveFlags.Pending)\n    ) {\n      sub.flags_ = flags | (16 satisfies ReactiveFlags.Dirty)\n      if (flags & (2 satisfies ReactiveFlags.Watching)) {\n        notify(sub as AlienEffect)\n      }\n    }\n  } while ((link = link.nextSub_!))\n}\n\nconst isValidLink = (checkLink: Link, sub: ReactiveNode): boolean => {\n  let link = sub.depsTail_\n  while (link) {\n    if (link === checkLink) {\n      return true\n    }\n    link = link.prevDep_\n  }\n  return false\n}\n\nexport const getPath = <T = any>(path: string): T | undefined => {\n  let result = root\n  const split = path.split('.')\n  for (const path of split) {\n    if (result == null || !hasOwn(result, path)) {\n      return\n    }\n    result = result[path]\n  }\n  return result as T\n}\n\nconst deep = (value: any, prefix = ''): any => {\n  const isArr = Array.isArray(value)\n  if (isArr || isPojo(value)) {\n    const deepObj = (isArr ? [] : {}) as Record<string, Signal<any>>\n    for (const key in value) {\n      deepObj[key] = signal(\n        deep((value as Record<string, Signal<any>>)[key], `${prefix + key}.`),\n      )\n    }\n    const keys = signal(0)\n    return new Proxy(deepObj, {\n      get(_, prop: string) {\n        // JSON.stringify calls `.toJSON()` directly instead of checking if it exists on the object\n        // so we have to check if `toJSON` is being called and prevent a signal from automatically\n        // being made so JSON.stringify can fallback to the default stringify\n        if (!(prop === 'toJSON' && !hasOwn(deepObj, prop))) {\n          // special case for when prop is an array function because every array function needs to\n          // be reactive to when the keys change\n          if (isArr && prop in Array.prototype) {\n            keys()\n            return deepObj[prop]\n          }\n          // if prop is a symbol just return the symbol because we don't want to make up that theres\n          // an iterator symbol on an object or not\n          if (typeof prop === 'symbol') {\n            return deepObj[prop]\n          }\n          // if obj doesnt have prop OR prop is null or undefined then create a signal and default\n          // to an empty string\n          if (!hasOwn(deepObj, prop) || deepObj[prop]() == null) {\n            deepObj[prop] = signal('')\n            dispatch(prefix + prop, '')\n            keys(keys() + 1)\n          }\n          return deepObj[prop]()\n        }\n      },\n      set(_, prop: string, newValue) {\n        const path = prefix + prop\n        // special case for when setting length so we can make a diff patch\n        if (isArr && prop === 'length') {\n          const diff = (deepObj[prop] as unknown as number) - newValue\n          deepObj[prop] = newValue\n          // manually make a diff patch for now, shouldnt have to do this when object diffing is\n          // implemented. see https://github.com/starfederation/datastar-dev/issues/274\n          if (diff > 0) {\n            const patch: Record<string, any> = {}\n            for (let i = newValue; i < deepObj[prop]; i++) {\n              patch[i] = null\n            }\n            dispatch(prefix.slice(0, -1), patch)\n            keys(keys() + 1)\n          }\n        } else if (hasOwn(deepObj, prop)) {\n          if (newValue == null) {\n            delete deepObj[prop]\n            // if newValue is a computed set the computed directly instead of wrapping in signal\n          } else if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n            // if prop changed after setting it then dispatch\n          } else if (deepObj[prop](deep(newValue, `${path}.`))) {\n            dispatch(path, newValue)\n          }\n          // if newValue is null or undefined then noop\n        } else if (newValue != null) {\n          // if newValue is a computed set the computed directly instead of wrapping in signal\n          if (hasOwn(newValue, computedSymbol)) {\n            deepObj[prop] = newValue\n            dispatch(path, '')\n          } else {\n            deepObj[prop] = signal(deep(newValue, `${path}.`))\n            dispatch(path, newValue)\n          }\n          keys(keys() + 1)\n        }\n\n        return true\n      },\n      deleteProperty(_, prop: string) {\n        delete deepObj[prop]\n        keys(keys() + 1)\n        return true\n      },\n      ownKeys() {\n        keys()\n        return Reflect.ownKeys(deepObj)\n      },\n      has(_, prop) {\n        keys()\n        return prop in deepObj\n      },\n    })\n  }\n  return value\n}\n\nconst dispatch = (path?: string, value?: any) => {\n  if (path !== undefined && value !== undefined) {\n    currentPatch.push([path, value])\n  }\n  if (!batchDepth && currentPatch.length) {\n    const detail = pathToObj(currentPatch)\n    currentPatch.length = 0\n    document.dispatchEvent(\n      new CustomEvent<JSONPatch>(DATASTAR_SIGNAL_PATCH_EVENT, {\n        detail,\n      }),\n    )\n  }\n}\n\nexport const mergePatch = (\n  patch: JSONPatch,\n  { ifMissing }: MergePatchArgs = {},\n): void => {\n  beginBatch()\n  for (const key in patch) {\n    if (patch[key] == null) {\n      if (!ifMissing) {\n        delete root[key]\n      }\n    } else {\n      mergeInner(patch[key], key, root, '', ifMissing)\n    }\n  }\n  endBatch()\n}\n\nexport const mergePaths = (paths: Paths, options?: MergePatchArgs): void =>\n  mergePatch(pathToObj(paths), options)\n\nconst mergeInner = (\n  patch: any,\n  target: string,\n  targetParent: Record<string, any>,\n  prefix: string,\n  ifMissing: boolean | undefined,\n): void => {\n  if (isPojo(patch)) {\n    if (\n      !(\n        hasOwn(targetParent, target) &&\n        (isPojo(targetParent[target]) || Array.isArray(targetParent[target]))\n      )\n    ) {\n      targetParent[target] = {}\n    }\n\n    for (const key in patch) {\n      if (patch[key] == null) {\n        if (!ifMissing) {\n          delete targetParent[target][key]\n        }\n      } else {\n        mergeInner(\n          patch[key],\n          key,\n          targetParent[target],\n          `${prefix + target}.`,\n          ifMissing,\n        )\n      }\n    }\n  } else if (!(ifMissing && hasOwn(targetParent, target))) {\n    targetParent[target] = patch\n  }\n}\n\nconst toRegExp = (val: string | RegExp): RegExp =>\n  typeof val === 'string' ? RegExp(val.replace(/^\\/|\\/$/g, '')) : val\n\n/**\n * Filters the root store based on an include and exclude RegExp\n *\n * @returns The filtered object\n */\nexport const filtered = (\n  { include = /.*/, exclude = /(?!)/ }: SignalFilterOptions = {},\n  obj: JSONPatch = root,\n): Record<string, any> => {\n  const includeRe = toRegExp(include)\n  const excludeRe = toRegExp(exclude)\n  const paths: Paths = []\n  const stack: [any, string][] = [[obj, '']]\n\n  while (stack.length) {\n    const [node, prefix] = stack.pop()!\n\n    for (const key in node) {\n      const path = prefix + key\n      if (isPojo(node[key])) {\n        stack.push([node[key], `${path}.`])\n      } else if (includeRe.test(path) && !excludeRe.test(path)) {\n        paths.push([path, getPath(path)])\n      }\n    }\n  }\n\n  return pathToObj(paths)\n}\n\nexport const root: Record<string, any> = deep({})\n","import type { HTMLOrSVG } from '@engine/types'\n\nexport const isHTMLOrSVG = (el: Node): el is HTMLOrSVG =>\n  el instanceof HTMLElement ||\n  el instanceof SVGElement ||\n  el instanceof MathMLElement\n","import { DATASTAR_FETCH_EVENT, DSP, DSS } from '@engine/consts'\nimport { snake } from '@utils/text'\nimport { root } from '@engine/signals'\nimport type {\n  ActionPlugin,\n  ActionContext,\n  AttributeContext,\n  AttributePlugin,\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  Requirement,\n  WatcherPlugin,\n} from '@engine/types'\nimport { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify } from '@utils/text'\n\nconst url = 'https://data-star.dev/errors'\n\nconst error = (\n  ctx: Record<string, any>,\n  reason: string,\n  metadata: Record<string, any> = {},\n) => {\n  Object.assign(metadata, ctx)\n  const e = new Error()\n  const r = snake(reason)\n  const q = new URLSearchParams({\n    metadata: JSON.stringify(metadata),\n  }).toString()\n  const c = JSON.stringify(metadata, null, 2)\n  e.message = `${reason}\\nMore info: ${url}/${r}?${q}\\nContext: ${c}`\n  return e\n}\n\nconst actionPlugins: Map<string, ActionPlugin> = new Map()\nconst attributePlugins: Map<string, AttributePlugin> = new Map()\nconst watcherPlugins: Map<string, WatcherPlugin> = new Map()\n\nexport const actions: Record<\n  string,\n  (ctx: ActionContext, ...args: any[]) => any\n> = new Proxy(\n  {},\n  {\n    get: (_, prop: string) => actionPlugins.get(prop)?.apply,\n    has: (_, prop: string) => actionPlugins.has(prop),\n    ownKeys: () => Reflect.ownKeys(actionPlugins),\n    set: () => false,\n    deleteProperty: () => false,\n  },\n)\n\n// Map of cleanups keyed by element and attribute name\nconst removals = new Map<HTMLOrSVG, Map<string, () => void>>()\n\nconst queuedAttributes: AttributePlugin[] = []\nconst queuedAttributeNames = new Set<string>()\nexport const attribute = <R extends Requirement, B extends boolean>(\n  plugin: AttributePlugin<R, B>,\n): void => {\n  queuedAttributes.push(plugin as unknown as AttributePlugin)\n\n  if (queuedAttributes.length === 1) {\n    setTimeout(() => {\n      for (const attribute of queuedAttributes) {\n        queuedAttributeNames.add(attribute.name)\n        attributePlugins.set(attribute.name, attribute)\n      }\n      queuedAttributes.length = 0\n      apply()\n      queuedAttributeNames.clear()\n    })\n  }\n}\n\nexport const action = <T>(plugin: ActionPlugin<T>): void => {\n  actionPlugins.set(plugin.name, plugin)\n}\n\ndocument.addEventListener(DATASTAR_FETCH_EVENT, ((\n  evt: CustomEvent<DatastarFetchEvent>,\n) => {\n  const plugin = watcherPlugins.get(evt.detail.type)\n  if (plugin) {\n    plugin.apply(\n      {\n        error: error.bind(0, {\n          plugin: { type: 'watcher', name: plugin.name },\n          element: {\n            id: (evt.target as Element).id,\n            tag: (evt.target as Element).tagName,\n          },\n        }),\n      },\n      evt.detail.argsRaw,\n    )\n  }\n}) as EventListener)\n\nexport const watcher = (plugin: WatcherPlugin): void => {\n  watcherPlugins.set(plugin.name, plugin)\n}\n\nconst cleanupEls = (els: Iterable<HTMLOrSVG>): void => {\n  for (const el of els) {\n    const cleanups = removals.get(el)\n    // If removals has el, delete it and run all cleanup functions\n    if (removals.delete(el)) {\n      for (const cleanup of cleanups!.values()) {\n        cleanup()\n      }\n      cleanups!.clear()\n    }\n  }\n}\n\nconst aliasedIgnore = aliasify('ignore')\nconst aliasedIgnoreAttr = `[${aliasedIgnore}]`\nconst shouldIgnore = (el: HTMLOrSVG) =>\n  el.hasAttribute(`${aliasedIgnore}__self`) || !!el.closest(aliasedIgnoreAttr)\n\nconst applyEls = (els: Iterable<HTMLOrSVG>, onlyNew?: boolean): void => {\n  for (const el of els) {\n    if (!shouldIgnore(el)) {\n      for (const key in el.dataset) {\n        applyAttributePlugin(\n          el,\n          key.replace(/[A-Z]/g, '-$&').toLowerCase(),\n          el.dataset[key]!,\n          onlyNew,\n        )\n      }\n    }\n  }\n}\n\nconst observe = (mutations: MutationRecord[]) => {\n  for (const {\n    target,\n    type,\n    attributeName,\n    addedNodes,\n    removedNodes,\n  } of mutations) {\n    if (type === 'childList') {\n      for (const node of removedNodes) {\n        if (isHTMLOrSVG(node)) {\n          cleanupEls([node])\n          cleanupEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n\n      for (const node of addedNodes) {\n        if (isHTMLOrSVG(node)) {\n          applyEls([node])\n          applyEls(node.querySelectorAll<HTMLOrSVG>('*'))\n        }\n      }\n    } else if (\n      type === 'attributes' &&\n      attributeName!.startsWith('data-') &&\n      isHTMLOrSVG(target) &&\n      !shouldIgnore(target)\n    ) {\n      // skip over 'data-'\n      const key = attributeName!.slice(5)\n      const value = target.getAttribute(attributeName!)\n      if (value === null) {\n        const cleanups = removals.get(target)\n        if (cleanups) {\n          cleanups.get(key)?.()\n          cleanups.delete(key)\n        }\n      } else {\n        applyAttributePlugin(target, key, value)\n      }\n    }\n  }\n}\n\n// TODO: mutation observer per root so applying to web component doesnt overwrite main observer\nconst mutationObserver = new MutationObserver(observe)\n\nexport const apply = (\n  root: HTMLOrSVG | ShadowRoot = document.documentElement,\n): void => {\n  if (isHTMLOrSVG(root)) {\n    applyEls([root], true)\n  }\n  applyEls(root.querySelectorAll<HTMLOrSVG>('*'), true)\n\n  mutationObserver.observe(root, {\n    subtree: true,\n    childList: true,\n    attributes: true,\n  })\n}\n\nconst applyAttributePlugin = (\n  el: HTMLOrSVG,\n  attrKey: string,\n  value: string,\n  onlyNew?: boolean,\n): void => {\n  if (!ALIAS || attrKey.startsWith(`${ALIAS}-`)) {\n    const rawKey = ALIAS ? attrKey.slice(ALIAS.length + 1) : attrKey\n    const [namePart, ...rawModifiers] = rawKey.split('__')\n    const [pluginName, key] = namePart.split(/:(.+)/)\n    const plugin = attributePlugins.get(pluginName)\n    if ((!onlyNew || queuedAttributeNames.has(pluginName)) && plugin) {\n      const ctx = {\n        el,\n        rawKey,\n        mods: new Map(),\n        error: error.bind(0, {\n          plugin: { type: 'attribute', name: plugin.name },\n          element: { id: el.id, tag: el.tagName },\n          expression: { rawKey, key, value },\n        }),\n        key,\n        value,\n        rx: undefined,\n      } as AttributeContext\n\n      const keyReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.key)) ||\n        'allowed'\n      const valueReq =\n        (plugin.requirement &&\n          (typeof plugin.requirement === 'string'\n            ? plugin.requirement\n            : plugin.requirement.value)) ||\n        'allowed'\n\n      if (key) {\n        if (keyReq === 'denied') {\n          throw ctx.error('KeyNotAllowed')\n        }\n      } else if (keyReq === 'must') {\n        throw ctx.error('KeyRequired')\n      }\n\n      if (value) {\n        if (valueReq === 'denied') {\n          throw ctx.error('ValueNotAllowed')\n        }\n      } else if (valueReq === 'must') {\n        throw ctx.error('ValueRequired')\n      }\n\n      if (keyReq === 'exclusive' || valueReq === 'exclusive') {\n        if (key && value) {\n          throw ctx.error('KeyAndValueProvided')\n        }\n        if (!key && !value) {\n          throw ctx.error('KeyOrValueRequired')\n        }\n      }\n\n      if (value) {\n        let cachedRx: GenRxFn\n        ctx.rx = (...args: any[]) => {\n          if (!cachedRx) {\n            cachedRx = genRx(value, {\n              returnsValue: plugin.returnsValue,\n              argNames: plugin.argNames,\n            })\n          }\n          return cachedRx(el, ...args)\n        }\n      }\n\n      for (const rawMod of rawModifiers) {\n        const [label, ...mod] = rawMod.split('.')\n        ctx.mods.set(label, new Set(mod))\n      }\n\n      const cleanup = plugin.apply(ctx)\n      if (cleanup) {\n        let cleanups = removals.get(el)\n        if (cleanups) {\n          cleanups.get(rawKey)?.()\n        } else {\n          cleanups = new Map()\n          removals.set(el, cleanups)\n        }\n        cleanups.set(rawKey, cleanup)\n      }\n    }\n  }\n}\n\ntype GenRxOptions = {\n  returnsValue?: boolean\n  argNames?: string[]\n}\n\ntype GenRxFn = <T>(el: HTMLOrSVG, ...args: any[]) => T\n\nconst genRx = (\n  value: string,\n  { returnsValue = false, argNames = [] }: GenRxOptions = {},\n): GenRxFn => {\n  let expr = ''\n  if (returnsValue) {\n    // This regex allows Datastar expressions to support nested\n    // regex and strings that contain ; without breaking.\n    //\n    // Each of these regex defines a block type we want to match\n    // (importantly we ignore the content within these blocks):\n    //\n    // regex            \\/(\\\\\\/|[^\\/])*\\/\n    // double quotes      \"(\\\\\"|[^\\\"])*\"\n    // single quotes      '(\\\\'|[^'])*'\n    // ticks              `(\\\\`|[^`])*`\n    // iife               \\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;)\\{]*)\\s*\\)\\s*\\(\\s*\\)\n    //\n    // The iife support is (intentionally) limited. It only supports\n    // function and arrow syntax with no arguments, and no nested IIFEs.\n    //\n    // We also want to match the non delimiter part of statements\n    // note we only support ; statement delimiters:\n    //\n    // [^;]\n    //\n    const statementRe =\n      /(\\/(\\\\\\/|[^/])*\\/|\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|`(\\\\`|[^`])*`|\\(\\s*((function)\\s*\\(\\s*\\)|(\\(\\s*\\))\\s*=>)\\s*(?:\\{[\\s\\S]*?\\}|[^;){]*)\\s*\\)\\s*\\(\\s*\\)|[^;])+/gm\n    const statements = value.trim().match(statementRe)\n    if (statements) {\n      const lastIdx = statements.length - 1\n      const last = statements[lastIdx].trim()\n      if (!last.startsWith('return')) {\n        statements[lastIdx] = `return (${last});`\n      }\n      expr = statements.join(';\\n')\n    }\n  } else {\n    expr = value.trim()\n  }\n\n  // Ignore any escaped values\n  const escaped = new Map<string, string>()\n  const escapeRe = RegExp(`(?:${DSP})(.*?)(?:${DSS})`, 'gm')\n  let counter = 0\n  for (const match of expr.matchAll(escapeRe)) {\n    const k = match[1]\n    const v = `__escaped${counter++}`\n    escaped.set(v, k)\n    expr = expr.replace(DSP + k + DSS, v)\n  }\n\n  // Replace signal references with bracket notation\n  // Examples:\n  //   $count          -> $['count']\n  //   $count--        -> $['count']--\n  //   $foo.bar        -> $['foo']['bar']\n  //   $foo-bar        -> $['foo-bar']\n  //   $foo.bar-baz    -> $['foo']['bar-baz']\n  //   $foo-$bar       -> $['foo']-$['bar']\n  //   $arr[$index]    -> $['arr'][$['index']]\n  //   $['foo']        -> $['foo']\n  //   $foo[obj.bar]   -> $['foo'][obj.bar]\n  //   $foo['bar.baz'] -> $['foo']['bar.baz']\n  //   $123            -> $['123']\n  //   $foo.0.name     -> $['foo']['0']['name']\n\n  expr = expr\n    // $['x'] -> $x (normalize existing bracket notation)\n    .replace(/\\$\\['([a-zA-Z_$\\d][\\w$]*)'\\]/g, '$$$1')\n    // $x -> $['x'] (including dots and hyphens)\n    .replace(/\\$([a-zA-Z_\\d]\\w*(?:[.-]\\w+)*)/g, (_, signalName) =>\n      signalName\n        .split('.')\n        .reduce((acc: string, part: string) => `${acc}['${part}']`, '$'),\n    )\n    // [$x] -> [$['x']] ($ inside brackets)\n    .replace(\n      /\\[(\\$[a-zA-Z_\\d]\\w*)\\]/g,\n      (_, varName) => `[$['${varName.slice(1)}']]`,\n    )\n\n  expr = expr.replaceAll(/@(\\w+)\\(/g, '__action(\"$1\",evt,')\n\n  // Replace any escaped values\n  for (const [k, v] of escaped) {\n    expr = expr.replace(k, v)\n  }\n\n  try {\n    const fn = Function('el', '$', '__action', 'evt', ...argNames, expr)\n    return (el: HTMLOrSVG, ...args: any[]) => {\n      const action = (name: string, evt: Event | undefined, ...args: any[]) => {\n        const err = error.bind(0, {\n          plugin: { type: 'action', name },\n          element: { id: el.id, tag: el.tagName },\n          expression: {\n            fnContent: expr,\n            value,\n          },\n        })\n        const fn = actions[name]\n        if (fn) {\n          return fn(\n            {\n              el,\n              evt,\n              error: err,\n            },\n            ...args,\n          )\n        }\n        throw err('UndefinedAction')\n      }\n      try {\n        return fn(el, root, action, undefined, ...args)\n      } catch (e: any) {\n        console.error(e)\n        throw error(\n          {\n            element: { id: el.id, tag: el.tagName },\n            expression: {\n              fnContent: expr,\n              value,\n            },\n            error: e.message,\n          },\n          'ExecuteExpression',\n        )\n      }\n    }\n  } catch (e: any) {\n    console.error(e)\n    throw error(\n      {\n        expression: {\n          fnContent: expr,\n          value,\n        },\n        error: e.message,\n      },\n      'GenerateExpression',\n    )\n  }\n}\n","// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { startPeeking, stopPeeking } from '@engine/signals'\n\naction({\n  name: 'peek',\n  apply(_, fn: () => any) {\n    startPeeking()\n    try {\n      return fn()\n    } finally {\n      stopPeeking()\n    }\n  },\n})\n","// Icon: ion:checkmark-round\n// Slug: Sets the value of all matching signals.\n// Description: Sets the value of all matching signals (or all signals if no filter is used) to the expression provided in the first argument.\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'setAll',\n  apply(_, value: any, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, () => value)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n","// Icon: material-symbols:toggle-off\n// Slug: Toggles the value of all matching signals.\n// Description: Toggles the boolean value of all matching signals (or all signals if no filter is used).\n\nimport { action } from '@engine'\nimport {\n  filtered,\n  mergePatch,\n  startPeeking,\n  stopPeeking,\n} from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { updateLeaves } from '@utils/paths'\n\naction({\n  name: 'toggleAll',\n  apply(_, filter: SignalFilterOptions) {\n    // peek because in an effect you would be subscribing to signals and then setting them which\n    // would cause an infinite loop and why would you want to infinite loop on purpose\n    startPeeking()\n    const masked = filtered(filter)\n    updateLeaves(masked, (oldValue: any) => !oldValue)\n    mergePatch(masked)\n    stopPeeking()\n  },\n})\n","// Icon: ion:eye\n// Slug: Access signals without subscribing to changes.\n// Description: Allows accessing signals without subscribing to their changes in expressions.\n\nimport { action } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { filtered } from '@engine/signals'\nimport type {\n  DatastarFetchEvent,\n  HTMLOrSVG,\n  SignalFilterOptions,\n} from '@engine/types'\nimport { kebab } from '@utils/text'\n\nconst fetchAbortControllers = new WeakMap<HTMLOrSVG, AbortController>()\n\nconst createHttpMethod = (name: string, method: string): void =>\n  action({\n    name,\n    apply: async (\n      { el, evt, error },\n      url: string,\n      {\n        selector,\n        headers: userHeaders,\n        contentType = 'json',\n        filterSignals: { include = /.*/, exclude = /(^|\\.)_/ } = {},\n        openWhenHidden = false,\n        retryInterval = 1000,\n        retryScaler = 2,\n        retryMaxWaitMs = 30_000,\n        retryMaxCount = 10,\n        requestCancellation = 'auto',\n      }: FetchArgs = {},\n    ) => {\n      const controller =\n        requestCancellation instanceof AbortController\n          ? requestCancellation\n          : new AbortController()\n      const isDisabled = requestCancellation === 'disabled'\n      if (!isDisabled) {\n        const oldController = fetchAbortControllers.get(el)\n        if (oldController) {\n          oldController.abort()\n          // wait one tick for FINISHED to fire\n          await Promise.resolve()\n        }\n      }\n\n      if (!isDisabled && !(requestCancellation instanceof AbortController)) {\n        fetchAbortControllers.set(el, controller)\n      }\n\n      try {\n        const observer = new MutationObserver((mutations) => {\n          for (const mutation of mutations) {\n            for (const removed of mutation.removedNodes) {\n              if (removed === el) {\n                controller.abort()\n                cleanupFn()\n              }\n            }\n          }\n        })\n        if (el.parentNode) {\n          observer.observe(el.parentNode, { childList: true })\n        }\n\n        let cleanupFn = () => {\n          observer.disconnect()\n        }\n\n        try {\n          if (!url?.length) {\n            throw error('FetchNoUrlProvided', { action })\n          }\n\n          const initialHeaders: Record<string, any> = {\n            Accept: 'text/event-stream, text/html, application/json',\n            'Datastar-Request': true,\n          }\n          if (contentType === 'json') {\n            initialHeaders['Content-Type'] = 'application/json'\n          }\n          const headers = Object.assign({}, initialHeaders, userHeaders)\n\n          // We ignore the content-type header if using form data\n          // if missing the boundary will be set automatically\n\n          const req: FetchEventSourceInit = {\n            method,\n            headers,\n            openWhenHidden,\n            retryInterval,\n            retryScaler,\n            retryMaxWaitMs,\n            retryMaxCount,\n            signal: controller.signal,\n            onopen: async (response: Response) => {\n              if (response.status >= 400)\n                dispatchFetch(ERROR, el, { status: response.status.toString() })\n            },\n            onmessage: (evt) => {\n              if (!evt.event.startsWith('datastar')) return\n              const type = evt.event\n              const argsRawLines: Record<string, string[]> = {}\n\n              for (const line of evt.data.split('\\n')) {\n                const i = line.indexOf(' ')\n                const k = line.slice(0, i)\n                const v = line.slice(i + 1)\n                ;(argsRawLines[k] ||= []).push(v)\n              }\n\n              const argsRaw = Object.fromEntries(\n                Object.entries(argsRawLines).map(([k, v]) => [k, v.join('\\n')]),\n              )\n\n              dispatchFetch(type, el, argsRaw)\n            },\n            onerror: (error) => {\n              if (isWrongContent(error)) {\n                // don't retry if the content-type is wrong\n                throw error('FetchExpectedTextEventStream', { url })\n              }\n              // do nothing and it will retry\n              if (error) {\n                console.error(error.message)\n                dispatchFetch(RETRYING, el, { message: error.message })\n              }\n            },\n          }\n\n          const urlInstance = new URL(url, document.baseURI)\n          const queryParams = new URLSearchParams(urlInstance.search)\n\n          if (contentType === 'json') {\n            const res = JSON.stringify(filtered({ include, exclude }))\n            if (method === 'GET') {\n              queryParams.set('datastar', res)\n            } else {\n              req.body = res\n            }\n          } else if (contentType === 'form') {\n            const formEl = (\n              selector ? document.querySelector(selector) : el.closest('form')\n            ) as HTMLFormElement\n            if (!formEl) {\n              throw error('FetchFormNotFound', { action, selector })\n            }\n\n            // Validate the form\n            if (!formEl.checkValidity()) {\n              formEl.reportValidity()\n              cleanupFn()\n              return\n            }\n\n            // Collect the form data\n\n            const formData = new FormData(formEl)\n            let submitter = el as HTMLElement | null\n\n            if (el === formEl && evt instanceof SubmitEvent) {\n              // Get the submitter from the event\n              submitter = evt.submitter\n            } else {\n              // Prevent the form being submitted\n              const preventDefault = (evt: Event) => evt.preventDefault()\n              formEl.addEventListener('submit', preventDefault)\n              cleanupFn = () => {\n                formEl.removeEventListener('submit', preventDefault)\n                observer.disconnect()\n              }\n            }\n\n            // Append the value of the form submitter if it is a button with a name\n            if (submitter instanceof HTMLButtonElement) {\n              const name = submitter.getAttribute('name')\n              if (name) formData.append(name, submitter.value)\n            }\n\n            const multipart =\n              formEl.getAttribute('enctype') === 'multipart/form-data'\n            // Leave the `Content-Type` header empty for multipart encoding so the browser can set it automatically with the correct boundary\n            if (!multipart) {\n              headers['Content-Type'] = 'application/x-www-form-urlencoded'\n            }\n\n            const formParams = new URLSearchParams(formData as any)\n            if (method === 'GET') {\n              for (const [key, value] of formParams) {\n                queryParams.append(key, value)\n              }\n            } else if (multipart) {\n              req.body = formData\n            } else {\n              req.body = formParams\n            }\n          } else {\n            throw error('FetchInvalidContentType', { action, contentType })\n          }\n\n          dispatchFetch(STARTED, el, {})\n          urlInstance.search = queryParams.toString()\n\n          try {\n            await fetchEventSource(urlInstance.toString(), el, req)\n          } catch (e: any) {\n            if (!isWrongContent(e)) {\n              throw error('FetchFailed', { method, url, error: e.message })\n            }\n            // exit gracefully and do nothing if the content-type is wrong\n            // this can happen if the client is sending a request\n            // where no response is expected, and they havenâ€™t\n            // set the content-type to text/event-stream\n          }\n        } finally {\n          dispatchFetch(FINISHED, el, {})\n          cleanupFn()\n        }\n      } finally {\n        if (fetchAbortControllers.get(el) === controller) {\n          fetchAbortControllers.delete(el)\n        }\n      }\n    },\n  })\n\ncreateHttpMethod('delete', 'DELETE')\ncreateHttpMethod('get', 'GET')\ncreateHttpMethod('patch', 'PATCH')\ncreateHttpMethod('post', 'POST')\ncreateHttpMethod('put', 'PUT')\n\nexport const STARTED = 'started'\nexport const FINISHED = 'finished'\nexport const ERROR = 'error'\nexport const RETRYING = 'retrying'\nexport const RETRIES_FAILED = 'retries-failed'\n\nconst dispatchFetch = (\n  type: string,\n  el: HTMLOrSVG,\n  argsRaw: Record<string, string>,\n) =>\n  document.dispatchEvent(\n    new CustomEvent<DatastarFetchEvent>(DATASTAR_FETCH_EVENT, {\n      detail: { type, el, argsRaw },\n    }),\n  )\n\nconst isWrongContent = (err: any) => `${err}`.includes('text/event-stream')\n\ntype ResponseOverrides =\n  | {\n      selector?: string\n      mode?: string\n      useViewTransition?: boolean\n    }\n  | {\n      onlyIfMissing?: boolean\n    }\n\nexport type FetchArgs = {\n  headers?: Record<string, string>\n  credentials?: RequestCredentials\n  openWhenHidden?: boolean\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  responseOverrides?: ResponseOverrides\n  contentType?: 'json' | 'form'\n  filterSignals?: SignalFilterOptions\n  selector?: string\n  requestCancellation?: 'auto' | 'disabled' | AbortController\n}\n\n// Below originally from https://github.com/Azure/fetch-event-source/blob/main/LICENSE\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\n\ninterface EventSourceMessage {\n  id: string\n  event: string\n  data: string\n  retry?: number\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nconst getBytes = async (\n  stream: ReadableStream<Uint8Array>,\n  onChunk: (arr: Uint8Array) => void,\n): Promise<void> => {\n  const reader = stream.getReader()\n  let result = await reader.read()\n  while (!result.done) {\n    onChunk(result.value)\n    result = await reader.read()\n  }\n}\n\nconst getLines = (onLine: (line: Uint8Array, fieldLength: number) => void) => {\n  let buffer: Uint8Array | undefined\n  let position: number // current read position\n  let fieldLength: number // length of the `field` portion of the line\n  let discardTrailingNewline = false\n\n  // return a function that can process each incoming byte chunk:\n  return (arr: Uint8Array) => {\n    if (!buffer) {\n      buffer = arr\n      position = 0\n      fieldLength = -1\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr)\n    }\n\n    const bufLength = buffer.length\n    let lineStart = 0 // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === 10) lineStart = ++position // skip to next char\n        discardTrailingNewline = false\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1 // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case 58: // :\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart\n            }\n            break\n          // @ts-expect-error:7029 \\r case below should fallthrough to \\n:\n          // biome-ignore lint/suspicious/noFallthroughSwitchClause: intentional fallthrough for CR to LF\n          case 13: // \\r\n            discardTrailingNewline = true\n          case 10: // \\n\n            lineEnd = position\n            break\n        }\n      }\n\n      if (lineEnd === -1) break // Wait for the next arr and then continue parsing\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength)\n      lineStart = position // we're now on the next line\n      fieldLength = -1\n    }\n\n    if (lineStart === bufLength)\n      buffer = undefined // we've finished reading it\n    else if (lineStart) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart)\n      position -= lineStart\n    }\n  }\n}\n\nconst getMessages = (\n  onId: (id: string) => void,\n  onRetry: (retry: number) => void,\n  onMessage?: (msg: EventSourceMessage) => void,\n): ((line: Uint8Array, fieldLength: number) => void) => {\n  let message = newMessage()\n  const decoder = new TextDecoder()\n\n  // return a function that can process each incoming line buffer:\n  return (line, fieldLength) => {\n    if (!line.length) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message)\n      message = newMessage()\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength))\n      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1)\n      const value = decoder.decode(line.subarray(valueOffset))\n\n      switch (field) {\n        case 'data':\n          message.data = message.data ? `${message.data}\\n${value}` : value\n          break\n        case 'event':\n          message.event = value\n          break\n        case 'id':\n          onId((message.id = value))\n          break\n        case 'retry': {\n          const retry = +value\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry((message.retry = retry))\n          }\n          break\n        }\n      }\n    }\n  }\n}\n\nconst concat = (a: Uint8Array, b: Uint8Array) => {\n  const res = new Uint8Array(a.length + b.length)\n  res.set(a)\n  res.set(b, a.length)\n  return res\n}\n\nconst newMessage = (): EventSourceMessage => ({\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  data: '',\n  event: '',\n  id: '',\n  retry: undefined,\n})\n\ntype FetchEventSourceInit = RequestInit & {\n  headers?: Record<string, string>\n  onopen?: (response: Response) => Promise<void>\n  onmessage?: (ev: EventSourceMessage) => void\n  onclose?: () => void\n  onerror?: (err: any) => number | null | undefined | void\n  openWhenHidden?: boolean\n  fetch?: typeof fetch\n  retryInterval?: number\n  retryScaler?: number\n  retryMaxWaitMs?: number\n  retryMaxCount?: number\n  overrides?: ResponseOverrides\n}\n\nconst fetchEventSource = (\n  input: RequestInfo,\n  el: HTMLOrSVG,\n  {\n    signal: inputSignal,\n    headers: inputHeaders,\n    onopen: inputOnOpen,\n    onmessage,\n    onclose,\n    onerror,\n    openWhenHidden,\n    fetch: inputFetch,\n    retryInterval = 1_000,\n    retryScaler = 2,\n    retryMaxWaitMs = 30_000,\n    retryMaxCount = 10,\n    overrides,\n    ...rest\n  }: FetchEventSourceInit,\n): Promise<void> => {\n  return new Promise<void>((resolve, reject) => {\n    // make a copy of the input headers since we may modify it below:\n    const headers: Record<string, string> = {\n      ...inputHeaders,\n    }\n\n    let curRequestController: AbortController\n    const onVisibilityChange = () => {\n      curRequestController.abort() // close existing request on every visibility change\n      if (!document.hidden) create() // page is now visible again, recreate request.\n    }\n\n    if (!openWhenHidden) {\n      document.addEventListener('visibilitychange', onVisibilityChange)\n    }\n\n    let retryTimer = 0\n    const dispose = () => {\n      document.removeEventListener('visibilitychange', onVisibilityChange)\n      clearTimeout(retryTimer)\n      curRequestController.abort()\n    }\n\n    // if the incoming signal aborts, dispose resources and resolve:\n    inputSignal?.addEventListener('abort', () => {\n      dispose()\n      resolve() // don't waste time constructing/logging errors\n    })\n\n    const fetch = inputFetch || window.fetch\n    const onopen = inputOnOpen || (() => {})\n\n    let retries = 0\n    let baseRetryInterval = retryInterval\n    const create = async () => {\n      curRequestController = new AbortController()\n      try {\n        const response = await fetch(input, {\n          ...rest,\n          headers,\n          signal: curRequestController.signal,\n        })\n\n        // on successful connection, reset the retry logic\n        retries = 0\n        retryInterval = baseRetryInterval\n\n        await onopen(response)\n\n        const dispatchNonSSE = async (\n          dispatchType: string,\n          response: Response,\n          name: string,\n          overrides?: ResponseOverrides,\n          ...argNames: string[]\n        ) => {\n          const argsRaw: Record<string, string> = {\n            [name]: await response.text(),\n          }\n          for (const n of argNames) {\n            let v = response.headers.get(`datastar-${kebab(n)}`)\n            if (overrides) {\n              const o = (overrides as any)[n]\n              if (o) v = typeof o === 'string' ? o : JSON.stringify(o)\n            }\n            if (v) argsRaw[n] = v\n          }\n\n          dispatchFetch(dispatchType, el, argsRaw)\n          dispose()\n          resolve()\n        }\n\n        const ct = response.headers.get('Content-Type')\n        if (ct?.includes('text/html')) {\n          return await dispatchNonSSE(\n            'datastar-patch-elements',\n            response,\n            'elements',\n            overrides,\n            'selector',\n            'mode',\n            'useViewTransition',\n          )\n        }\n\n        if (ct?.includes('application/json')) {\n          return await dispatchNonSSE(\n            'datastar-patch-signals',\n            response,\n            'signals',\n            overrides,\n            'onlyIfMissing',\n          )\n        }\n\n        if (ct?.includes('text/javascript')) {\n          const script = document.createElement('script')\n          const scriptAttributesHeader = response.headers.get(\n            'datastar-script-attributes',\n          )\n\n          if (scriptAttributesHeader) {\n            for (const [name, value] of Object.entries(\n              JSON.parse(scriptAttributesHeader),\n            )) {\n              script.setAttribute(name, value as string)\n            }\n          }\n          script.textContent = await response.text()\n          document.head.appendChild(script)\n          dispose()\n          return\n        }\n\n        await getBytes(\n          response.body!,\n          getLines(\n            getMessages(\n              (id) => {\n                if (id) {\n                  // signals the id and send it back on the next retry:\n                  headers['last-event-id'] = id\n                } else {\n                  // don't send the last-event-id header anymore:\n                  delete headers['last-event-id']\n                }\n              },\n              (retry) => {\n                baseRetryInterval = retryInterval = retry\n              },\n              onmessage,\n            ),\n          ),\n        )\n\n        onclose?.()\n        dispose()\n        resolve()\n      } catch (err) {\n        if (!curRequestController.signal.aborted) {\n          // if we havenâ€™t aborted the request ourselves:\n          try {\n            // check if we need to retry:\n            const interval: any = onerror?.(err) || retryInterval\n            clearTimeout(retryTimer)\n            retryTimer = setTimeout(create, interval)\n            retryInterval = Math.min(\n              retryInterval * retryScaler,\n              retryMaxWaitMs,\n            ) // exponential backoff\n            if (++retries >= retryMaxCount) {\n              dispatchFetch(RETRIES_FAILED, el, {})\n              // we should not retry anymore:\n              dispose()\n              reject('Max retries reached.') // Max retries reached, check your server or network connection\n            } else {\n              console.error(\n                `Datastar failed to reach ${input.toString()} retrying in ${interval}ms.`,\n              )\n            }\n          } catch (innerErr) {\n            // we should not retry anymore:\n            dispose()\n            reject(innerErr)\n          }\n        }\n      }\n    }\n\n    create()\n  })\n}\n","// Icon: material-symbols:edit-attributes-outline\n// Slug: Syncs the value of an attribute with an expression.\n// Description: Sets the value of any HTML attribute to an expression, and keeps it in sync.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'attr',\n  requirement: { value: 'must' },\n  returnsValue: true,\n  apply({ el, key, rx }) {\n    const syncAttr = (key: string, val: any) => {\n      if (val === '' || val === true) {\n        el.setAttribute(key, '')\n      } else if (val === false || val == null) {\n        el.removeAttribute(key)\n      } else if (typeof val === 'string') {\n        el.setAttribute(key, val)\n      } else {\n        el.setAttribute(key, JSON.stringify(val))\n      }\n    }\n\n    const update = key\n      ? () => {\n          observer.disconnect()\n          const val = rx() as string\n          syncAttr(key, val)\n          observer.observe(el, {\n            attributeFilter: [key],\n          })\n        }\n      : () => {\n          observer.disconnect()\n          const obj = rx() as Record<string, any>\n          const attributeFilter = Object.keys(obj)\n          for (const key of attributeFilter) {\n            syncAttr(key, obj[key])\n          }\n          observer.observe(el, {\n            attributeFilter,\n          })\n        }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n","// Icon: akar-icons:link-chain\n// Slug: Creates a signal with two-way data binding.\n// Description: Creates a signal (if one doesnâ€™t already exist) and sets up two-way data binding between it and an elementâ€™s value.\n\nimport { attribute } from '@engine'\nimport { effect, getPath, mergePaths } from '@engine/signals'\nimport type { Paths } from '@engine/types'\nimport { aliasify, modifyCasing } from '@utils/text'\n\ntype SignalFile = {\n  name: string\n  contents: string\n  mime: string\n}\n\nconst dataURIRegex = /^data:(?<mime>[^;]+);base64,(?<contents>.*)$/\nconst empty = Symbol('empty')\n\nconst aliasedBind = aliasify('bind')\n\nattribute({\n  name: 'bind',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value, error }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    let get = (el: any, type: string) =>\n      type === 'number' ? +el.value : el.value\n\n    let set = (value: any) => {\n      ;(el as HTMLInputElement).value = `${value}`\n    }\n\n    if (el instanceof HTMLInputElement) {\n      switch (el.type) {\n        case 'range':\n        case 'number':\n          get = (el: any, type: string) =>\n            type === 'string' ? el.value : +el.value\n          break\n\n        case 'checkbox':\n          get = (el: HTMLInputElement, type: string) => {\n            if (el.value !== 'on') {\n              if (type === 'boolean') {\n                return el.checked\n              } else {\n                return el.checked ? el.value : ''\n              }\n            } else {\n              if (type === 'string') {\n                return el.checked ? el.value : ''\n              } else {\n                return el.checked\n              }\n            }\n          }\n          set = (value: string | boolean) => {\n            el.checked = typeof value === 'string' ? value === el.value : value\n          }\n          break\n\n        case 'radio':\n          // Set up radio button name attribute if not present\n          if (!el.getAttribute('name')?.length) {\n            el.setAttribute('name', signalName)\n          }\n\n          get = (el: HTMLInputElement, type: string) =>\n            el.checked ? (type === 'number' ? +el.value : el.value) : empty\n          set = (value: string | number) => {\n            el.checked =\n              value === (typeof value === 'number' ? +el.value : el.value)\n          }\n          break\n        case 'file': {\n          const syncSignal = () => {\n            const files = [...(el.files || [])]\n            const signalFiles: SignalFile[] = []\n            Promise.all(\n              files.map(\n                (f) =>\n                  new Promise<void>((resolve) => {\n                    const reader = new FileReader()\n                    reader.onload = () => {\n                      if (typeof reader.result !== 'string') {\n                        throw error('InvalidFileResultType', {\n                          resultType: typeof reader.result,\n                        })\n                      }\n                      const match = reader.result.match(dataURIRegex)\n                      if (!match?.groups) {\n                        throw error('InvalidDataUri', {\n                          result: reader.result,\n                        })\n                      }\n                      signalFiles.push({\n                        name: f.name,\n                        contents: match.groups.contents,\n                        mime: match.groups.mime,\n                      })\n                    }\n                    reader.onloadend = () => resolve()\n                    reader.readAsDataURL(f)\n                  }),\n              ),\n            ).then(() => {\n              mergePaths([[signalName, signalFiles]])\n            })\n          }\n\n          el.addEventListener('change', syncSignal)\n          el.addEventListener('input', syncSignal)\n\n          return () => {\n            el.removeEventListener('change', syncSignal)\n            el.removeEventListener('input', syncSignal)\n          }\n        }\n      }\n    } else if (el instanceof HTMLSelectElement) {\n      if (el.multiple) {\n        const typeMap = new Map<string, string>()\n        get = (el: HTMLSelectElement) =>\n          [...el.selectedOptions].map((option) => {\n            const type = typeMap.get(option.value)\n            return type === 'string' || type == null\n              ? option.value\n              : +option.value\n          })\n\n        set = (value: (string | number)[]) => {\n          for (const option of el.options) {\n            if (value.includes(option.value)) {\n              typeMap.set(option.value, 'string')\n              option.selected = true\n            } else if (value.includes(+option.value)) {\n              typeMap.set(option.value, 'number')\n              option.selected = true\n            } else {\n              option.selected = false\n            }\n          }\n        }\n      }\n    } else if (el instanceof HTMLTextAreaElement) {\n      // default case\n    } else {\n      // web component\n      get = (el: Element) =>\n        'value' in el ? el.value : el.getAttribute('value')\n      set = (value: any) => {\n        if ('value' in el) {\n          el.value = value\n        } else {\n          el.setAttribute('value', value)\n        }\n      }\n    }\n\n    const initialValue = getPath(signalName)\n    const type = typeof initialValue\n\n    let path = signalName\n    if (\n      Array.isArray(initialValue) &&\n      !(el instanceof HTMLSelectElement && el.multiple)\n    ) {\n      const signalNameKebab = key ? key : value!\n      const inputs = document.querySelectorAll(\n        `[${aliasedBind}\\\\:${CSS.escape(signalNameKebab)}],[${aliasedBind}=\"${CSS.escape(signalNameKebab)}\"]`,\n      ) as NodeListOf<HTMLInputElement>\n\n      const paths: Paths = []\n      let i = 0\n      for (const input of inputs) {\n        paths.push([`${path}.${i}`, get(input, 'none')])\n\n        if (el === input) {\n          break\n        }\n        i++\n      }\n      mergePaths(paths, { ifMissing: true })\n      path = `${path}.${i}`\n    } else {\n      mergePaths([[path, get(el, type)]], {\n        ifMissing: true,\n      })\n    }\n\n    const syncSignal = () => {\n      const signalValue = getPath(path)\n      if (signalValue != null) {\n        const value = get(el, typeof signalValue)\n        if (value !== empty) {\n          mergePaths([[path, value]])\n        }\n      }\n    }\n\n    el.addEventListener('input', syncSignal)\n    el.addEventListener('change', syncSignal)\n    const cleanup = effect(() => {\n      set(getPath(path))\n    })\n\n    return () => {\n      cleanup()\n      el.removeEventListener('input', syncSignal)\n      el.removeEventListener('change', syncSignal)\n    }\n  },\n})\n","// Icon: ic:baseline-format-paint\n// Slug: Adds or removes a class based on an expression.\n// Description: Adds or removes a class to or from an element based on an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'class',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, mods, rx }) {\n    if (key) {\n      key = modifyCasing(key, mods, 'kebab')\n    }\n\n    const callback = () => {\n      observer.disconnect()\n\n      const classes = key\n        ? { [key]: rx() as boolean }\n        : (rx() as Record<string, boolean>)\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        if (classes[k]) {\n          for (const name of classNames) {\n            if (!el.classList.contains(name)) {\n              el.classList.add(name)\n            }\n          }\n        } else {\n          for (const name of classNames) {\n            if (el.classList.contains(name)) {\n              el.classList.remove(name)\n            }\n          }\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['class'] })\n    }\n\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n\n      const classes = key\n        ? { [key]: rx() as boolean }\n        : (rx() as Record<string, boolean>)\n\n      for (const k in classes) {\n        const classNames = k.split(/\\s+/).filter((cn) => cn.length > 0)\n        for (const name of classNames) {\n          el.classList.remove(name)\n        }\n      }\n    }\n  },\n})\n","// Icon: streamline-ultimate:wifi-signal-2\n// Slug: Creates a computed signal.\n// Description: Creates a signal that is computed based on an expression.\n\nimport { attribute } from '@engine'\nimport { computed, mergePaths, mergePatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { updateLeaves } from '@utils/paths'\n\nattribute({\n  name: 'computed',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, mods, rx, error }) {\n    if (key) {\n      mergePaths([[modifyCasing(key, mods), computed(rx)]])\n    } else {\n      const patch = Object.assign({}, rx() as Record<string, () => any>)\n      updateLeaves(patch, (old) => {\n        if (typeof old === 'function') {\n          return computed(old)\n        } else {\n          throw error('ComputedExpectedFunction')\n        }\n      })\n      mergePatch(patch)\n    }\n  },\n})\n","// Icon: oui:security-signal\n// Slug: Executes an expression when signals change.\n// Description: Executes an expression on page load and whenever any signals in the expression change.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'effect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply: ({ rx }) => effect(rx),\n})\n","// Icon: streamline:signal-loading-remix\n// Slug: Creates an indicator for whether an SSE request is in flight.\n// Description: Creates a signal and sets its value to `true` while an SSE request request is in flight, otherwise `false`.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_FETCH_EVENT } from '@engine/consts'\nimport { mergePaths } from '@engine/signals'\nimport type { DatastarFetchEvent } from '@engine/types'\nimport { FINISHED, STARTED } from '@plugins/actions/fetch'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'indicator',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n\n    mergePaths([[signalName, false]])\n\n    const watcher = ((event: CustomEvent<DatastarFetchEvent>) => {\n      const { type, el: elt } = event.detail\n      if (elt !== el) {\n        return\n      }\n      switch (type) {\n        case STARTED:\n          mergePaths([[signalName, true]])\n          break\n        case FINISHED:\n          mergePaths([[signalName, false]])\n          break\n      }\n    }) as EventListener\n    document.addEventListener(DATASTAR_FETCH_EVENT, watcher)\n    return () => {\n      mergePaths([[signalName, false]])\n      document.removeEventListener(DATASTAR_FETCH_EVENT, watcher)\n    }\n  },\n})\n","// Icon: si:json-fill\n// Slug: Outputs a JSON stringified version of signals.\n// Description: Sets the text content of an element to a reactive JSON stringified version of signals.\n\nimport { attribute } from '@engine'\nimport { effect, filtered } from '@engine/signals'\nimport type { SignalFilterOptions } from '@engine/types'\nimport { jsStrToObject } from '@utils/text'\n\nattribute({\n  name: 'json-signals',\n  requirement: {\n    key: 'denied',\n  },\n  apply({ el, value, mods }) {\n    const spaces = mods.has('terse') ? 0 : 2\n    let filters: SignalFilterOptions = {}\n    if (value) {\n      filters = jsStrToObject(value)\n    }\n\n    const callback = () => {\n      observer.disconnect()\n      el.textContent = JSON.stringify(filtered(filters), null, spaces)\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n    const observer = new MutationObserver(callback)\n    const cleanup = effect(callback)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n","export const tagToMs = (args: Set<string>) => {\n  if (!args || args.size <= 0) return 0\n  for (const arg of args) {\n    if (arg.endsWith('ms')) {\n      return +arg.replace('ms', '')\n    }\n    if (arg.endsWith('s')) {\n      return +arg.replace('s', '') * 1000\n    }\n    try {\n      return Number.parseFloat(arg)\n    } catch (_) {}\n  }\n  return 0\n}\n\nexport const tagHas = (\n  tags: Set<string>,\n  tag: string,\n  defaultValue = false,\n) => {\n  if (!tags) return defaultValue\n  return tags.has(tag.toLowerCase())\n}\n\nexport const tagFirst = (tags?: Set<string>, defaultValue = ''): string => {\n  if (tags && tags.size > 0) {\n    for (const tag of tags) {\n      return tag\n    }\n  }\n  return defaultValue\n}\n","import type { EventCallbackHandler, Modifiers } from '@engine/types'\nimport { tagHas, tagToMs } from '@utils/tags'\n\nexport const delay = (\n  callback: EventCallbackHandler,\n  wait: number,\n): EventCallbackHandler => {\n  return (...args: any[]) => {\n    setTimeout(() => {\n      callback(...args)\n    }, wait)\n  }\n}\n\nexport const debounce = (\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = false,\n  trailing = true,\n): EventCallbackHandler => {\n  let timer = 0\n  return (...args: any[]) => {\n    timer && clearTimeout(timer)\n\n    if (leading && !timer) {\n      callback(...args)\n    }\n\n    timer = setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      timer && clearTimeout(timer)\n      timer = 0\n    }, wait)\n  }\n}\n\nexport const throttle = (\n  callback: EventCallbackHandler,\n  wait: number,\n  leading = true,\n  trailing = false,\n): EventCallbackHandler => {\n  let waiting = false\n\n  return (...args: any[]) => {\n    if (waiting) return\n\n    if (leading) {\n      callback(...args)\n    }\n\n    waiting = true\n    setTimeout(() => {\n      if (trailing) {\n        callback(...args)\n      }\n      waiting = false\n    }, wait)\n  }\n}\n\nexport const modifyTiming = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  const delayArgs = mods.get('delay')\n  if (delayArgs) {\n    const wait = tagToMs(delayArgs)\n    callback = delay(callback, wait)\n  }\n\n  const debounceArgs = mods.get('debounce')\n  if (debounceArgs) {\n    const wait = tagToMs(debounceArgs)\n    const leading = tagHas(debounceArgs, 'leading', false)\n    const trailing = !tagHas(debounceArgs, 'notrailing', false)\n    callback = debounce(callback, wait, leading, trailing)\n  }\n\n  const throttleArgs = mods.get('throttle')\n  if (throttleArgs) {\n    const wait = tagToMs(throttleArgs)\n    const leading = !tagHas(throttleArgs, 'noleading', false)\n    const trailing = tagHas(throttleArgs, 'trailing', false)\n    callback = throttle(callback, wait, leading, trailing)\n  }\n\n  return callback\n}\n","import type { EventCallbackHandler, Modifiers } from '@engine/types'\n\nexport const supportsViewTransitions = !!document.startViewTransition\n\nexport const modifyViewTransition = (\n  callback: EventCallbackHandler,\n  mods: Modifiers,\n): EventCallbackHandler => {\n  if (mods.has('viewtransition') && supportsViewTransitions) {\n    const cb = callback // I hate javascript\n    callback = (...args: any[]) =>\n      document.startViewTransition(() => cb(...args))\n  }\n\n  return callback\n}\n","// Icon: material-symbols:mail\n// Slug: Attaches an event listener to an element.\n// Description: Attaches an event listener to an element, executing an expression whenever the event is triggered.\n\nimport { attribute } from '@engine'\nimport {\n  DATASTAR_FETCH_EVENT,\n  DATASTAR_SIGNAL_PATCH_EVENT,\n} from '@engine/consts'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on',\n  requirement: 'must',\n  argNames: ['evt'],\n  apply({ el, key, mods, rx }) {\n    let target: Element | Window | Document = el\n    if (mods.has('window')) target = window\n    let callback = (evt?: Event) => {\n      if (evt) {\n        if (mods.has('prevent')) {\n          evt.preventDefault()\n        }\n        if (mods.has('stop')) {\n          evt.stopPropagation()\n        }\n      }\n      beginBatch()\n      rx(evt)\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const evtListOpts: AddEventListenerOptions = {\n      capture: mods.has('capture'),\n      passive: mods.has('passive'),\n      once: mods.has('once'),\n    }\n    if (mods.has('outside')) {\n      target = document\n      const cb = callback\n      callback = (evt?: Event) => {\n        if (!el.contains(evt?.target as HTMLElement)) {\n          cb(evt)\n        }\n      }\n    }\n    const eventName = modifyCasing(key, mods, 'kebab')\n    // Listen for Datastar events on the document\n    if (\n      eventName === DATASTAR_FETCH_EVENT ||\n      eventName === DATASTAR_SIGNAL_PATCH_EVENT\n    ) {\n      target = document\n    }\n    // Prevent default on form submit events\n    if (el instanceof HTMLFormElement && eventName === 'submit') {\n      const cb = callback\n      callback = (evt?: Event) => {\n        evt?.preventDefault()\n        cb(evt)\n      }\n    }\n    target.addEventListener(eventName, callback, evtListOpts)\n    return () => {\n      target.removeEventListener(eventName, callback)\n    }\n  },\n})\n","// Icon: mdi-light:vector-intersection\n// Slug: Runs an expression on intersection.\n// Description: Runs an expression when the element intersects with the viewport.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport type { HTMLOrSVG } from '@engine/types'\nimport { modifyTiming } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nconst once = new WeakSet<HTMLOrSVG>()\n\nattribute({\n  name: 'on-intersect',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ el, mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    callback = modifyTiming(callback, mods)\n    const options = { threshold: 0 }\n    if (mods.has('full')) {\n      options.threshold = 1\n    } else if (mods.has('half')) {\n      options.threshold = 0.5\n    }\n    let observer: IntersectionObserver | null = new IntersectionObserver(\n      (entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            callback()\n            if (observer && once.has(el)) {\n              observer.disconnect()\n            }\n          }\n        }\n      },\n      options,\n    )\n    observer.observe(el)\n    if (mods.has('once')) {\n      once.add(el)\n    }\n    return () => {\n      if (!mods.has('once')) {\n        once.delete(el)\n      }\n      if (observer) {\n        observer.disconnect()\n        observer = null\n      }\n    }\n  },\n})\n","// Icon: material-symbols:timer-outline\n// Slug: Runs an expression at a regular interval.\n// Description: Runs an expression at a regular interval.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagHas, tagToMs } from '@utils/tags'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'on-interval',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ mods, rx }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let duration = 1000\n    const durationArgs = mods.get('duration')\n    if (durationArgs) {\n      duration = tagToMs(durationArgs)\n      const leading = tagHas(durationArgs, 'leading', false)\n      if (leading) {\n        callback()\n      }\n    }\n    const intervalId = setInterval(callback, duration)\n    return () => {\n      clearInterval(intervalId)\n    }\n  },\n})\n","// Icon: material-symbols:timer-play-outline\n// Slug: Runs an expression when loaded into the DOM.\n// Description: Runs an expression when the element is loaded into the DOM.\n\nimport { attribute } from '@engine'\nimport { beginBatch, endBatch } from '@engine/signals'\nimport { tagToMs } from '@utils/tags'\nimport { delay } from '@utils/timing'\nimport { modifyViewTransition } from '@utils/view-transitions'\n\nattribute({\n  name: 'init',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  apply({ rx, mods }) {\n    let callback = () => {\n      beginBatch()\n      rx()\n      endBatch()\n    }\n    callback = modifyViewTransition(callback, mods)\n    let wait = 0\n    const delayArgs = mods.get('delay')\n    if (delayArgs) {\n      wait = tagToMs(delayArgs)\n      if (wait > 0) {\n        callback = delay(callback, wait)\n      }\n    }\n    callback()\n  },\n})\n","// Icon: material-symbols:change-circle-outline\n// Slug: Runs an expression when signals are patched.\n// Description: Runs an expression whenever one or more signals are patched.\n\nimport { attribute } from '@engine'\nimport { DATASTAR_SIGNAL_PATCH_EVENT } from '@engine/consts'\nimport { beginBatch, endBatch, filtered } from '@engine/signals'\nimport type { JSONPatch, SignalFilterOptions } from '@engine/types'\nimport { isEmpty } from '@utils/paths'\nimport { jsStrToObject } from '@utils/text'\nimport { modifyTiming } from '@utils/timing'\n\nattribute({\n  name: 'on-signal-patch',\n  requirement: {\n    value: 'must',\n  },\n  argNames: ['patch'],\n  returnsValue: true,\n  apply({ el, key, mods, rx, error }) {\n    if (!!key && key !== 'filter') {\n      throw error('KeyNotAllowed')\n    }\n\n    // Look for data-on-signal-patch-filter data attribute\n    const filtersRaw = el.getAttribute('data-on-signal-patch-filter')\n    let filters: SignalFilterOptions = {}\n    if (filtersRaw) {\n      filters = jsStrToObject(filtersRaw)\n    }\n\n    const callback: EventListener = modifyTiming(\n      (evt: CustomEvent<JSONPatch>) => {\n        const watched = filtered(filters, evt.detail)\n        if (!isEmpty(watched)) {\n          beginBatch()\n          rx(watched)\n          endBatch()\n        }\n      },\n      mods,\n    )\n\n    document.addEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    return () => {\n      document.removeEventListener(DATASTAR_SIGNAL_PATCH_EVENT, callback)\n    }\n  },\n})\n","// Icon: mdi:cursor-pointer\n// Slug: Creates a reference to an element.\n// Description: Creates a new signal that is a reference to the element on which the data attribute is placed.\n\nimport { attribute } from '@engine'\nimport { mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'ref',\n  requirement: 'exclusive',\n  apply({ el, key, mods, value }) {\n    const signalName = key != null ? modifyCasing(key, mods) : value\n    mergePaths([[signalName, el]])\n  },\n})\n","// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Shows or hides an element.\n// Description: Shows or hides an element based on whether an expression evaluates to `true` or `false`.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nconst NONE = 'none'\nconst DISPLAY = 'display'\n\nattribute({\n  name: 'show',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      const shouldShow = rx()\n      if (shouldShow) {\n        if (el.style.display === NONE) el.style.removeProperty(DISPLAY)\n      } else {\n        el.style.setProperty(DISPLAY, NONE)\n      }\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n","// Icon: streamline:wifi-signal-full-remix\n// Slug: Patches signals into the existing signals.\n// Description: Patches (adds, updates or removes) one or more signals into the existing signals.\n\nimport { attribute } from '@engine'\nimport { mergePatch, mergePaths } from '@engine/signals'\nimport { modifyCasing } from '@utils/text'\n\nattribute({\n  name: 'signals',\n  returnsValue: true,\n  apply({ key, mods, rx }) {\n    const ifMissing = mods.has('ifmissing')\n\n    if (key) {\n      key = modifyCasing(key, mods)\n      mergePaths([[key, rx?.()]], { ifMissing })\n    } else {\n      const patch = Object.assign({}, rx?.() as Record<string, any>)\n      mergePatch(patch, { ifMissing })\n    }\n  },\n})\n","// Icon: material-symbols:format-paint-outline\n// Slug: Sets inline styles on an element based on an expression.\n// Description: Sets CSS styles on an element using either key-based or object syntax, and keeps them in sync with reactive signals.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\nimport { kebab } from '@utils/text'\n\nattribute({\n  name: 'style',\n  requirement: {\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ key, el, rx }) {\n    const { style } = el\n    const initialStyles = new Map<string, string>()\n\n    const apply = (prop: string, value: any) => {\n      const initial = initialStyles.get(prop)\n      if (!value && value !== 0) {\n        initial !== undefined &&\n          (initial\n            ? style.setProperty(prop, initial)\n            : style.removeProperty(prop))\n      } else {\n        initial === undefined &&\n          initialStyles.set(prop, style.getPropertyValue(prop))\n        style.setProperty(prop, String(value))\n      }\n    }\n\n    const update = () => {\n      observer.disconnect()\n\n      if (key) {\n        apply(key, rx())\n      } else {\n        const styles = rx() as Record<string, any>\n\n        for (const [prop, initial] of initialStyles) {\n          prop in styles ||\n            (initial\n              ? style.setProperty(prop, initial)\n              : style.removeProperty(prop))\n        }\n\n        for (const prop in styles) {\n          apply(kebab(prop), styles[prop])\n        }\n      }\n\n      observer.observe(el, { attributeFilter: ['style'] })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n      for (const [prop, initial] of initialStyles) {\n        initial ? style.setProperty(prop, initial) : style.removeProperty(prop)\n      }\n    }\n  },\n})\n","// Icon: icon-park-outline:text\n// Slug: Binds the text content of an element.\n// Description: Binds the text content of an element to an expression.\n\nimport { attribute } from '@engine'\nimport { effect } from '@engine/signals'\n\nattribute({\n  name: 'text',\n  requirement: {\n    key: 'denied',\n    value: 'must',\n  },\n  returnsValue: true,\n  apply({ el, rx }) {\n    const update = () => {\n      observer.disconnect()\n      el.textContent = `${rx()}`\n      observer.observe(el, {\n        childList: true,\n        characterData: true,\n        subtree: true,\n      })\n    }\n\n    const observer = new MutationObserver(update)\n    const cleanup = effect(update)\n\n    return () => {\n      observer.disconnect()\n      cleanup()\n    }\n  },\n})\n","import { isHTMLOrSVG } from '@utils/dom'\nimport { aliasify } from '@utils/text'\n\nconst ctxIdMap = new Map<Node, Set<string>>()\nconst ctxPersistentIds = new Set<string>()\nconst oldIdTagNameMap = new Map<string, string>()\nconst duplicateIds = new Set<string>()\nconst ctxPantry = document.createElement('div')\nctxPantry.hidden = true\n\nconst aliasedIgnoreMorph = aliasify('ignore-morph')\nconst aliasedIgnoreMorphAttr = `[${aliasedIgnoreMorph}]`\nexport const morph = (\n  oldElt: Element | ShadowRoot,\n  newContent: DocumentFragment | Element,\n  mode: 'outer' | 'inner' = 'outer',\n): void => {\n  if (\n    (isHTMLOrSVG(oldElt) &&\n      isHTMLOrSVG(newContent) &&\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newContent.hasAttribute(aliasedIgnoreMorph)) ||\n    oldElt.parentElement?.closest(aliasedIgnoreMorphAttr)\n  ) {\n    return\n  }\n\n  const normalizedElt = document.createElement('div')\n  normalizedElt.append(newContent)\n  document.body.insertAdjacentElement('afterend', ctxPantry)\n\n  // Computes the set of IDs that persist between the two contents excluding duplicates\n  const oldIdElements = oldElt.querySelectorAll('[id]')\n  for (const { id, tagName } of oldIdElements) {\n    if (oldIdTagNameMap.has(id)) {\n      duplicateIds.add(id)\n    } else {\n      oldIdTagNameMap.set(id, tagName)\n    }\n  }\n  if (oldElt instanceof Element && oldElt.id) {\n    if (oldIdTagNameMap.has(oldElt.id)) {\n      duplicateIds.add(oldElt.id)\n    } else {\n      oldIdTagNameMap.set(oldElt.id, oldElt.tagName)\n    }\n  }\n\n  ctxPersistentIds.clear()\n  const newIdElements = normalizedElt.querySelectorAll('[id]')\n  for (const { id, tagName } of newIdElements) {\n    if (ctxPersistentIds.has(id)) {\n      duplicateIds.add(id)\n    } else if (oldIdTagNameMap.get(id) === tagName) {\n      ctxPersistentIds.add(id)\n    }\n  }\n\n  for (const id of duplicateIds) {\n    ctxPersistentIds.delete(id)\n  }\n\n  oldIdTagNameMap.clear()\n  duplicateIds.clear()\n  ctxIdMap.clear()\n\n  const parent = mode === 'outer' ? oldElt.parentElement! : oldElt\n  populateIdMapWithTree(parent, oldIdElements)\n  populateIdMapWithTree(normalizedElt, newIdElements)\n\n  morphChildren(\n    parent,\n    normalizedElt,\n    mode === 'outer' ? oldElt : null,\n    oldElt.nextSibling,\n  )\n\n  ctxPantry.remove()\n}\n\n// This is the core algorithm for matching up children.\n// The idea is to use ID sets to try to match up nodes as faithfully as possible.\n// We greedily match, which allows us to keep the algorithm fast,\n// but by using ID sets, we are able to better match up with content deeper in the DOM.\nconst morphChildren = (\n  oldParent: Element | ShadowRoot, // the old content that we are merging the new content into\n  newParent: Element, // the parent element of the new content\n  insertionPoint: Node | null = null, // the point in the DOM we start morphing at (defaults to first child)\n  endPoint: Node | null = null, // the point in the DOM we stop morphing at (defaults to after last child)\n): void => {\n  // normalize\n  if (\n    oldParent instanceof HTMLTemplateElement &&\n    newParent instanceof HTMLTemplateElement\n  ) {\n    // we can pretend the DocumentElement is an Element\n    oldParent = oldParent.content as unknown as Element\n    newParent = newParent.content as unknown as Element\n  }\n  insertionPoint ??= oldParent.firstChild\n\n  // run through all the new content\n  for (const newChild of newParent.childNodes) {\n    // once we reach the end of the old parent content skip to the end and insert the rest\n    if (insertionPoint && insertionPoint !== endPoint) {\n      const bestMatch = findBestMatch(newChild, insertionPoint, endPoint)\n      if (bestMatch) {\n        // if the node to morph is not at the insertion point then remove/move up to it\n        if (bestMatch !== insertionPoint) {\n          let cursor: Node | null = insertionPoint\n          // Remove nodes between the start and end nodes\n          while (cursor && cursor !== bestMatch) {\n            const tempNode = cursor\n            cursor = cursor.nextSibling\n            removeNode(tempNode)\n          }\n        }\n        morphNode(bestMatch, newChild)\n        insertionPoint = bestMatch.nextSibling\n        continue\n      }\n    }\n\n    // if the matching node is elsewhere in the original content\n    if (newChild instanceof Element && ctxPersistentIds.has(newChild.id)) {\n      // move it and all its children here and morph, will always be found\n      // Search for an element by ID within the document and pantry, and move it using moveBefore.\n      const movedChild = document.getElementById(newChild.id) as Element\n\n      // Removes an element from its ancestors' ID maps.\n      // This is needed when an element is moved from the \"future\" via `moveBeforeId`.\n      // Otherwise, its erstwhile ancestors could be mistakenly moved to the pantry rather than being deleted,\n      // preventing their removal hooks from being called.\n      let current = movedChild\n      while ((current = current.parentNode as Element)) {\n        const idSet = ctxIdMap.get(current)\n        if (idSet) {\n          idSet.delete(newChild.id)\n          if (!idSet.size) {\n            ctxIdMap.delete(current)\n          }\n        }\n      }\n\n      moveBefore(oldParent, movedChild, insertionPoint)\n      morphNode(movedChild, newChild)\n      insertionPoint = movedChild.nextSibling\n      continue\n    }\n\n    // This performs the action of inserting a new node while handling situations where the node contains\n    // elements with persistent IDs and possible state info we can still preserve by moving in and then morphing\n    if (ctxIdMap.has(newChild)) {\n      // node has children with IDs with possible state so create a dummy elt of same type and apply full morph algorithm\n      const newEmptyChild = document.createElement(\n        (newChild as Element).tagName,\n      )\n      oldParent.insertBefore(newEmptyChild, insertionPoint)\n      morphNode(newEmptyChild, newChild)\n      insertionPoint = newEmptyChild.nextSibling\n    } else {\n      // optimization: no id state to preserve so we can just insert a clone of the newChild and its descendants\n      const newClonedChild = document.importNode(newChild, true) // importNode to not mutate newParent\n      oldParent.insertBefore(newClonedChild, insertionPoint)\n      insertionPoint = newClonedChild.nextSibling\n    }\n  }\n\n  // remove any remaining old nodes that didn't match up with new content\n  while (insertionPoint && insertionPoint !== endPoint) {\n    const tempNode = insertionPoint\n    insertionPoint = insertionPoint.nextSibling\n    removeNode(tempNode)\n  }\n}\n\n// Scans forward from the startPoint to the endPoint looking for a match for the node.\n// It looks for an id set match first, then a soft match.\n// We abort soft matching if we find two future soft matches, to reduce churn.\nconst findBestMatch = (\n  node: Node,\n  startPoint: Node | null,\n  endPoint: Node | null,\n): Node | null => {\n  let bestMatch: Node | null | undefined = null\n  let nextSibling = node.nextSibling\n  let siblingSoftMatchCount = 0\n  let displaceMatchCount = 0\n\n  // Max ID matches we are willing to displace in our search\n  const nodeMatchCount = ctxIdMap.get(node)?.size || 0\n\n  let cursor = startPoint\n  while (cursor && cursor !== endPoint) {\n    // soft matching is a prerequisite for id set matching\n    if (isSoftMatch(cursor, node)) {\n      let isIdSetMatch = false\n      const oldSet = ctxIdMap.get(cursor)\n      const newSet = ctxIdMap.get(node)\n\n      if (newSet && oldSet) {\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            isIdSetMatch = true\n            break\n          }\n        }\n      }\n\n      if (isIdSetMatch) {\n        return cursor // found an id set match, we're done!\n      }\n\n      // we havenâ€™t yet saved a soft match fallback\n      // the current soft match will hard match something else in the future, leave it\n      if (!bestMatch && !ctxIdMap.has(cursor)) {\n        // optimization: if node can't id set match, we can just return the soft match immediately\n        if (!nodeMatchCount) {\n          return cursor\n        }\n        // save this as the fallback if we get through the loop without finding a hard match\n        bestMatch = cursor\n      }\n    }\n\n    // check for IDs we may be displaced when matching\n    displaceMatchCount += ctxIdMap.get(cursor)?.size || 0\n    if (displaceMatchCount > nodeMatchCount) {\n      // if we are going to displace more IDs than the node contains then\n      // we do not have a good candidate for an ID match, so return\n      break\n    }\n\n    if (bestMatch === null && nextSibling && isSoftMatch(cursor, nextSibling)) {\n      // The next new node has a soft match with this node, so\n      // increment the count of future soft matches\n      siblingSoftMatchCount++\n      nextSibling = nextSibling.nextSibling\n\n      // If there are two future soft matches, block soft matching for this node to allow\n      // future siblings to soft match. This is to reduce churn in the DOM when an element\n      // is prepended.\n      if (siblingSoftMatchCount >= 2) {\n        bestMatch = undefined\n      }\n    }\n\n    cursor = cursor.nextSibling\n  }\n\n  return bestMatch || null\n}\n\n// ok to cast: if one is not element, `id` and `tagName` will be null and we'll just compare that.\nconst isSoftMatch = (oldNode: Node, newNode: Node): boolean =>\n  oldNode.nodeType === newNode.nodeType &&\n  (oldNode as Element).tagName === (newNode as Element).tagName &&\n  // If oldElt has an `id` with possible state and it doesnâ€™t match newElt.id then avoid morphing.\n  // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n  // its not persistent, and new nodes can't have any hidden state.\n  (!(oldNode as Element).id ||\n    (oldNode as Element).id === (newNode as Element).id)\n\n// Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n// - Persistent nodes will be moved to the pantry for later reuse\n// - Other nodes will have their hooks called, and then are removed\nconst removeNode = (node: Node): void => {\n  // are we going to id set match this later?\n  ctxIdMap.has(node)\n    ? // skip callbacks and move to pantry\n      moveBefore(ctxPantry, node, null)\n    : // remove for realsies\n      node.parentNode?.removeChild(node)\n}\n\n// Moves an element before another element within the same parent.\n// Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n// This is essentially a forward-compat wrapper.\nconst moveBefore: (parentNode: Node, node: Node, after: Node | null) => void =\n  // @ts-expect-error\n  removeNode.call.bind(ctxPantry.moveBefore ?? ctxPantry.insertBefore)\n\nconst aliasedPreserveAttr = aliasify('preserve-attr')\n\n// syncs the oldNode to the newNode, copying over all attributes and\n// inner element state from the newNode to the oldNode\nconst morphNode = (\n  oldNode: Node, // root node to merge content into\n  newNode: Node, // new content to merge\n): Node => {\n  const type = newNode.nodeType\n\n  // if is an element type, sync the attributes from the\n  // new node into the new node\n  if (type === 1 /* element type */) {\n    const oldElt = oldNode as Element\n    const newElt = newNode as Element\n    if (\n      oldElt.hasAttribute(aliasedIgnoreMorph) &&\n      newElt.hasAttribute(aliasedIgnoreMorph)\n    ) {\n      return oldNode\n    }\n\n    //  many bothans died to bring us this information:\n    //  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n    //  https://github.com/choojs/nanomorph/blob/master/lib/morph.js#L113\n    if (\n      oldElt instanceof HTMLInputElement &&\n      newElt instanceof HTMLInputElement &&\n      newElt.type !== 'file'\n    ) {\n      // https://github.com/bigskysoftware/idiomorph/issues/27\n      // | old input value | new input value  | behaviour                              |\n      // | --------------- | ---------------- | -------------------------------------- |\n      // | `null`          | `null`           | preserve old input value               |\n      // | some value      | the same value   | preserve old input value               |\n      // | some value      | `null`           | set old input value to `\"\"`            |\n      // | `null`          | some value       | set old input value to new input value |\n      // | some value      | some other value | set old input value to new input value |\n      if (newElt.getAttribute('value') !== oldElt.getAttribute('value')) {\n        oldElt.value = newElt.getAttribute('value') ?? ''\n      }\n    } else if (\n      oldElt instanceof HTMLTextAreaElement &&\n      newElt instanceof HTMLTextAreaElement\n    ) {\n      if (newElt.value !== oldElt.value) {\n        oldElt.value = newElt.value\n      }\n      if (oldElt.firstChild && oldElt.firstChild.nodeValue !== newElt.value) {\n        oldElt.firstChild.nodeValue = newElt.value\n      }\n    }\n\n    const preserveAttrs = (\n      (newNode as HTMLElement).getAttribute(aliasedPreserveAttr) ?? ''\n    ).split(' ')\n\n    for (const { name, value } of newElt.attributes) {\n      if (\n        oldElt.getAttribute(name) !== value &&\n        !preserveAttrs.includes(name)\n      ) {\n        oldElt.setAttribute(name, value)\n      }\n    }\n\n    for (let i = oldElt.attributes.length - 1; i >= 0; i--) {\n      const { name } = oldElt.attributes[i]!\n      if (!newElt.hasAttribute(name) && !preserveAttrs.includes(name)) {\n        oldElt.removeAttribute(name)\n      }\n    }\n\n    if (!oldElt.isEqualNode(newElt)) {\n      morphChildren(oldElt, newElt)\n    }\n  }\n\n  if (type === 8 /* comment */ || type === 3 /* text */) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  return oldNode\n}\n\n// A bottom-up algorithm that populates a map of Element -> IdSet.\n// The ID set for a given element is the set of all IDs contained within its subtree.\n// As an optimization, we filter these IDs through the given list of persistent IDs,\n// because we don't need to bother considering IDed elements that won't be in the new content.\nconst populateIdMapWithTree = (\n  root: Element | ShadowRoot | null,\n  elements: Iterable<Element>,\n): void => {\n  for (const elt of elements) {\n    if (ctxPersistentIds.has(elt.id)) {\n      let current: Element | null = elt\n      // walk up the parent hierarchy of that element, adding the ID of element to the parent's ID set\n      while (current && current !== root) {\n        let idSet = ctxIdMap.get(current)\n        // if the ID set doesnâ€™t exist, create it and insert it in the map\n        if (!idSet) {\n          idSet = new Set()\n          ctxIdMap.set(current, idSet)\n        }\n        idSet.add(elt.id)\n        current = current.parentElement\n      }\n    }\n  }\n}\n","// Icon: material-symbols:cloud-download\n// Slug: Patches elements into the DOM.\n// Description: Patches elements into the DOM.\n\nimport { watcher } from '@engine'\nimport type { WatcherContext } from '@engine/types'\nimport { morph } from '@engine/morph'\nimport { supportsViewTransitions } from '@utils/view-transitions'\n\ntype PatchElementsMode =\n  | 'remove'\n  | 'outer'\n  | 'inner'\n  | 'replace'\n  | 'prepend'\n  | 'append'\n  | 'before'\n  | 'after'\n\ntype PatchElementsArgs = {\n  elements: string\n  mode: PatchElementsMode\n  selector: string\n  useViewTransition: boolean\n}\n\nwatcher({\n  name: 'datastar-patch-elements',\n  apply(\n    ctx,\n    { elements = '', selector = '', mode = 'outer', useViewTransition },\n  ) {\n    switch (mode) {\n      case 'remove':\n      case 'outer':\n      case 'inner':\n      case 'replace':\n      case 'prepend':\n      case 'append':\n      case 'before':\n      case 'after':\n        break\n      default:\n        throw ctx.error('PatchElementsInvalidMode', { mode })\n    }\n\n    if (!selector && mode !== 'outer' && mode !== 'replace') {\n      throw ctx.error('PatchElementsExpectedSelector')\n    }\n\n    const args2: PatchElementsArgs = {\n      mode,\n      selector,\n      elements,\n      useViewTransition: useViewTransition?.trim() === 'true',\n    }\n\n    if (supportsViewTransitions && useViewTransition) {\n      document.startViewTransition(() => onPatchElements(ctx, args2))\n    } else {\n      onPatchElements(ctx, args2)\n    }\n  },\n})\n\nconst onPatchElements = (\n  { error }: WatcherContext,\n  { elements, selector, mode }: PatchElementsArgs,\n) => {\n  const elementsWithSvgsRemoved = elements.replace(\n    /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n    '',\n  )\n  const hasHtml = /<\\/html>/.test(elementsWithSvgsRemoved)\n  const hasHead = /<\\/head>/.test(elementsWithSvgsRemoved)\n  const hasBody = /<\\/body>/.test(elementsWithSvgsRemoved)\n\n  const newDocument = new DOMParser().parseFromString(\n    hasHtml || hasHead || hasBody\n      ? elements\n      : `<body><template>${elements}</template></body>`,\n    'text/html',\n  )\n\n  let newContent = document.createDocumentFragment()\n  if (hasHtml) {\n    newContent.appendChild(newDocument.documentElement)\n  } else if (hasHead && hasBody) {\n    newContent.appendChild(newDocument.head)\n    newContent.appendChild(newDocument.body)\n  } else if (hasHead) {\n    newContent.appendChild(newDocument.head)\n  } else if (hasBody) {\n    newContent.appendChild(newDocument.body)\n  } else {\n    newContent = newDocument.querySelector('template')!.content\n  }\n\n  if (!selector && (mode === 'outer' || mode === 'replace')) {\n    for (const child of newContent.children) {\n      let target: Element\n      if (child instanceof HTMLHtmlElement) {\n        target = document.documentElement\n      } else if (child instanceof HTMLBodyElement) {\n        target = document.body\n      } else if (child instanceof HTMLHeadElement) {\n        target = document.head\n      } else {\n        target = document.getElementById(child.id)!\n        if (!target) {\n          console.warn(error('PatchElementsNoTargetsFound'), {\n            element: { id: child.id },\n          })\n          continue\n        }\n      }\n\n      applyToTargets(mode as PatchElementsMode, child, [target])\n    }\n  } else {\n    const targets = document.querySelectorAll(selector)\n    if (!targets.length) {\n      console.warn(error('PatchElementsNoTargetsFound'), { selector })\n      return\n    }\n\n    applyToTargets(mode as PatchElementsMode, newContent, targets)\n  }\n}\n\nconst scripts = new WeakSet<HTMLScriptElement>()\nfor (const script of document.querySelectorAll('script')) {\n  scripts.add(script)\n}\n\nconst execute = (target: Element): void => {\n  const elScripts =\n    target instanceof HTMLScriptElement\n      ? [target]\n      : target.querySelectorAll('script')\n  for (const old of elScripts) {\n    if (!scripts.has(old)) {\n      const script = document.createElement('script')\n      for (const { name, value } of old.attributes) {\n        script.setAttribute(name, value)\n      }\n      script.text = old.text\n      old.replaceWith(script)\n      scripts.add(script)\n    }\n  }\n}\n\nconst applyPatchMode = (\n  targets: Iterable<Element>,\n  element: DocumentFragment | Element,\n  action: string,\n) => {\n  for (const target of targets) {\n    const cloned = element.cloneNode(true) as Element\n    execute(cloned)\n    // @ts-expect-error\n    target[action](cloned)\n  }\n}\n\nconst applyToTargets = (\n  mode: PatchElementsMode,\n  element: DocumentFragment | Element,\n  targets: Iterable<Element>,\n) => {\n  switch (mode) {\n    case 'remove':\n      for (const target of targets) {\n        target.remove()\n      }\n      break\n    case 'outer':\n    case 'inner':\n      for (const target of targets) {\n        morph(target, element.cloneNode(true) as Element, mode)\n        execute(target)\n      }\n      break\n    case 'replace':\n      applyPatchMode(targets, element, 'replaceWith')\n      break\n    case 'prepend':\n    case 'append':\n    case 'before':\n    case 'after':\n      applyPatchMode(targets, element, mode)\n  }\n}\n","// Icon: material-symbols:settings-input-antenna\n// Slug: Patches signals.\n// Description: Patches signals.\n\nimport { watcher } from '@engine'\nimport { mergePatch } from '@engine/signals'\nimport { jsStrToObject } from '@utils/text'\n\nwatcher({\n  name: 'datastar-patch-signals',\n  apply({ error }, { signals, onlyIfMissing }) {\n    if (signals) {\n      const ifMissing = onlyIfMissing?.trim() === 'true'\n      mergePatch(jsStrToObject(signals), { ifMissing })\n    } else {\n      throw error('PatchSignalsExpectedSignals')\n    }\n  },\n})\n","// Icon: material-symbols:send\n// Slug: Dispatches custom browser events for component communication.\n// Description: Dispatches CustomEvents globally or to specific elements, enabling event-driven reactive patterns like Livewire.\n\nimport { action } from '@engine'\n\n/**\n * Dispatch Action - Event Communication System\n *\n * Mirrors Livewire's dispatch system, enabling both frontend and backend\n * to trigger custom events for component communication.\n *\n * Usage:\n * @dispatch('event-name')                                  // Global dispatch\n * @dispatch('event-name', {data: 'value'})                // With data\n * @dispatch('event-name', {id: 123}, {selector: '#target'}) // Targeted\n *\n * Options:\n * - selector: CSS selector for targeted dispatch (multiple elements supported)\n * - window: Force window dispatch (default: true if no selector)\n * - bubbles: Event bubbles (default: true)\n * - cancelable: Event can be canceled (default: true)\n * - composed: Event composes through shadow DOM (default: true)\n */\naction({\n    name: 'dispatch',\n    apply: (\n        { el },\n        eventName: string,\n        data?: any,\n        options?: {\n            selector?: string\n            window?: boolean\n            bubbles?: boolean\n            cancelable?: boolean\n            composed?: boolean\n        }\n    ) => {\n        // Validate event name\n        if (!eventName || typeof eventName !== 'string') {\n            console.error(\n                '[Hyper Dispatch] Invalid event name. Must be a non-empty string.',\n                { eventName }\n            )\n            return\n        }\n\n        // Default options\n        const opts = {\n            selector: options?.selector,\n            window: options?.window ?? (!options?.selector), // Default to window if no selector\n            bubbles: options?.bubbles ?? true,\n            cancelable: options?.cancelable ?? true,\n            composed: options?.composed ?? true,\n        }\n\n        // Create CustomEvent\n        const event = new CustomEvent(eventName, {\n            detail: data || {},\n            bubbles: opts.bubbles,\n            cancelable: opts.cancelable,\n            composed: opts.composed,\n        })\n\n        // Targeted dispatch\n        if (opts.selector) {\n            const targets = document.querySelectorAll(opts.selector)\n\n            if (targets.length === 0) {\n                console.warn(\n                    `[Hyper Dispatch] No elements found for selector: ${opts.selector}`,\n                    { eventName, selector: opts.selector }\n                )\n                return\n            }\n\n            targets.forEach((target) => {\n                target.dispatchEvent(new CustomEvent(eventName, {\n                    detail: data || {},\n                    bubbles: opts.bubbles,\n                    cancelable: opts.cancelable,\n                    composed: opts.composed,\n                }))\n            })\n\n            return\n        }\n\n        // Global dispatch (window)\n        if (opts.window) {\n            window.dispatchEvent(event)\n            return\n        }\n\n        // Element dispatch (fallback to current element)\n        el.dispatchEvent(event)\n    },\n})\n","// Icon: material-symbols:attachment\n// Slug: Converts file sources to valid HTML src/href URLs with smart fallbacks.\n// Description: Handles base64 arrays from file binding and provides fallbacks. File paths are auto-converted by Laravel backend.\n\nimport { action } from '@engine'\nimport type { ActionContext } from '@engine/types'\n\n/**\n * FileUrl Action - Simplified and Reliable\n *\n * Now much simpler since Laravel handles path-to-URL conversion.\n * Frontend only needs to handle:\n * - Base64 arrays from Datastar file inputs\n * - URLs (already converted by Laravel)\n * - Fallbacks for missing/empty data\n *\n * Usage Examples:\n * @fileUrl($profilePicture)                           // Auto-detect with fallback\n * @fileUrl($document, {fallback: '/default.pdf'})     // Custom fallback\n * @fileUrl('/storage/file.jpg')                       // URL passthrough\n * @fileUrl($avatar, {defaultMime: 'image/png'})       // Custom MIME for base64\n */\naction({\n    name: 'fileUrl',\n    apply: (\n        _ctx: ActionContext,\n        fileSource: any,\n        options?: {\n            fallback?: string\n            defaultMime?: string\n            mimeSignal?: string // Name of companion MIME signal\n        }\n    ): string => {\n        const opts = options || {}\n        const fallback = opts.fallback || ''\n        const defaultMime = opts.defaultMime || 'application/octet-stream'\n        const mimeSignal = opts.mimeSignal\n\n        // Handle null, undefined, or empty values\n        if (fileSource == null) {\n            return fallback\n        }\n\n        // Handle arrays (from Datastar file binding)\n        if (Array.isArray(fileSource)) {\n            // Empty array means no file selected\n            if (fileSource.length === 0) {\n                return fallback\n            }\n\n            const firstItem = fileSource[0]\n\n            // RC6 Format: Array of {name, contents, mime} objects\n            if (typeof firstItem === 'object' && firstItem !== null && 'contents' in firstItem) {\n                const { contents, mime } = firstItem as { contents: string; mime: string; name?: string }\n\n                // Validate contents\n                if (!contents || typeof contents !== 'string') {\n                    return fallback\n                }\n\n                // Use MIME from object (RC6 provides it automatically)\n                const mimeType = mime || defaultMime\n\n                // Construct data URL\n                return `data:${mimeType};base64,${contents}`\n            }\n\n            // Legacy Format: Array of base64 strings (for backward compatibility)\n            const base64Content = firstItem\n            if (!base64Content || typeof base64Content !== 'string') {\n                return fallback\n            }\n\n            // Determine MIME type\n            let mimeType = defaultMime\n\n            // Try to get MIME from companion signal if specified\n            if (mimeSignal && typeof window !== 'undefined') {\n                const mimeArray = ((window as any).$ || {})[mimeSignal]\n                if (Array.isArray(mimeArray) && mimeArray.length > 0) {\n                    mimeType = mimeArray[0] || defaultMime\n                }\n            }\n\n            // Construct data URL\n            return `data:${mimeType};base64,${base64Content}`\n        }\n\n        // Handle strings (URLs, paths, data URLs)\n        if (typeof fileSource === 'string') {\n            const trimmed = fileSource.trim()\n\n            // Empty string\n            if (!trimmed) {\n                return fallback\n            }\n\n            // Laravel should have converted file paths to proper URLs\n            // We just return whatever string we got\n            return trimmed\n        }\n\n        // Handle unexpected types gracefully\n        if (typeof fileSource === 'object') {\n            console.warn(\n                'FileUrl action received unexpected object:',\n                fileSource\n            )\n        }\n\n        return fallback\n    },\n})\n","// Icon: material-symbols:arrow-back\n// Slug: Navigate back with fallback support\n// Description: Convenience action for going back to previous page or fallback URL\n\nimport { action, actions } from '@engine'\nimport type { ActionContext } from '@engine/types'\n\n/**\n * Back Action - Navigate to Previous Page\n *\n * Convenience action for navigating back in browser history.\n * Falls back to a specified URL if no referrer available.\n *\n * USAGE EXAMPLES:\n *\n * @back()                          // Go back or to '/'\n * @back('/dashboard')              // Go back or to '/dashboard'\n * @back('/home', 'back')           // With custom navigation key\n * @back('/home', 'back', {merge: true})  // With options\n */\naction({\n    name: 'back',\n    apply: async (\n        ctx: ActionContext,\n        fallback: string = '/',\n        key: string = 'back',\n        options: Record<string, any> = {}\n    ): Promise<void> => {\n        // Determine the back URL\n        let backUrl = fallback\n\n        // Try to get the previous URL from browser history\n        if (\n            document.referrer &&\n            document.referrer !== window.location.href\n        ) {\n            try {\n                const referrerUrl = new URL(document.referrer)\n                const currentUrl = new URL(window.location.href)\n\n                // Only use referrer if it's from the same origin\n                if (referrerUrl.origin === currentUrl.origin) {\n                    backUrl = document.referrer\n                }\n            } catch (error) {\n                console.warn('Error parsing referrer URL:', error)\n                // Use fallback\n            }\n        }\n\n        // Call @navigate action\n        const navigateAction = actions.navigate\n\n        if (navigateAction) {\n            await navigateAction(ctx, backUrl, key, {\n                merge: true, // Default to merge for back navigation\n                ...options,\n            })\n        } else {\n            console.error('Navigate action not found. Falling back to location.href')\n            window.location.href = backUrl\n        }\n    },\n})\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Basic usage - go back or to home\n * <button data-on:click=\"@back()\">Back</button>\n *\n * // With custom fallback\n * <button data-on:click=\"@back('/dashboard')\">Back to Dashboard</button>\n *\n * // With navigation key (for targeted updates)\n * <button data-on:click=\"@back('/home', 'navigation')\">Back</button>\n *\n * // With options\n * <button data-on:click=\"@back('/home', 'back', {merge: false})\">\n *     Back (Clean)\n * </button>\n */\n","// Icon: material-symbols:refresh\n// Slug: Refresh current page reactively\n// Description: Convenience action for refreshing the current page using Datastar navigation\n\nimport { action, actions } from '@engine'\nimport type { ActionContext } from '@engine/types'\n\n/**\n * Refresh Action - Reactive Page Refresh\n *\n * Convenience action for refreshing the current page using Datastar navigation\n * (not a full page reload). Preserves reactive state and uses SSE updates.\n *\n * USAGE EXAMPLES:\n *\n * @refresh()                        // Refresh current page (merge by default)\n * @refresh('refresh')               // With custom navigation key\n * @refresh('refresh', {merge: false})  // Refresh without merging query params\n */\naction({\n    name: 'refresh',\n    apply: async (\n        ctx: ActionContext,\n        key: string = 'refresh',\n        options: Record<string, any> = {}\n    ): Promise<void> => {\n        // Get current URL\n        const currentUrl = window.location.href\n\n        // Call @navigate action with current URL\n        const navigateAction = actions.navigate\n\n        if (navigateAction) {\n            await navigateAction(ctx, currentUrl, key, {\n                merge: true, // Default to merge for refresh\n                replace: true, // Replace history entry (don't add new)\n                ...options,\n            })\n        } else {\n            console.error('Navigate action not found. Falling back to location.reload')\n            window.location.reload()\n        }\n    },\n})\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Basic refresh - updates current page reactively\n * <button data-on:click=\"@refresh()\">Refresh</button>\n *\n * // With custom navigation key (for targeted updates)\n * <button data-on:click=\"@refresh('stats')\">Refresh Stats</button>\n *\n * // Clean refresh (no query param merging)\n * <button data-on:click=\"@refresh('refresh', {merge: false})\">\n *     Clean Refresh\n * </button>\n *\n * // Polling pattern\n * <div data-on-interval__duration.5s=\"@refresh('poll')\">\n *     Auto-refreshing content\n * </div>\n */\n","// Icon: material-symbols:restart-alt\n// Slug: Force full page reload\n// Description: Hard refresh that discards all client state and reloads the page completely\n\nimport { action } from '@engine'\nimport type { ActionContext } from '@engine/types'\n\n/**\n * Reload Action - Hard Page Refresh\n *\n * Forces a complete page reload, discarding all client-side state.\n * This breaks out of the reactive mode and performs a traditional full page load.\n *\n * Use when you need to completely reset the application state or when\n * reactive updates are insufficient (e.g., after major configuration changes).\n *\n * USAGE EXAMPLES:\n *\n * @reload()                         // Force full page reload\n */\naction({\n    name: 'reload',\n    apply: (_ctx: ActionContext): void => {\n        // Perform hard refresh\n        // This is equivalent to the browser's refresh button (F5)\n        window.location.reload()\n    },\n})\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Full page reload (discards all state)\n * <button data-on:click=\"@reload()\">\n *     Reload Page\n * </button>\n *\n * // Use after settings change\n * <button data-on:click=\"@postx('/settings').then(() => @reload())\">\n *     Save & Reload\n * </button>\n *\n * // Emergency reset\n * <button data-on:click=\"@reload()\" class=\"text-red-500\">\n *     Reset Everything\n * </button>\n */\n","// Icon: material-symbols:error-outline\n// Slug: Shows validation error for a field.\n// Description: Displays the first validation error message for a specified field from the errors signal.\n\nimport { attribute } from '@engine'\nimport { effect, computed, getPath, mergePatch } from '@engine/signals'\n\nattribute({\n    name: 'error',\n    requirement: {\n        key: 'denied',\n        value: 'must',\n    },\n    apply({ el, value }) {\n        const fieldName = value.trim()\n\n        // Ensure the 'errors' signal exists and is initialized as an empty object\n        // This works like the signals plugin - creates the signal if missing\n        mergePatch({ errors: {} }, { ifMissing: true })\n\n        // Create a computed that reactively reads the error for this field\n        const errorComputed = computed(() => {\n            const errors = getPath('errors')\n            if (errors && errors[fieldName]) {\n                const fieldErrors = errors[fieldName]\n                if (Array.isArray(fieldErrors) && fieldErrors.length > 0) {\n                    return fieldErrors[0]\n                } else if (typeof fieldErrors === 'string') {\n                    return fieldErrors\n                }\n            }\n            return null\n        })\n\n        // Effect that updates the DOM when the error changes\n        const cleanup = effect(() => {\n            const errorMessage = errorComputed()\n\n            if (errorMessage) {\n                el.style.removeProperty('display')\n                el.textContent = errorMessage\n            } else {\n                el.style.setProperty('display', 'none')\n                el.textContent = ''\n            }\n        })\n\n        return cleanup\n    },\n})\n","// Icon: material-symbols:repeat\n// Slug: Iterates over an array or object with efficient diffing.\n// Description: Production-ready loop directive with keyed diffing, zero signal pollution, and full Datastar reactivity integration.\n\nimport { attribute, apply } from '@engine'\nimport { effect, getPath, mergePatch, root, beginBatch, endBatch, startPeeking, stopPeeking } from '@engine/signals'\nimport type { HTMLOrSVG } from '@engine/types'\n\n/**\n * ARCHITECTURE: Clean Loop Implementation\n *\n * PRINCIPLES:\n * 1. NO SIGNAL POLLUTION - Only source signals exist (e.g., $users)\n * 2. Direct mapping: iterator \"user\" â†’ source path \"users.0\", \"users.1\", etc.\n * 3. Datastar's Proxy-based reactivity handles all property mutations\n * 4. Keyed diffing reuses DOM elements, retransforming indices on position changes\n * 5. Efficient change detection: no-change, simple-add, simple-remove, complex\n */\n\ninterface IterationState {\n    prevKeys: any[];\n    lookup: Map<any, LoopElement>;\n    template: HTMLTemplateElement;\n    templateContent: DocumentFragment;\n    iteratorNames: ParsedExpression;\n    keyExpression: string | null;\n    effectCleanup: (() => void) | null;\n    sourceSignalPath: string;\n    isNormalized: boolean;\n    iterationId: string;\n}\n\ninterface LoopElement {\n    el: HTMLOrSVG;\n    key: any;\n    index: number;\n}\n\ninterface ParsedExpression {\n    item: string;\n    index?: string;\n    collection?: string;\n    items: string;\n}\n\nconst iterationStates = new WeakMap<HTMLOrSVG, IterationState>()\n\n// Helper function to peek without tracking\nconst peek = (fn: () => void) => {\n    startPeeking()\n    try {\n        fn()\n    } finally {\n        stopPeeking()\n    }\n}\n\nattribute({\n    name: 'for',\n    requirement: {\n        key: 'denied',\n        value: 'must',\n    },\n    apply(ctx) {\n        const { el, value, mods, error } = ctx\n\n        // Validate template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw error('ForMustBeOnTemplate', {\n                message: 'data-for must be used on <template> elements',\n            })\n        }\n\n        // Parse expression: \"user in $users\", \"[name, email] in $users\", \"item, index in $items\"\n        const parsed = parseExpression(value)\n        if (!parsed) {\n            throw error('InvalidForExpression', {\n                expression: value,\n                expected: 'Format: \"item in $items\", \"[name, age] in $users\", \"item, index in $items\"',\n            })\n        }\n\n        // Get key expression from data-for__key modifier\n        const keyMod = mods.get('key')\n        const keyExpression = keyMod && keyMod.size > 0 ? Array.from(keyMod)[0] : null\n\n        // Setup\n        const template = el as HTMLTemplateElement\n        template.style.display = 'none'\n        const templateContent = template.content.cloneNode(true) as DocumentFragment\n\n        const sourceSignalPath = parsed.items\n        const sourceData = getPath(sourceSignalPath)\n        const isNormalized = shouldNormalizeData(sourceData)\n\n        // Generate unique iteration ID for this data-for instance\n        const iterationId = `__for_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n        const state: IterationState = {\n            prevKeys: [],\n            lookup: new Map(),\n            template,\n            templateContent,\n            iteratorNames: parsed,\n            keyExpression,\n            effectCleanup: null,\n            sourceSignalPath,\n            isNormalized,\n            iterationId,\n        }\n\n        iterationStates.set(el, state)\n\n        // Create reactive effect that tracks source signal\n        const effectCleanup = effect(() => {\n            // Access source signal reactively through getPath\n            // This properly triggers Datastar's reactive tracking\n            const sourceData = getPath(sourceSignalPath)\n\n            // For arrays, track structure changes AND deep properties (for objects only)\n            if (Array.isArray(sourceData)) {\n                const reactiveArray = root[sourceSignalPath]\n\n                // Track deep properties ONLY for object items (not primitives)\n                // This enables reactive updates like: $users[0].name = 'New Name'\n                if (reactiveArray && reactiveArray.length > 0) {\n                    const firstItem = reactiveArray[0]\n                    // Only track deep if items are objects (not strings/numbers)\n                    if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                        for (const key in reactiveArray) {\n                            const item = reactiveArray[key]\n                            void item // Track array structure\n                            // Track all object properties for reactivity\n                            if (item && typeof item === 'object') {\n                                for (const prop in item) {\n                                    void item[prop]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            const items = normalizeData(sourceData)\n\n            const newArrayWithKeys = items.map((item, index) => ({\n                item,\n                index,\n                key: evaluateKey(keyExpression, item, index),\n            }))\n\n            // Prevent tracking during DOM updates (critical for performance)\n            peek(() => {\n                beginBatch()\n                try {\n                    diffAndUpdate(newArrayWithKeys, state, ctx)\n                } finally {\n                    endBatch()\n                }\n            })\n        })\n\n        state.effectCleanup = effectCleanup\n\n        return () => {\n            cleanup(state)\n            iterationStates.delete(el)\n        }\n    },\n})\n\n/**\n * Parse for expression\n */\nfunction parseExpression(expression: string): ParsedExpression | null {\n    const forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    const stripParensRE = /^\\s*\\(|\\)\\s*$/g;\n    const forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n\n    const match = expression.match(forAliasRE);\n    if (!match) return null;\n\n    let itemsExpr = match[2].trim();\n    if (itemsExpr.startsWith(\"$\")) {\n        itemsExpr = itemsExpr.slice(1);\n    }\n\n    const result: ParsedExpression = {\n        item: \"\",\n        items: itemsExpr,\n    };\n\n    let item = match[1].replace(stripParensRE, \"\").trim();\n    const iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n        result.item = item.replace(forIteratorRE, \"\").trim();\n        result.index = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n            result.collection = iteratorMatch[2].trim();\n        }\n    } else {\n        result.item = item;\n    }\n\n    return result;\n}\n\n/**\n * Diff and update DOM with keyed diffing\n */\nfunction diffAndUpdate(\n    newArrayWithKeys: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    // Handle duplicate keys\n    const seen = new Set();\n    const finalArray = newArrayWithKeys.map((data, i) => {\n        let finalKey = data.key;\n        if (seen.has(finalKey)) {\n            finalKey = `${finalKey}_dup_${i}`;\n        }\n        seen.add(finalKey);\n        return { ...data, key: finalKey };\n    });\n\n    const newKeys = finalArray.map(d => d.key);\n    const prevKeys = state.prevKeys;\n\n    // Detect change type\n    const changeType = detectChange(prevKeys, newKeys);\n\n    if (changeType === 'no-change') {\n        // NO-CHANGE: Keys haven't changed, but properties might have\n        // Sync ephemeral signals from source for DISPLAY properties (data-text, etc.)\n        // Bindings (data-bind) update ephemeral signals directly, but display\n        // properties need to be synced when source properties change\n        if (!state.isNormalized && finalArray.length > 0) {\n            // Check if this is an object array (first item is an object)\n            const firstItem = finalArray[0].item;\n            if (firstItem && typeof firstItem === 'object' && !Array.isArray(firstItem)) {\n                for (const itemData of finalArray) {\n                    const loopEl = state.lookup.get(itemData.key)\n                    if (loopEl) {\n                        const sanitizedKey = sanitizeKey(itemData.key)\n                        // Sync ephemeral signal with latest source data\n                        mergePatch({\n                            [state.iterationId]: {\n                                [sanitizedKey]: itemData.item\n                            }\n                        })\n                    }\n                }\n            }\n        }\n        return;\n    } else if (changeType === 'simple-add') {\n        handleAdd(finalArray, state, ctx);\n    } else if (changeType === 'simple-remove') {\n        handleRemove(prevKeys, newKeys, state, ctx, finalArray);\n    } else {\n        handleReorder(finalArray, state, ctx);\n    }\n\n    state.prevKeys = [...newKeys];\n}\n\n/**\n * Detect change type for optimized updates\n */\nfunction detectChange(prevKeys: any[], newKeys: any[]): 'no-change' | 'simple-add' | 'simple-remove' | 'complex' {\n    if (prevKeys.length === newKeys.length && prevKeys.every((k, i) => k === newKeys[i])) {\n        return 'no-change';\n    }\n\n    if (prevKeys.length < newKeys.length) {\n        if (prevKeys.every((k, i) => k === newKeys[i])) {\n            return 'simple-add';\n        }\n    }\n\n    if (prevKeys.length > newKeys.length) {\n        const newSet = new Set(newKeys);\n        if (!newKeys.some(k => !new Set(prevKeys).has(k))) {\n            let newIdx = 0;\n            for (const pk of prevKeys) {\n                if (newSet.has(pk)) {\n                    if (newKeys[newIdx] !== pk) return 'complex';\n                    newIdx++;\n                }\n            }\n            return 'simple-remove';\n        }\n    }\n\n    return 'complex';\n}\n\n/**\n * Handle simple additions\n */\nfunction handleAdd(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const startIdx = state.prevKeys.length;\n    let prevEl: HTMLOrSVG = state.template;\n\n    if (startIdx > 0) {\n        const lastKey = state.prevKeys[startIdx - 1];\n        const last = state.lookup.get(lastKey);\n        if (last) prevEl = last.el;\n    }\n\n    for (let i = startIdx; i < data.length; i++) {\n        const item = data[i];\n        const loopEl = createElement(item, state, ctx);\n        state.lookup.set(item.key, loopEl);\n        prevEl.after(loopEl.el);\n        prevEl = loopEl.el;\n        queueMicrotask(() => apply(loopEl.el));\n    }\n}\n\n/**\n * Handle simple removals\n */\nfunction handleRemove(\n    prevKeys: any[],\n    newKeys: any[],\n    state: IterationState,\n    _ctx: any,\n    data: Array<{ item: any; index: number; key: any }>\n) {\n    const newSet = new Set(newKeys);\n\n    // Remove elements no longer in new keys\n    for (const key of prevKeys) {\n        if (!newSet.has(key)) {\n            const loopEl = state.lookup.get(key);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(key);\n            }\n        }\n    }\n\n    // Update indices for remaining elements\n    for (const itemData of data) {\n        const loopEl = state.lookup.get(itemData.key);\n        if (loopEl && loopEl.index !== itemData.index) {\n            loopEl.index = itemData.index;\n\n            // Update index in ephemeral signal for reactive updates\n            if (!state.isNormalized) {\n                const sanitizedKey = sanitizeKey(itemData.key)\n                const currentData = root[state.iterationId]?.[sanitizedKey]\n                if (currentData !== undefined) {\n                    mergePatch({\n                        [state.iterationId]: {\n                            [`${sanitizedKey}__index`]: itemData.index\n                        }\n                    })\n                }\n            }\n        }\n    }\n}\n\n/**\n * Handle complex changes with smart reordering\n */\nfunction handleReorder(\n    data: Array<{ item: any; index: number; key: any }>,\n    state: IterationState,\n    ctx: any\n) {\n    const newSet = new Set(data.map(d => d.key));\n\n    // Remove elements no longer in new keys\n    for (const pk of state.prevKeys) {\n        if (!newSet.has(pk)) {\n            const loopEl = state.lookup.get(pk);\n            if (loopEl) {\n                loopEl.el.remove();\n                state.lookup.delete(pk);\n            }\n        }\n    }\n\n    // Reorder/create elements\n    let prevEl: HTMLOrSVG = state.template;\n    for (const item of data) {\n        const existing = state.lookup.get(item.key);\n\n        if (existing) {\n            // Reuse element - update index in ephemeral signal if it changed\n            if (existing.index !== item.index) {\n                existing.index = item.index;\n\n                // Update index in ephemeral signal for reactive updates\n                if (!state.isNormalized) {\n                    const sanitizedKey = sanitizeKey(item.key)\n                    const currentData = root[state.iterationId]?.[sanitizedKey]\n                    if (currentData !== undefined) {\n                        mergePatch({\n                            [state.iterationId]: {\n                                [`${sanitizedKey}__index`]: item.index\n                            }\n                        })\n                    }\n                }\n            }\n\n            if (existing.el.previousElementSibling !== prevEl) {\n                prevEl.after(existing.el);\n            }\n            prevEl = existing.el;\n        } else {\n            // Create new element\n            const loopEl = createElement(item, state, ctx);\n            state.lookup.set(item.key, loopEl);\n            prevEl.after(loopEl.el);\n            prevEl = loopEl.el;\n            queueMicrotask(() => apply(loopEl.el));\n        }\n    }\n}\n\n/**\n * Create new loop element with EPHEMERAL SIGNALS\n *\n * CRITICAL: Use ephemeral signals (keyed by item key) to prevent source signal corruption\n */\nfunction createElement(\n    itemData: { item: any; index: number; key: any },\n    state: IterationState,\n    _ctx: any\n): LoopElement {\n    const { templateContent, sourceSignalPath, iteratorNames, isNormalized, iterationId } = state;\n\n    const clone = templateContent.cloneNode(true) as DocumentFragment;\n    const el = clone.firstElementChild as HTMLOrSVG;\n\n    // Map iterator to ephemeral signal path (keyed by item key to prevent corruption)\n    let signalPath = sourceSignalPath;\n    let indexSignalPath: string | null = null;\n    if (!isNormalized) {\n        // For arrays: Create ephemeral signal keyed by unique key\n        // This prevents corruption of source signal\n        const sanitizedKey = sanitizeKey(itemData.key);\n        signalPath = `${iterationId}.${sanitizedKey}`;\n        indexSignalPath = `${iterationId}.${sanitizedKey}__index`;\n\n        // Create ephemeral signals for item and index\n        mergePatch({\n            [iterationId]: {\n                [sanitizedKey]: itemData.item,\n                [`${sanitizedKey}__index`]: itemData.index\n            }\n        })\n    }\n\n    transformElement(el, iteratorNames, itemData.index, signalPath, indexSignalPath, isNormalized, itemData.item);\n\n    return {\n        el,\n        key: itemData.key,\n        index: itemData.index,\n    };\n}\n\n/**\n * Sanitize key for use as signal path\n */\nfunction sanitizeKey(key: any): string {\n    return String(key).replace(/[^a-zA-Z0-9_]/g, '_');\n}\n\n/**\n * Transform element attributes\n */\nfunction transformElement(\n    el: HTMLOrSVG,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n) {\n    const process = (elem: Element): void => {\n        Array.from(elem.attributes).forEach((attr) => {\n            if (attr.name.startsWith(\"data-\") && attr.value) {\n                attr.value = transformExpression(\n                    attr.value,\n                    attr.name,\n                    iterators,\n                    index,\n                    signalPath,\n                    indexSignalPath,\n                    isNormalized,\n                    value\n                );\n            }\n        });\n\n        if (elem instanceof HTMLTemplateElement && elem.content) {\n            Array.from(elem.content.children).forEach(child => process(child));\n        } else {\n            Array.from(elem.children).forEach(child => process(child));\n        }\n    };\n\n    process(el);\n}\n\n/**\n * Transform expression\n */\nfunction transformExpression(\n    expr: string,\n    attrName: string,\n    iterators: ParsedExpression,\n    index: number,\n    signalPath: string,\n    indexSignalPath: string | null,\n    isNormalized: boolean,\n    value: any\n): string {\n    let result = expr;\n\n    // Determine if signal name or expression\n    const isSignalName = /^(bind|ref|indicator|signals|computed)/.test(attrName.replace(/^data-/, \"\"));\n\n    // Protect string literals\n    const literals: string[] = [];\n    result = result\n        .replace(/'(?:[^'\\\\]|\\\\.)*'/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/\"(?:[^\"\\\\]|\\\\.)*\"/g, m => (literals.push(m), `__LIT${literals.length - 1}__`))\n        .replace(/`(?:[^`\\\\]|\\\\.)*`/g, m => (literals.push(m), `__LIT${literals.length - 1}__`));\n\n    // Transform index - use reactive signal if available, otherwise literal\n    if (iterators.index) {\n        if (indexSignalPath && !isNormalized) {\n            // Use reactive index signal with $ prefix for expressions\n            const prefix = isSignalName ? \"\" : \"$\";\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), prefix + indexSignalPath);\n        } else {\n            // Fallback to literal index for normalized data\n            result = result.replace(new RegExp(`\\\\b${esc(iterators.index)}\\\\b`, \"g\"), index.toString());\n        }\n    }\n\n    // Transform collection\n    if (iterators.collection) {\n        const prefix = isSignalName ? \"\" : \"$\";\n        result = result.replace(new RegExp(`\\\\b${esc(iterators.collection)}\\\\b`, \"g\"), prefix + signalPath);\n    }\n\n    // Transform item\n    if (isDestructured(iterators.item)) {\n        const vars = extractVars(iterators.item);\n        const isArrayDestructuring = iterators.item.trim().startsWith('[');\n\n        vars.forEach((v, idx) => {\n            let varSignalPath: string;\n            let varValue: any;\n\n            if (isArrayDestructuring) {\n                // Array destructuring: [x, y] â†’ signalPath.0, signalPath.1\n                varSignalPath = `${signalPath}.${idx}`;\n                varValue = Array.isArray(value) ? value[idx] : value;\n            } else {\n                // Object destructuring: {name, price} â†’ signalPath.name, signalPath.price\n                varSignalPath = `${signalPath}.${v}`;\n                varValue = value && typeof value === 'object' ? value[v] : value;\n            }\n\n            result = transformVar(result, v, varSignalPath, isSignalName, isNormalized, varValue, iterators);\n        });\n    } else {\n        result = transformVar(result, iterators.item, signalPath, isSignalName, isNormalized, value, iterators);\n    }\n\n    // Restore literals\n    result = result.replace(/__LIT(\\d+)__/g, (_, i) => literals[parseInt(i)]);\n\n    return result;\n}\n\n/**\n * Transform variable\n */\nfunction transformVar(\n    expr: string,\n    varName: string,\n    signalPath: string,\n    isSignalName: boolean,\n    isNormalized: boolean,\n    value: any,\n    _iterators: ParsedExpression\n): string {\n    if (isNormalized) {\n        // Value-based: replace with literal value\n        return expr.replace(new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"), JSON.stringify(value));\n    }\n\n    const prefix = isSignalName ? \"\" : \"$\";\n\n    // Property access: varName.prop â†’ signalPath.prop\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\.([a-zA-Z_][a-zA-Z0-9_.]*)\\\\b`, \"g\"),\n        `${prefix}${signalPath}.$1`\n    );\n\n    // Standalone: varName â†’ signalPath\n    expr = expr.replace(\n        new RegExp(`\\\\b${esc(varName)}\\\\b(?!\\\\.)`, \"g\"),\n        prefix + signalPath\n    );\n\n    return expr;\n}\n\n/**\n * Utilities\n */\nfunction shouldNormalizeData(data: any): boolean {\n    return typeof data === \"number\" || (data && typeof data === \"object\" && !Array.isArray(data));\n}\n\nfunction normalizeData(data: any): any[] {\n    if (data == null) return [];\n    if (Array.isArray(data)) return data;\n    if (typeof data === \"number\") return Array.from({ length: data }, (_, i) => i + 1);\n    if (typeof data === \"object\") return Object.entries(data);\n    return [data];\n}\n\nfunction evaluateKey(keyExpr: string | null, item: any, index: number): any {\n    if (!keyExpr) {\n        if (item && typeof item === \"object\") {\n            if (\"id\" in item && item.id != null) return item.id;\n            if (\"uuid\" in item && item.uuid != null) return item.uuid;\n            if (\"key\" in item && item.key != null) return item.key;\n        }\n        return index;\n    }\n\n    if (keyExpr === \"index\") return index;\n\n    if (keyExpr.includes('.')) {\n        const parts = keyExpr.split('.');\n        let val = item;\n        for (const part of parts) {\n            if (val && typeof val === \"object\" && part in val) {\n                val = val[part];\n            } else {\n                return index;\n            }\n        }\n        return val !== undefined && val !== null ? val : index;\n    }\n\n    if (item && typeof item === \"object\" && keyExpr in item) {\n        const keyVal = item[keyExpr];\n        return keyVal !== undefined && keyVal !== null ? keyVal : index;\n    }\n\n    return index;\n}\n\nfunction isDestructured(item: string): boolean {\n    return /^\\[.*\\]$/.test(item) || /^\\{.*\\}$/.test(item);\n}\n\nfunction extractVars(item: string): string[] {\n    return item\n        .replace(/[\\[\\]\\{\\}]/g, \"\")\n        .split(\",\")\n        .map(i => i.trim());\n}\n\nfunction esc(str: string): string {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nfunction cleanup(state: IterationState) {\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    state.lookup.forEach(loopEl => loopEl.el.remove());\n    state.lookup.clear();\n    state.prevKeys.length = 0;\n}\n","// Icon: material-symbols:check-circle-outline\n// Slug: Conditionally renders elements based on expression.\n// Description: Implements conditional rendering like Alpine.js x-if - must be on <template> with single root element. Uses computed wrapper for proper reactivity with Datastar's signal system.\n\nimport { attribute, apply } from '@engine'\nimport { effect, computed } from '@engine/signals'\nimport type { HTMLOrSVG } from '@engine/types'\n\n/**\n * State management interface for each data-if instance\n */\ninterface IfState {\n    renderedElement: Element | null\n    isRendered: boolean\n    commentMarker: Comment\n    effectCleanup: (() => void) | null\n    ifId: string\n}\n\n// WeakMap to store if state per element\nconst ifStates = new WeakMap<HTMLOrSVG, IfState>()\nlet ifCounter = 0\n\nattribute({\n    name: 'if',\n    requirement: {\n        key: 'denied',\n        value: 'must',\n    },\n    returnsValue: true,\n    apply({ el, rx, error }) {\n        // VALIDATION: Must be on template element\n        if (!(el instanceof HTMLTemplateElement)) {\n            throw error('IfMustBeOnTemplate', {\n                message: 'data-if must be used on <template> elements',\n            })\n        }\n\n        // VALIDATION: Template must have single root element (Alpine.js requirement)\n        const templateContent = el.content\n        const rootElements = Array.from(templateContent.children)\n        if (rootElements.length !== 1) {\n            throw error('IfTemplateMustHaveSingleRoot', {\n                count: rootElements.length,\n                message:\n                    'data-if template must contain exactly one root element',\n            })\n        }\n\n        const template = el\n        const container = template.parentElement!\n\n        // Hide template element\n        template.style.display = 'none'\n\n        // ALPINE.JS PATTERN: Create comment marker for reliable positioning\n        const ifId = `__if_${++ifCounter}`\n        const commentMarker = document.createComment(`Datastar if ${ifId}`)\n        container.insertBefore(commentMarker, template.nextSibling)\n\n        // Initialize state tracking with WeakMap (data-for pattern)\n        const state: IfState = {\n            renderedElement: null,\n            isRendered: false,\n            commentMarker,\n            effectCleanup: null,\n            ifId,\n        }\n\n        ifStates.set(el, state)\n\n        try {\n            // COMPUTED WRAPPER: Re-evaluate expression reactively (data-for pattern)\n            // This ensures proper subscription even when signals are deleted/recreated by Datastar\n            const conditionComputed = computed(() => {\n                return rx() // Evaluate reactive expression inside computed\n            })\n\n            // DATASTAR REACTIVE EFFECT: Conditional rendering\n            const effectCleanup = effect(() => {\n                const shouldRender = !!conditionComputed()\n\n                // State transition: false -> true (RENDER)\n                if (shouldRender && !state.isRendered) {\n                    state.renderedElement = renderElement(\n                        template,\n                        state.commentMarker\n                    )\n                    state.isRendered = true\n                }\n                // State transition: true -> false (CLEANUP)\n                else if (!shouldRender && state.isRendered) {\n                    if (state.renderedElement) {\n                        cleanupElement(state.renderedElement)\n                        state.renderedElement = null\n                    }\n                    state.isRendered = false\n                }\n            })\n\n            state.effectCleanup = effectCleanup\n\n            // Return cleanup function (called when plugin is removed)\n            return () => {\n                cleanupIfInstance(state)\n                ifStates.delete(el)\n            }\n        } catch (err) {\n            // Cleanup on error\n            const instanceState = ifStates.get(el)\n            if (instanceState) {\n                cleanupIfInstance(instanceState)\n                ifStates.delete(el)\n            }\n            throw err\n        }\n    },\n})\n\n/**\n * RENDER FUNCTION: Clone template and insert into DOM\n * Follows data-for pattern with queueMicrotask for Datastar processing\n */\nfunction renderElement(\n    template: HTMLTemplateElement,\n    commentMarker: Comment\n): Element {\n    // Clone template content\n    const clone = template.content.cloneNode(true) as DocumentFragment;\n    const element = clone.firstElementChild as Element;\n\n    // Insert element into DOM after the comment marker\n    commentMarker.parentNode!.insertBefore(element, commentMarker.nextSibling);\n\n    // Apply Datastar processing to generated element\n    // Use queueMicrotask to ensure DOM is ready (data-for pattern)\n    queueMicrotask(() => {\n        apply(element as HTMLElement);\n    });\n\n    return element;\n}\n\n/**\n * CLEANUP FUNCTION: Remove element from DOM\n * Datastar's mutation observer handles attribute cleanup\n */\nfunction cleanupElement(element: Element): void {\n    element.remove();\n}\n\n/**\n * COMPREHENSIVE CLEANUP: Clean up entire if instance\n * Follows data-for's comprehensive cleanup pattern\n */\nfunction cleanupIfInstance(state: IfState): void {\n    // Cleanup reactive effect\n    if (state.effectCleanup) {\n        state.effectCleanup();\n        state.effectCleanup = null;\n    }\n\n    // Remove rendered element if present\n    if (state.renderedElement) {\n        cleanupElement(state.renderedElement);\n        state.renderedElement = null;\n    }\n\n    // Remove comment marker\n    if (state.commentMarker && state.commentMarker.parentNode) {\n        state.commentMarker.remove();\n    }\n\n    // Reset state\n    state.isRendered = false;\n}\n","// Icon: material-symbols:navigation\n// Slug: Enhanced reactive navigation with Datastar-standard modifiers.\n// Description: Professional navigation with explicit merge control and standard modifier support.\n\nimport { attribute, actions } from '@engine'\n\n/**\n * Enhanced Navigate Attribute - Professional Navigation System\n *\n * Follows Datastar modifier conventions for explicit, predictable navigation.\n * No more \"smart defaults\" - developers control exactly what happens.\n *\n * MODIFIER EXAMPLES:\n * data-navigate=\"true\"                                    // Basic navigation (no merge)\n * data-navigate__key.sidebar=\"true\"                       // Navigation with key\n * data-navigate__merge=\"true\"                            // Explicit merge behavior\n * data-navigate__merge__key.main=\"true\"                  // Merge with key\n * data-navigate__only.search,category=\"true\"             // Only preserve specific params\n * data-navigate__except.page=\"true\"                      // Preserve all except specific\n * data-navigate__replace=\"true\"                          // Replace instead of push history\n * data-navigate__debounce.300ms=\"true\"                   // Debounce navigation\n *\n * COMPLEX EXAMPLES:\n * data-navigate__merge__except.page__debounce.500ms=\"true\"    // Comprehensive control\n * data-navigate__key.filters__only.search,category=\"true\"     // Granular parameter control\n */\nattribute({\n    name: 'navigate',\n    requirement: {\n        key: 'denied',\n        value: 'must',\n    },\n    apply(ctx) {\n        const { el, value, mods, error } = ctx\n\n        // Parse navigation configuration from modifiers\n        const navigateConfig = parseNavigateModifiers(mods, value.trim())\n\n        if (!navigateConfig) {\n            throw error('InvalidNavigateConfiguration', {\n                value,\n                modifiers: Array.from(mods.keys()),\n            })\n        }\n\n        // Create navigation handler with access to ctx\n        const handleNavigationWithCtx = (url: string, config: NavigateConfig): void => {\n            handleNavigation(ctx, url, config)\n        }\n\n        // Create timing wrapper if specified\n        const executeNavigation = navigateConfig.timing\n            ? createTimingWrapper(handleNavigationWithCtx, navigateConfig.timing)\n            : handleNavigationWithCtx\n\n        // Create click handler\n        const handleClick = (event: Event) => {\n            const target = event.target as HTMLElement\n            const link = target.closest('a[href]') as HTMLAnchorElement\n\n            if (!link || !shouldInterceptNavigation(link)) {\n                return\n            }\n\n            event.preventDefault()\n            executeNavigation(link.href, navigateConfig)\n        }\n\n        // Create form submit handler for GET forms\n        const handleSubmit = (event: Event) => {\n            const form = event.target as HTMLFormElement\n\n            if (!shouldInterceptFormSubmit(form)) {\n                return\n            }\n\n            event.preventDefault()\n\n            const formData = new FormData(form)\n            const url = new URL(form.action, window.location.href)\n\n            // Add form data to URL params\n            for (const [key, value] of formData.entries()) {\n                if (typeof value === 'string') {\n                    url.searchParams.set(key, value)\n                }\n            }\n\n            executeNavigation(url.toString(), navigateConfig)\n        }\n\n        // Attach event listeners\n        el.addEventListener('click', handleClick)\n        el.addEventListener('submit', handleSubmit)\n\n        return () => {\n            el.removeEventListener('click', handleClick)\n            el.removeEventListener('submit', handleSubmit)\n        }\n    },\n})\n\n/**\n * Navigation configuration interface\n */\ninterface NavigateConfig {\n    key: string;\n    merge: boolean;\n    only?: string[];\n    except?: string[];\n    replace?: boolean;\n    timing?: TimingConfig;\n}\n\ninterface TimingConfig {\n    type: \"debounce\" | \"throttle\" | \"delay\";\n    duration: number;\n    leading?: boolean;\n}\n\n/**\n * Parse Datastar modifiers into navigation configuration\n *\n * SUPPORTED MODIFIERS:\n * - __key.{keyname} â†’ Sets navigation key\n * - __merge â†’ Enable query parameter merging\n * - __only.{param1,param2} â†’ Only preserve specific parameters\n * - __except.{param1,param2} â†’ Preserve all except specific parameters\n * - __replace â†’ Use replaceState instead of pushState\n * - __debounce.{duration}ms â†’ Debounce navigation\n * - __throttle.{duration}ms â†’ Throttle navigation\n * - __delay.{duration}ms â†’ Simple delay\n */\nfunction parseNavigateModifiers(\n    mods: Map<string, Set<string>>,\n    value: string\n): NavigateConfig | null {\n    if (!value || value.trim() === \"\") {\n        return null;\n    }\n\n    const config: NavigateConfig = {\n        key: \"true\", // Default key\n        merge: false, // EXPLICIT: No more smart defaults!\n        replace: false,\n    };\n\n    // Parse modifiers\n    for (const [modName, modTags] of mods) {\n        switch (modName) {\n            case \"key\":\n                // __key.sidebar â†’ key = \"sidebar\"\n                config.key = modTags.size > 0 ? Array.from(modTags)[0] : \"true\";\n                break;\n\n            case \"merge\":\n                // __merge â†’ merge = true\n                config.merge = true;\n                break;\n\n            case \"only\":\n                // __only.search,category â†’ only = [\"search\", \"category\"]\n                config.only = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"except\":\n                // __except.page â†’ except = [\"page\"]\n                config.except = Array.from(modTags);\n                config.merge = true; // Implied when using only/except\n                break;\n\n            case \"replace\":\n                // __replace â†’ replace = true\n                config.replace = true;\n                break;\n\n            case \"debounce\":\n                // __debounce.300ms â†’ debounce for 300ms\n                config.timing = parseTimingModifier(\"debounce\", modTags);\n                break;\n\n            case \"throttle\":\n                // __throttle.500ms â†’ throttle for 500ms\n                config.timing = parseTimingModifier(\"throttle\", modTags);\n                break;\n\n            case \"delay\":\n                // __delay.1s â†’ simple delay for 1s\n                config.timing = parseTimingModifier(\"delay\", modTags);\n                break;\n        }\n    }\n\n    // Validation: cannot use both only and except\n    if (config.only && config.except) {\n        console.warn(\n            \"Navigate: Cannot use both __only and __except modifiers. Using __only.\"\n        );\n        delete config.except;\n    }\n\n    return config;\n}\n\n/**\n * Parse timing modifier tags into timing configuration\n */\nfunction parseTimingModifier(\n    type: \"debounce\" | \"throttle\" | \"delay\",\n    tags: Set<string>\n): TimingConfig | undefined {\n    const tagArray = Array.from(tags);\n\n    // Find duration tag (e.g., \"300ms\", \"1s\", \"1000\")\n    const durationTag = tagArray.find((tag) => /^\\d+(?:ms|s)?$/.test(tag));\n    if (!durationTag) {\n        console.warn(\n            `Navigate: Invalid ${type} timing - no duration specified`\n        );\n        return undefined;\n    }\n\n    // Parse duration\n    let duration: number;\n    if (durationTag.endsWith(\"ms\")) {\n        duration = parseInt(durationTag.slice(0, -2));\n    } else if (durationTag.endsWith(\"s\")) {\n        duration = parseInt(durationTag.slice(0, -1)) * 1000;\n    } else {\n        duration = parseInt(durationTag); // Assume milliseconds\n    }\n\n    return {\n        type,\n        duration,\n        leading: tagArray.includes(\"leading\"),\n    };\n}\n\n/**\n * Create timing wrapper for navigation function\n */\nfunction createTimingWrapper(\n    fn: (url: string, config: NavigateConfig) => void,\n    timing: TimingConfig\n): (url: string, config: NavigateConfig) => void {\n    switch (timing.type) {\n        case \"debounce\":\n            return createDebounce(fn, timing.duration, timing.leading);\n\n        case \"throttle\":\n            return createThrottle(fn, timing.duration, timing.leading);\n\n        case \"delay\":\n            return createDelay(fn, timing.duration);\n\n        default:\n            return fn;\n    }\n}\n\n/**\n * Simple debounce implementation\n */\nfunction createDebounce<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number,\n    leading?: boolean\n): T {\n    let timeout: ReturnType<typeof setTimeout> | undefined;\n    let hasRun = false;\n\n    return ((...args: Parameters<T>) => {\n        const callNow = leading && !hasRun;\n\n        clearTimeout(timeout);\n\n        timeout = setTimeout(() => {\n            hasRun = false;\n            if (!leading) fn(...args);\n        }, delay);\n\n        if (callNow) {\n            hasRun = true;\n            fn(...args);\n        }\n    }) as T;\n}\n\n/**\n * Simple throttle implementation\n */\nfunction createThrottle<T extends (...args: any[]) => void>(\n    fn: T,\n    limit: number,\n    leading?: boolean\n): T {\n    let inThrottle = false;\n    let lastArgs: Parameters<T> | null = null;\n\n    return ((...args: Parameters<T>) => {\n        if (!inThrottle) {\n            if (leading !== false) {\n                fn(...args);\n            }\n            inThrottle = true;\n\n            setTimeout(() => {\n                inThrottle = false;\n                if (lastArgs && leading === false) {\n                    fn(...lastArgs);\n                    lastArgs = null;\n                }\n            }, limit);\n        } else {\n            lastArgs = args;\n        }\n    }) as T;\n}\n\n/**\n * Simple delay implementation\n */\nfunction createDelay<T extends (...args: any[]) => void>(\n    fn: T,\n    delay: number\n): T {\n    return ((...args: Parameters<T>) => {\n        setTimeout(() => fn(...args), delay);\n    }) as T;\n}\n\n/**\n * Handle navigation with configuration - uses Datastar action registry\n */\nfunction handleNavigation(ctx: any, url: string, config: NavigateConfig): void {\n    try {\n        // Process URL with merge configuration\n        const finalUrl = processUrlWithMergeConfig(url, config);\n\n        // Get the navigate action from Datastar's action registry\n        const navigateAction = actions.navigate\n\n        if (!navigateAction) {\n            console.error(\n                'Navigate action not available in Datastar actions registry. ' +\n                'Falling back to standard navigation.'\n            )\n            window.location.href = finalUrl\n            return\n        }\n\n        // Build options for navigate action\n        const navigateOptions: Record<string, any> = {\n            merge: config.merge,\n            replace: config.replace,\n        }\n\n        if (config.only) {\n            navigateOptions.only = config.only\n        }\n\n        if (config.except) {\n            navigateOptions.except = config.except\n        }\n\n        // Call @navigate action using Datastar's infrastructure\n        navigateAction(ctx, finalUrl, config.key, navigateOptions)\n    } catch (error) {\n        console.error(\"Navigation failed:\", error);\n        window.location.href = url;\n    }\n}\n\n/**\n * Process URL with merge configuration - EXPLICIT and PREDICTABLE\n */\nfunction processUrlWithMergeConfig(\n    url: string,\n    config: NavigateConfig\n): string {\n    // If no merging, return URL as-is\n    if (!config.merge) {\n        return url;\n    }\n\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = config.only\n                ? config.only.includes(key)\n                : !config.except || !config.except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                // Remove empty parameters\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error processing URL merge:\", error);\n        return url;\n    }\n}\n\n/**\n * Determine if we should intercept navigation for this link\n */\nfunction shouldInterceptNavigation(link: HTMLAnchorElement): boolean {\n    // Skip external links\n    try {\n        const url = new URL(link.href, window.location.href);\n        if (url.origin !== window.location.origin) {\n            return false;\n        }\n    } catch {\n        return false;\n    }\n\n    // Skip download links\n    if (link.hasAttribute(\"download\")) {\n        return false;\n    }\n\n    // Skip explicitly opted-out links\n    if (link.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Determine if we should intercept form submission\n */\nfunction shouldInterceptFormSubmit(form: HTMLFormElement): boolean {\n    // Only handle GET forms\n    if (form.method.toLowerCase() !== \"get\") {\n        return false;\n    }\n\n    // Skip explicitly opted-out forms\n    if (form.hasAttribute(\"data-navigate-skip\")) {\n        return false;\n    }\n\n    return true;\n}\n","/**\n * Laravel CSRF Token Utilities - Security Token Management for Hyper Requests\n *\n * Provides utilities for automatic CSRF token injection into HTTP requests sent to Laravel\n * backends. These functions handle token extraction from Laravel's meta tag, detection of\n * manually-provided tokens, and safe header construction for protected HTTP methods.\n *\n * Laravel's CSRF protection requires a valid token for all state-changing operations\n * (POST, PUT, PATCH, DELETE). This module ensures seamless integration by automatically\n * retrieving and injecting tokens without requiring manual intervention from developers.\n *\n * Core capabilities:\n * - Token retrieval from Laravel's `<meta name=\"csrf-token\">` tag\n * - Detection of manually-provided CSRF headers to prevent duplication\n * - Safe header construction that respects user-provided tokens\n * - Support for multiple CSRF header formats (X-CSRF-TOKEN, x-csrf-token, X-Csrf-Token)\n *\n * Security considerations:\n * - Only injects tokens when not manually provided (avoids overriding user intent)\n * - Returns empty object when token unavailable (graceful degradation)\n * - Respects Laravel's token rotation and expiration mechanisms\n *\n * @module hyper-ext/utils/csrf\n * @see https://laravel.com/docs/csrf\n */\n\n/**\n * Retrieve CSRF token from Laravel's meta tag\n *\n * Searches the document for the standard Laravel CSRF meta tag and extracts\n * its content attribute value. Laravel automatically injects this meta tag in\n * the document head when using the @csrf Blade directive or Laravel's default\n * layout templates.\n *\n * The token should be present on all pages that will make CSRF-protected requests.\n * If the token is missing, CSRF-protected requests will fail with 419 (Token Mismatch)\n * errors from Laravel.\n *\n * @returns {string | null} The CSRF token string, or null if meta tag not found\n *\n * @example\n * ```typescript\n * const token = getCSRFToken()\n * if (token) {\n *   // Token available, safe to make protected requests\n *   console.log('CSRF token:', token)\n * } else {\n *   // Token missing, CSRF-protected requests will fail\n *   console.warn('CSRF token not found in document')\n * }\n * ```\n */\nexport function getCSRFToken(): string | null {\n    const metaTag = document.querySelector('meta[name=\"csrf-token\"]');\n    return metaTag?.getAttribute(\"content\") || null;\n}\n\n/**\n * Check if CSRF token was manually provided in request headers\n *\n * Examines user-provided headers object for any of the standard CSRF header names\n * that Laravel recognizes. This prevents double-injection of CSRF tokens when\n * developers explicitly provide their own token in request configuration.\n *\n * Laravel accepts CSRF tokens in multiple header formats for flexibility. This\n * function checks all recognized variants to ensure comprehensive detection.\n *\n * @param {Record<string, string>} userHeaders - Headers object provided by user (defaults to empty)\n *\n * @returns {boolean} True if user manually provided CSRF token, false otherwise\n *\n * @example\n * ```typescript\n * // User manually provided token\n * const headers = { 'X-CSRF-TOKEN': 'abc123' }\n * hasManualCSRF(headers) // Returns: true\n *\n * // No manual token\n * const headers = { 'Content-Type': 'application/json' }\n * hasManualCSRF(headers) // Returns: false\n * ```\n */\nexport function hasManualCSRF(\n    userHeaders: Record<string, string> = {}\n): boolean {\n    // Laravel recognizes multiple CSRF header name formats\n    const csrfHeaders = [\"X-CSRF-TOKEN\", \"x-csrf-token\", \"X-Csrf-Token\"];\n    return csrfHeaders.some((header) => userHeaders[header]);\n}\n\n/**\n * Get CSRF headers for Laravel requests with automatic token injection\n *\n * Constructs a headers object containing the CSRF token for Laravel requests, but only\n * if the token wasn't manually provided by the developer. This respects explicit user\n * configuration while providing automatic token injection for convenience.\n *\n * The function performs two critical checks:\n * 1. Validates that no manual CSRF header was provided (avoids duplication)\n * 2. Retrieves the token from Laravel's meta tag (ensures token availability)\n *\n * If either check fails, returns an empty object to allow the request to proceed\n * without automatic token injection. This enables graceful degradation and respects\n * user intent when tokens are explicitly managed.\n *\n * @param {Record<string, string>} userHeaders - Headers object provided by user (defaults to empty)\n *\n * @returns {Record<string, string>} Headers object with X-CSRF-TOKEN or empty object\n *\n * @example\n * ```typescript\n * // Automatic token injection\n * const headers = { 'Content-Type': 'application/json' }\n * const csrfHeaders = getCSRFHeaders(headers)\n * // Returns: { 'X-CSRF-TOKEN': 'abc123...' }\n *\n * // Respects manual token (no injection)\n * const headers = { 'X-CSRF-TOKEN': 'custom-token' }\n * const csrfHeaders = getCSRFHeaders(headers)\n * // Returns: {} (empty, doesn't override)\n *\n * // Graceful degradation when token missing\n * // (meta tag not in document)\n * const csrfHeaders = getCSRFHeaders({})\n * // Returns: {} (empty, token unavailable)\n * ```\n *\n * @see getCSRFToken For token retrieval mechanism\n * @see hasManualCSRF For manual token detection\n */\nexport function getCSRFHeaders(\n    userHeaders: Record<string, string> = {}\n): Record<string, string> {\n    // Don't override manual CSRF tokens\n    if (hasManualCSRF(userHeaders)) {\n        return {}; // User knows what they're doing\n    }\n\n    // Retrieve token from Laravel's meta tag\n    const csrfToken = getCSRFToken();\n\n    // Return token header or empty object for graceful degradation\n    return csrfToken ? { \"X-CSRF-TOKEN\": csrfToken } : {};\n}\n","/**\n * Laravel-Aware HTTP Action Factory - CSRF-Protected Request Builder\n *\n * Provides a factory function for creating Datastar action plugins that automatically inject\n * Laravel CSRF tokens into HTTP requests. This module serves as the foundation for all CSRF-\n * protected actions in the Hyper framework (@postx, @putx, @patchx, @deletex).\n *\n * Laravel's CSRF protection requires valid tokens for all state-changing HTTP methods (POST,\n * PUT, PATCH, DELETE). Manually managing tokens in every request is error-prone and verbose.\n * This factory automates token injection by wrapping Datastar's base fetch actions with\n * Laravel-specific security enhancements.\n *\n * The factory follows the Decorator pattern: it wraps existing Datastar actions without\n * modifying their behavior, transparently adding CSRF headers before delegating to the\n * original implementation. This ensures full compatibility with Datastar's fetch API while\n * meeting Laravel's security requirements.\n *\n * Core capabilities:\n * - Automatic CSRF token retrieval from `<meta name=\"csrf-token\">` tag\n * - Transparent header injection without modifying user-provided headers\n * - Respects manually-provided CSRF tokens (no override/duplication)\n * - Delegates all fetch behavior to Datastar's proven implementations\n * - Error handling for missing base actions (fail-fast with helpful context)\n *\n * Security considerations:\n * - Only injects tokens when not manually provided (respects user intent)\n * - Validates base action availability before registration (prevents runtime failures)\n * - Preserves all Datastar fetch features (SSE, streaming, form encoding, etc.)\n *\n * @module hyper-ext/backend/actions/fetch-laravel\n * @see getCSRFHeaders For token injection mechanism\n * @see https://laravel.com/docs/csrf For Laravel CSRF documentation\n * @see https://data-star.dev For Datastar fetch actions\n *\n * @example\n * ```typescript\n * // Create a custom CSRF-protected action\n * import { createHttpMethodWithCSRF } from './fetch-laravel'\n *\n * // Register @customx action that sends CUSTOM requests with CSRF\n * createHttpMethodWithCSRF('customx', 'CUSTOM')\n * ```\n *\n * @example\n * ```html\n * <!-- Usage in Blade templates (after registration) -->\n * <button data-on:click=\"@postx('/api/users')\">Create User</button>\n * <button data-on:click=\"@putx('/api/users/123')\">Update User</button>\n * <button data-on:click=\"@patchx('/api/users/123')\">Patch User</button>\n * <button data-on:click=\"@deletex('/api/users/123')\">Delete User</button>\n * ```\n */\n\nimport { action, actions } from '@engine'\nimport type { ActionContext } from '@engine/types'\nimport type { FetchArgs } from '../../../../datastar/plugins/actions/fetch'\nimport { getCSRFHeaders } from '../../../utils/csrf'\n\n/**\n * Create a Datastar action plugin with automatic Laravel CSRF token injection\n *\n * Registers a new action in Datastar's action registry that wraps an existing HTTP\n * method action (post, put, patch, delete) with automatic CSRF token injection. The\n * created action has the same signature and behavior as the base Datastar action,\n * with the added benefit of Laravel security compliance.\n *\n * The factory performs three critical operations:\n * 1. Validates that the base Datastar action exists (fail-fast error handling)\n * 2. Constructs enhanced request arguments with CSRF headers injected\n * 3. Delegates to the base action with enhanced arguments\n *\n * The CSRF token is retrieved from Laravel's standard `<meta name=\"csrf-token\">` tag\n * and injected into the X-CSRF-TOKEN header. If the user manually provided a CSRF\n * token, automatic injection is skipped to respect developer intent.\n *\n * @param {string} name - The name for the new action (e.g., 'postx', 'putx', 'patchx', 'deletex')\n * @param {string} method - The HTTP method for the base action (e.g., 'POST', 'PUT', 'PATCH', 'DELETE')\n *\n * @returns {void} Registers the action in Datastar's action registry via side-effect\n *\n * @throws {Error} When base Datastar action not found (via ctx.error in ActionContext)\n *                 Includes helpful context: method name, expected action name, available actions\n *\n * @example\n * ```typescript\n * // Basic usage - create standard CSRF-protected actions\n * createHttpMethodWithCSRF('postx', 'POST')     // Creates @postx action\n * createHttpMethodWithCSRF('putx', 'PUT')       // Creates @putx action\n * createHttpMethodWithCSRF('patchx', 'PATCH')   // Creates @patchx action\n * createHttpMethodWithCSRF('deletex', 'DELETE') // Creates @deletex action\n * ```\n *\n * @example\n * ```typescript\n * // Advanced usage - custom HTTP methods (if Datastar supports them)\n * createHttpMethodWithCSRF('linkx', 'LINK')\n * createHttpMethodWithCSRF('unlinkx', 'UNLINK')\n * ```\n *\n * @see action For Datastar action registration mechanism\n * @see actions For Datastar action registry lookup\n * @see getCSRFHeaders For CSRF token injection logic\n */\nexport const createHttpMethodWithCSRF = (\n    name: string,\n    method: string\n): void => {\n    // Register the action plugin with Datastar's action system\n    action({\n        name,\n        apply: async (\n            ctx: ActionContext,\n            url: string,\n            args: FetchArgs = {}\n        ) => {\n            // Retrieve the base HTTP action from Datastar's action registry\n            // Action names use lowercase HTTP method (post, put, patch, delete)\n            const baseActionName = method.toLowerCase()\n            const baseAction = actions[baseActionName]\n\n            // Fail-fast if base action doesn't exist (prevents confusing runtime errors)\n            if (!baseAction) {\n                throw ctx.error(`BaseActionNotFound`, {\n                    method,\n                    baseActionName,\n                    availableActions: Object.keys(actions),\n                })\n            }\n\n            // Construct enhanced arguments with CSRF token injection\n            // getCSRFHeaders checks if user already provided CSRF token manually\n            // and only injects if token not present (respects user intent)\n            //\n            // CRITICAL: Include credentials to send/receive cookies\n            // Without this, session cookies won't be sent with requests\n            // or received from responses, breaking session flash persistence\n            const enhancedArgs: FetchArgs = {\n                ...args,\n                credentials: 'include', // Required for session cookies\n                headers: {\n                    ...args?.headers,\n                    ...getCSRFHeaders(args?.headers),\n                },\n            }\n\n            // Delegate to the base Datastar action with CSRF-enhanced arguments\n            // All Datastar fetch features are preserved (SSE, streaming, forms, etc.)\n            return await baseAction(ctx, url, enhancedArgs)\n        },\n    })\n}\n","/**\n * POST with CSRF Protection - Laravel-Aware HTTP POST Action\n *\n * Provides a Datastar action that sends POST requests to Laravel backends with automatic\n * CSRF token injection. This action wraps the standard Datastar `@post` action and enhances\n * it with Laravel's CSRF protection requirements, eliminating the need for manual token\n * management in frontend code.\n *\n * Laravel requires CSRF tokens for all state-changing operations (POST, PUT, PATCH, DELETE)\n * to prevent Cross-Site Request Forgery attacks. This action automatically retrieves the\n * token from the `<meta name=\"csrf-token\">` tag and injects it into request headers.\n *\n * The action delegates all functionality to Datastar's base `@post` action while transparently\n * adding CSRF protection. This ensures full compatibility with Datastar's fetch API while\n * meeting Laravel's security requirements.\n *\n * @module hyper-ext/backend/actions/postx\n * @see createHttpMethodWithCSRF For the CSRF injection mechanism\n * @see https://laravel.com/docs/csrf For Laravel CSRF documentation\n *\n * @example\n * ```html\n * <!-- Basic POST request with automatic CSRF -->\n * <button data-on:click=\"@postx('/api/users')\">Create User</button>\n *\n * <!-- POST with request body from signals -->\n * <form data-on:submit.prevent=\"@postx('/users', { selector: 'form' })\">\n *   <input data-bind=\"name\" />\n *   <button>Submit</button>\n * </form>\n *\n * <!-- POST with custom headers (CSRF auto-injected) -->\n * <button data-on:click=\"@postx('/api/posts', { headers: { 'Accept': 'application/json' } })\">\n *   Create Post\n * </button>\n * ```\n */\n\nimport { createHttpMethodWithCSRF } from './fetch-laravel'\n\n// Register the postx action with automatic CSRF token injection\ncreateHttpMethodWithCSRF('postx', 'POST')\n","/**\n * PUT with CSRF Protection - Laravel-Aware HTTP PUT Action\n *\n * Provides a Datastar action that sends PUT requests to Laravel backends with automatic\n * CSRF token injection. This action wraps the standard Datastar `@put` action and enhances\n * it with Laravel's CSRF protection requirements for full resource updates.\n *\n * The PUT method is semantically meant for complete resource replacement in REST APIs.\n * Laravel requires CSRF tokens for all state-changing operations to prevent Cross-Site\n * Request Forgery attacks. This action automatically retrieves and injects the token.\n *\n * The action delegates all functionality to Datastar's base `@put` action while transparently\n * adding CSRF protection. This ensures full compatibility with Datastar's fetch API while\n * meeting Laravel's security requirements.\n *\n * @module hyper-ext/backend/actions/putx\n * @see createHttpMethodWithCSRF For the CSRF injection mechanism\n * @see https://laravel.com/docs/csrf For Laravel CSRF documentation\n *\n * @example\n * ```html\n * <!-- Basic PUT request for full resource update -->\n * <button data-on:click=\"@putx('/api/users/123')\">Update User</button>\n *\n * <!-- PUT with form data (complete replacement) -->\n * <form data-on:submit.prevent=\"@putx('/users/123', { selector: 'form' })\">\n *   <input data-bind=\"name\" />\n *   <input data-bind=\"email\" />\n *   <button>Update Profile</button>\n * </form>\n *\n * <!-- PUT with JSON body from signals -->\n * <button data-on:click=\"@putx('/api/settings', {\n *   headers: { 'Content-Type': 'application/json' }\n * })\">\n *   Save Settings\n * </button>\n * ```\n */\n\nimport { createHttpMethodWithCSRF } from './fetch-laravel'\n\n// Register the putx action with automatic CSRF token injection\ncreateHttpMethodWithCSRF('putx', 'PUT')\n","/**\n * PATCH with CSRF Protection - Laravel-Aware HTTP PATCH Action\n *\n * Provides a Datastar action that sends PATCH requests to Laravel backends with automatic\n * CSRF token injection. This action wraps the standard Datastar `@patch` action and enhances\n * it with Laravel's CSRF protection requirements for partial resource updates.\n *\n * The PATCH method is semantically meant for partial resource updates in REST APIs, allowing\n * you to modify specific fields without sending the entire resource representation. Laravel\n * requires CSRF tokens for all state-changing operations to prevent Cross-Site Request\n * Forgery attacks.\n *\n * The action delegates all functionality to Datastar's base `@patch` action while transparently\n * adding CSRF protection. This ensures full compatibility with Datastar's fetch API while\n * meeting Laravel's security requirements.\n *\n * @module hyper-ext/backend/actions/patchx\n * @see createHttpMethodWithCSRF For the CSRF injection mechanism\n * @see https://laravel.com/docs/csrf For Laravel CSRF documentation\n *\n * @example\n * ```html\n * <!-- Basic PATCH request for partial update -->\n * <button data-on:click=\"@patchx('/api/users/123')\">Update Name</button>\n *\n * <!-- PATCH with specific field updates -->\n * <input data-bind=\"email\"\n *        data-on:change=\"@patchx('/users/123', { selector: 'input' })\" />\n *\n * <!-- PATCH for toggling boolean flags -->\n * <button data-on:click=\"@patchx('/api/posts/456/publish')\">\n *   Publish Post\n * </button>\n *\n * <!-- PATCH with JSON payload from signals -->\n * <button data-on:click=\"@patchx('/api/profile', {\n *   headers: { 'Content-Type': 'application/json' }\n * })\">\n *   Update Profile Picture\n * </button>\n * ```\n */\n\nimport { createHttpMethodWithCSRF } from './fetch-laravel'\n\n// Register the patchx action with automatic CSRF token injection\ncreateHttpMethodWithCSRF('patchx', 'PATCH')\n","/**\n * DELETE with CSRF Protection - Laravel-Aware HTTP DELETE Action\n *\n * Provides a Datastar action that sends DELETE requests to Laravel backends with automatic\n * CSRF token injection. This action wraps the standard Datastar `@delete` action and enhances\n * it with Laravel's CSRF protection requirements for resource deletion.\n *\n * The DELETE method is used for removing resources from the server. Laravel requires CSRF\n * tokens for all state-changing operations to prevent Cross-Site Request Forgery attacks.\n * This action automatically retrieves and injects the token, making secure deletions simple.\n *\n * The action delegates all functionality to Datastar's base `@delete` action while transparently\n * adding CSRF protection. This ensures full compatibility with Datastar's fetch API while\n * meeting Laravel's security requirements.\n *\n * Security considerations:\n * - Always confirm destructive actions with user (use data-confirm or custom modal)\n * - Consider soft deletes for recoverable data\n * - Implement proper authorization checks on the backend\n *\n * @module hyper-ext/backend/actions/deletex\n * @see createHttpMethodWithCSRF For the CSRF injection mechanism\n * @see https://laravel.com/docs/csrf For Laravel CSRF documentation\n *\n * @example\n * ```html\n * <!-- Basic DELETE request -->\n * <button data-on:click=\"@deletex('/api/posts/123')\">Delete Post</button>\n *\n * <!-- DELETE with confirmation (using custom logic) -->\n * <button data-on:click=\"\n *   if (confirm('Delete this item?')) {\n *     @deletex('/api/items/456')\n *   }\n * \">Delete Item</button>\n *\n * <!-- DELETE multiple items -->\n * <button data-on:click=\"@deletex('/api/posts/bulk', {\n *   headers: { 'Content-Type': 'application/json' }\n * })\">Delete Selected</button>\n *\n * <!-- DELETE with custom success handling -->\n * <button data-on:click=\"\n *   @deletex('/api/comments/789')\n *     .then(() => $deleted = true)\n * \">Delete Comment</button>\n * ```\n */\n\nimport { createHttpMethodWithCSRF } from './fetch-laravel'\n\n// Register the deletex action with automatic CSRF token injection\ncreateHttpMethodWithCSRF('deletex', 'DELETE')\n","// Icon: material-symbols:navigation\n// Slug: Enhanced navigate action with JSON query support and consistent behavior.\n// Description: Professional navigate action that supports both string URLs and JSON query objects.\n\nimport { action, actions } from '@engine'\nimport type { ActionContext } from '@engine/types'\n\n/**\n * Enhanced Navigate Action - Professional Navigation with JSON Support\n *\n * Provides consistent navigation behavior between frontend expressions and backend responses.\n * Supports both traditional URL strings and JSON query parameter objects.\n *\n * USAGE EXAMPLES:\n *\n * Traditional URL Navigation:\n * @navigate('/dashboard')                              // Basic navigation\n * @navigate('/users', 'main')                         // Navigation with key\n * @navigate('/contacts?search=john', 'filters')       // URL with query params\n *\n * JSON Query Navigation (NEW):\n * @navigate({search: 'john', page: 1}, 'filters')                    // JSON queries\n * @navigate({search: 'john', page: 1}, 'filters', {merge: true})     // JSON with merge\n * @navigate({}, 'clear')                                             // Clear all queries\n *\n * Advanced Options:\n * @navigate('/users', 'main', {merge: false})                       // Explicit no merge\n * @navigate('/users', 'main', {only: ['search', 'category']})       // Only preserve specific\n * @navigate('/users', 'main', {except: ['page']})                   // Preserve except specific\n * @navigate('/users', 'main', {replace: true})                      // Replace instead of push\n *\n * Mixed Usage:\n * @navigate('/contacts', 'main', {queries: {search: $searchTerm}, merge: true})\n */\naction({\n    name: 'navigate',\n    apply: async (\n        ctx: ActionContext,\n        urlOrQueries: string | Record<string, any>,\n        key: string = 'true',\n        options: NavigateOptions = {}\n    ): Promise<void> => {\n        // Input validation\n        if (!urlOrQueries) {\n            throw ctx.error('NavigateUrlRequired', {\n                received: String(urlOrQueries),\n            })\n        }\n\n        if (typeof key !== 'string') {\n            throw ctx.error('NavigateKeyMustBeString', {\n                received: String(key),\n            })\n        }\n\n        try {\n            // Validate input URL has reasonable format before processing\n            // Check for obviously malformed URLs (e.g., unencoded spaces in path)\n            if (typeof urlOrQueries === 'string') {\n                // URLs with spaces in the path (not query string) are likely mistakes\n                if (/^[^?]*\\s/.test(urlOrQueries)) {\n                    console.error('URL contains unencoded spaces, likely invalid:', urlOrQueries)\n                    return // Gracefully abort for obviously malformed URLs\n                }\n            }\n\n            // Process the URL based on input type\n            const finalUrl = processNavigationInput(urlOrQueries, options)\n\n            // Final validation: ensure the processed URL is parseable\n            try {\n                new URL(finalUrl, window.location.origin)\n            } catch (urlError) {\n                console.error('Invalid URL for navigation:', finalUrl, urlError)\n                return // Gracefully abort navigation for invalid URLs\n            }\n\n            // Get the GET action from Datastar's action registry\n            // This is the proper Datastar way - actions call actions, not globals\n            const getAction = actions.get || actions.GET\n\n            if (!getAction) {\n                console.error(\n                    'GET action not available in Datastar actions registry. ' +\n                    'Navigation falling back to full page load.'\n                )\n                window.location.href = finalUrl\n                return\n            }\n\n            // Prepare fetch arguments with navigate headers\n            const fetchArgs = {\n                headers: {\n                    'HYPER-NAVIGATE': 'true',\n                    'HYPER-NAVIGATE-KEY': key,\n                },\n            }\n\n            // Call GET action using Datastar's infrastructure\n            // This sends the request with proper Datastar headers\n            await getAction(ctx, finalUrl, fetchArgs)\n\n            // Handle browser history (pushState or replaceState)\n            if (options.replace) {\n                history.replaceState(null, '', finalUrl)\n            } else {\n                history.pushState(null, '', finalUrl)\n            }\n        } catch (error) {\n            console.error('Navigate action failed:', error)\n\n            // Fallback to standard navigation only if URL is valid\n            try {\n                const fallbackUrl =\n                    typeof urlOrQueries === 'string'\n                        ? urlOrQueries\n                        : `${window.location.pathname}?${buildQueryString(\n                              urlOrQueries\n                          )}`\n\n                // Validate URL before attempting navigation\n                new URL(fallbackUrl, window.location.origin)\n                window.location.href = fallbackUrl\n            } catch (urlError) {\n                console.error('Invalid fallback URL, staying on current page:', urlError)\n                // Stay on current page for invalid URLs - fail gracefully\n            }\n        }\n    },\n})\n\n/**\n * Navigation options interface - matches both frontend and backend\n */\ninterface NavigateOptions {\n    merge?: boolean; // Whether to merge with existing query parameters\n    only?: string[]; // Only preserve these query parameters\n    except?: string[]; // Preserve all query parameters except these\n    replace?: boolean; // Use replaceState instead of pushState\n    queries?: Record<string, any>; // Additional queries to merge (when urlOrQueries is a path)\n}\n\n/**\n * Process navigation input based on type and options\n */\nfunction processNavigationInput(\n    urlOrQueries: string | Record<string, any>,\n    options: NavigateOptions\n): string {\n    if (typeof urlOrQueries === \"string\") {\n        // Traditional string URL\n        return processStringUrl(urlOrQueries, options);\n    } else {\n        // JSON query object\n        return processJsonQueries(urlOrQueries, options);\n    }\n}\n\n/**\n * Process traditional string URL with options\n */\nfunction processStringUrl(url: string, options: NavigateOptions): string {\n    // Handle additional queries option\n    if (options.queries && Object.keys(options.queries).length > 0) {\n        url = mergeQueriesIntoUrl(url, options.queries);\n    }\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(url, options.only, options.except);\n    }\n\n    return url;\n}\n\n/**\n * Process JSON query object into URL\n */\nfunction processJsonQueries(\n    queries: Record<string, any>,\n    options: NavigateOptions\n): string {\n    // Build base URL from current location\n    const currentPath = window.location.pathname;\n    const queryString = buildQueryString(queries);\n\n    const baseUrl = queryString ? `${currentPath}?${queryString}` : currentPath;\n\n    // Apply merge logic if specified\n    if (shouldApplyMerge(options)) {\n        return mergeQueryParameters(baseUrl, options.only, options.except);\n    }\n\n    return baseUrl;\n}\n\n/**\n * Determine if merge logic should be applied\n */\nfunction shouldApplyMerge(options: NavigateOptions): boolean {\n    // Explicit merge setting takes precedence\n    if (options.merge !== undefined) {\n        return options.merge;\n    }\n\n    // Implied merge when using only/except\n    if (options.only || options.except) {\n        return true;\n    }\n\n    // Default: no merge (explicit behavior)\n    return false;\n}\n\n/**\n * Build query string from object, handling various value types\n */\nfunction buildQueryString(queries: Record<string, any>): string {\n    const params = new URLSearchParams();\n\n    for (const [key, value] of Object.entries(queries)) {\n        if (value === null || value === undefined) {\n            // Skip null/undefined values\n            continue;\n        }\n\n        if (Array.isArray(value)) {\n            // Handle arrays (for multi-select, checkboxes, etc.)\n            value.forEach((item) => {\n                if (item !== null && item !== undefined && item !== \"\") {\n                    params.append(key, String(item));\n                }\n            });\n        } else if (value === \"\" || String(value).trim() === \"\") {\n            // Skip empty strings\n            continue;\n        } else {\n            // Handle primitive values\n            params.set(key, String(value));\n        }\n    }\n\n    return params.toString();\n}\n\n/**\n * Merge additional queries into existing URL\n */\nfunction mergeQueriesIntoUrl(\n    url: string,\n    additionalQueries: Record<string, any>\n): string {\n    try {\n        let targetUrl: URL;\n\n        if (url.startsWith(\"?\")) {\n            targetUrl = new URL(\n                `${window.location.pathname}${url}`,\n                window.location.origin\n            );\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n        } else {\n            targetUrl = new URL(url, window.location.origin);\n        }\n\n        // Add additional queries\n        for (const [key, value] of Object.entries(additionalQueries)) {\n            if (value === null || value === undefined || value === \"\") {\n                targetUrl.searchParams.delete(key);\n            } else if (Array.isArray(value)) {\n                targetUrl.searchParams.delete(key);\n                value.forEach((item) => {\n                    if (item !== null && item !== undefined && item !== \"\") {\n                        targetUrl.searchParams.append(key, String(item));\n                    }\n                });\n            } else {\n                targetUrl.searchParams.set(key, String(value));\n            }\n        }\n\n        return `${targetUrl.pathname}${targetUrl.search}`;\n    } catch (error) {\n        console.warn(\"Error merging queries into URL:\", error);\n        return url;\n    }\n}\n\n/**\n * Merge query parameters with current URL - consistent with attribute plugin\n */\nfunction mergeQueryParameters(\n    url: string,\n    only?: string[],\n    except?: string[]\n): string {\n    try {\n        const currentParams = new URLSearchParams(window.location.search);\n\n        let targetUrl: URL;\n        let targetPath: string;\n        let targetParams: URLSearchParams;\n\n        // Parse target URL (same logic as attribute plugin)\n        if (url.startsWith(\"?\")) {\n            targetPath = window.location.pathname;\n            targetParams = new URLSearchParams(url);\n        } else if (url.startsWith(\"http\")) {\n            targetUrl = new URL(url);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        } else {\n            const baseUrl = new URL(window.location.origin);\n            targetUrl = new URL(url, baseUrl);\n            targetPath = targetUrl.pathname;\n            targetParams = targetUrl.searchParams;\n        }\n\n        const mergedParams = new URLSearchParams();\n\n        // Step 1: Add current parameters (filtered by only/except)\n        for (const [key, value] of currentParams) {\n            const shouldInclude = only\n                ? only.includes(key)\n                : !except || !except.includes(key);\n\n            if (shouldInclude) {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 2: Add/override with target parameters\n        for (const [key, value] of targetParams) {\n            if (!value || value.trim() === \"\") {\n                mergedParams.delete(key);\n            } else {\n                mergedParams.set(key, value);\n            }\n        }\n\n        // Step 3: Build final URL\n        const queryString = mergedParams.toString();\n        return queryString ? `${targetPath}?${queryString}` : targetPath;\n    } catch (error) {\n        console.warn(\"Error merging query parameters:\", error);\n        return url;\n    }\n}\n\n/**\n * EXAMPLES FOR DOCUMENTATION:\n *\n * // Traditional string navigation\n * @navigate('/users')                                    // Clean navigation\n * @navigate('/users?active=true', 'main')               // With queries\n *\n * // JSON query navigation\n * @navigate({search: $searchTerm, page: 1})             // Pure queries\n * @navigate({category: 'work'}, 'filters')              // With key\n *\n * // Advanced options\n * @navigate('/users', 'main', {\n *   queries: {search: $searchTerm},\n *   merge: true,\n *   except: ['page']\n * })\n *\n * // Clear all queries\n * @navigate({})                                         // Clear everything\n * @navigate('/')                                        // Clean slate\n *\n * // Array handling\n * @navigate({tags: ['php', 'laravel'], status: 'active'})  // Multi-value params\n */\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/responseInterceptor.ts\n// Icon: material-symbols:intercept\n// Slug: Laravel response handling for Datastar\n// Description: Handles redirects, errors, and debug output while preserving standard Laravel responses\n\n/**\n * Response Interceptor - Laravel Integration for Datastar\n *\n * This module intercepts fetch responses to handle Laravel-specific behaviors that don't\n * fit Datastar's reactive model. It acts as a bridge between Laravel's traditional HTTP\n * responses and Datastar's reactive fetch system.\n *\n * KEY BEHAVIORS:\n * 1. Full-page redirects (301, 302, 303, 307, 308) â†’ window.location navigation\n * 2. Laravel error pages (404, 403, 500) â†’ Document replacement for visibility\n * 3. Debug output (dd/dump, Ignition, Whoops) â†’ Document replacement for inspection\n * 4. Standard responses (views, JSON) â†’ Pass through to Datastar for native handling\n *\n * PERFORMANCE OPTIMIZATION:\n * - No response body reading for success responses (200-399)\n * - Only error responses (400+) have bodies read and inspected\n * - No artificial delays - redirects happen immediately after cookie processing\n * - Minimal overhead for normal Datastar operation\n *\n * COOKIE HANDLING:\n * - All fetch requests include credentials: 'include' for session support\n * - Browser processes Set-Cookie headers automatically when response arrives\n * - No manual cookie manipulation needed\n *\n * DATASTAR COMPATIBILITY:\n * - Standard content-types (text/html, application/json) pass through unchanged\n * - SSE responses (text/event-stream) are never intercepted\n * - Hyper responses (X-Hyper-Response header) are never intercepted\n *\n * @module hyper-ext/backend/watchers/responseInterceptor\n */\n\n// Global flag to ensure setup runs only once\nlet interceptorSetup = false\n\n// Initialize response interceptor\nif (!interceptorSetup) {\n    interceptorSetup = true\n    setupResponseInterceptor()\n}\n\nfunction setupResponseInterceptor() {\n    const originalFetch = window.fetch\n\n    window.fetch = async (...args) => {\n        const [resource, init] = args\n        const requestUrl = getUrlFromResource(resource)\n\n        // Skip intercepting static assets and debugging tools\n        if (shouldSkipUrl(requestUrl)) {\n            return originalFetch(...args)\n        }\n\n        // CRITICAL: Include credentials for session cookie support\n        // Without this, fetch won't send or receive cookies, breaking Laravel sessions\n        const enhancedInit: RequestInit = {\n            ...init,\n            credentials: init?.credentials || 'include'\n        }\n\n        // Check if this is a Datastar request (has Datastar-Request header)\n        const isDatastarRequest =\n            (enhancedInit?.headers as Record<string, string>)?.[\n                'Datastar-Request'\n            ] === 'true' ||\n            (enhancedInit?.headers as Headers)?.get?.('Datastar-Request') ===\n                'true'\n\n        try {\n            const response = await originalFetch(resource, enhancedInit)\n\n            // PRIORITY 1: Handle redirects FIRST (301, 302, 303, 307, 308)\n            // Full page redirects must happen immediately to maintain expected browser behavior\n            if (isRedirectResponse(response, requestUrl)) {\n                const redirectUrl = getRedirectUrl(response)\n                if (redirectUrl && redirectUrl !== window.location.href) {\n                    // Cookies are already processed by browser at this point\n                    // Schedule redirect to allow any pending operations to complete\n                    setTimeout(() => {\n                        window.location.href = redirectUrl\n                    }, 300)\n\n                    // Stop all further processing to prevent errors during redirect\n                    throw new RedirectHandled()\n                }\n            }\n\n            // PRIORITY 2: Pass through Datastar-managed responses\n            // Let Datastar handle SSE, Hyper responses, and standard content types\n            if (shouldPassThroughToDatastar(response, isDatastarRequest)) {\n                return response\n            }\n\n            // PRIORITY 3: Handle Laravel special responses (errors, debug output)\n            // Only for non-Datastar requests or Laravel framework pages\n            if (shouldHandleLaravelResponse(response, isDatastarRequest)) {\n                await handleLaravelResponse(response)\n                return new Response('', { status: 200 })\n            }\n\n            // PRIORITY 4: Pass through everything else\n            return response\n        } catch (error) {\n            // Silently handle redirects - they are expected behavior\n            if (error instanceof RedirectHandled) {\n                // Return empty SSE response that Datastar can safely process\n                // This prevents console errors while redirect is scheduled\n                return new Response('', {\n                    status: 200,\n                    headers: {\n                        'Content-Type': 'text/event-stream'\n                    }\n                })\n            }\n\n            console.error('Network error:', error)\n            throw error\n        }\n    }\n}\n\n/**\n * Custom error class for redirect flow control\n * Used to stop code execution when redirect is scheduled\n */\nclass RedirectHandled extends Error {\n    constructor() {\n        super('Redirect handled')\n        this.name = 'RedirectHandled'\n    }\n}\n\n/**\n * Determine if response should pass through to Datastar\n *\n * Datastar natively handles:\n * - text/html â†’ patch-elements (patches HTML into DOM)\n * - application/json â†’ patch-signals (updates signals)\n * - text/event-stream â†’ SSE event processing\n * - text/javascript â†’ script execution\n *\n * @param response - The fetch response to check\n * @param isDatastarRequest - Whether this was initiated by Datastar\n * @returns True if Datastar should handle this response\n */\nfunction shouldPassThroughToDatastar(\n    response: Response,\n    isDatastarRequest: boolean\n): boolean {\n    if (!isDatastarRequest) return false\n\n    const contentType = response.headers.get('Content-Type') || ''\n\n    // Always pass through Hyper-managed responses\n    if (response.headers.get('X-Hyper-Response') === 'true') {\n        return true\n    }\n\n    // Always pass through SSE responses\n    if (contentType.includes('text/event-stream')) {\n        return true\n    }\n\n    // Pass through standard content types for success responses\n    const hasStandardContentType =\n        contentType.includes('text/html') ||\n        contentType.includes('application/json') ||\n        contentType.includes('text/javascript')\n\n    if (hasStandardContentType && response.status >= 200 && response.status < 400) {\n        return true\n    }\n\n    return false\n}\n\n/**\n * Determine if response needs special Laravel handling\n *\n * Handles:\n * - Error pages (404, 403, 500) with HTML content\n * - Debug pages (dd/dump output)\n * - Exception pages (Ignition, Whoops)\n *\n * @param response - The fetch response to check\n * @param isDatastarRequest - Whether this was initiated by Datastar\n * @returns True if this needs Laravel-specific handling\n */\nfunction shouldHandleLaravelResponse(\n    response: Response,\n    isDatastarRequest: boolean\n): boolean {\n    const contentType = response.headers.get('Content-Type') || ''\n\n    // Never handle SSE or Hyper responses\n    if (\n        contentType.includes('text/event-stream') ||\n        response.headers.get('X-Hyper-Response') === 'true'\n    ) {\n        return false\n    }\n\n    // Handle error status codes with HTML content (404, 403, 500, etc.)\n    if (response.status >= 400 && contentType.includes('text/html')) {\n        return true\n    }\n\n    // Handle debug pages in non-Datastar contexts\n    if (\n        response.status >= 200 &&\n        response.status < 400 &&\n        contentType.includes('text/html') &&\n        !isDatastarRequest\n    ) {\n        return true\n    }\n\n    return false\n}\n\n/**\n * Handle Laravel special responses (errors, debug output)\n *\n * PERFORMANCE: Only reads response body for error responses (400+)\n * Success responses (200-399) pass through without body reading\n *\n * @param response - The fetch response to handle\n */\nasync function handleLaravelResponse(response: Response): Promise<void> {\n    // Only process error responses\n    if (response.status < 400) return\n\n    const contentType = response.headers.get('Content-Type') || ''\n\n    // Only process HTML error responses\n    if (!contentType.includes('text/html')) return\n\n    try {\n        const html = await response.clone().text()\n        if (isLaravelSpecialResponse(html)) {\n            replaceDocument(html)\n        }\n    } catch (error) {\n        console.error('Error reading response body:', error)\n    }\n}\n\n/**\n * Check if response is a redirect (301, 302, 303, 307, 308)\n *\n * @param response - The fetch response to check\n * @param originalUrl - The original request URL\n * @returns True if this is a redirect response\n */\nfunction isRedirectResponse(response: Response, originalUrl: string): boolean {\n    return (\n        [301, 302, 303, 307, 308].includes(response.status) ||\n        (response.url && response.url !== originalUrl) ||\n        !!response.headers.get('Location')\n    )\n}\n\n/**\n * Extract redirect URL from response\n *\n * @param response - The fetch response\n * @returns The redirect URL or null\n */\nfunction getRedirectUrl(response: Response): string | null {\n    let redirectUrl = response.url || response.headers.get('Location')\n\n    if (!redirectUrl) return null\n\n    // Convert relative URLs to absolute\n    if (redirectUrl.startsWith('/')) {\n        redirectUrl = window.location.origin + redirectUrl\n    }\n\n    return redirectUrl\n}\n\n/**\n * Detect Laravel special responses requiring document replacement\n *\n * Checks for:\n * - Laravel error handlers (Ignition, Whoops)\n * - Debug output (dd, dump, var_dump)\n * - Standard Laravel error views (404, 403, 500)\n *\n * @param html - The HTML content to check\n * @returns True if this is a Laravel special response\n */\nfunction isLaravelSpecialResponse(html: string): boolean {\n    // Laravel error handlers\n    if (\n        html.includes('ignition-') ||\n        html.includes('data-ignition') ||\n        html.includes('Whoops\\\\') ||\n        html.includes('whoops-container') ||\n        (html.includes('Illuminate\\\\') && html.includes('Exception'))\n    ) {\n        return true\n    }\n\n    // Laravel debug output\n    if (\n        html.includes('sf-dump') ||\n        html.includes('var-dump') ||\n        html.includes('symfony-var-dumper') ||\n        html.includes('dump-container')\n    ) {\n        return true\n    }\n\n    // Laravel error views\n    if (\n        html.includes('<!DOCTYPE html>') &&\n        (html.includes('<title>404') ||\n            html.includes('<title>403') ||\n            html.includes('<title>500') ||\n            html.includes('<title>503') ||\n            html.includes('<title>Server Error') ||\n            html.includes('<title>Page Not Found') ||\n            html.includes('<title>Forbidden') ||\n            html.includes('<title>Service Unavailable'))\n    ) {\n        return true\n    }\n\n    return false\n}\n\n/**\n * Replace current document with new HTML content\n *\n * Used for displaying Laravel error pages and debug output\n * that need full document context to render properly\n *\n * @param html - The HTML content to display\n */\nfunction replaceDocument(html: string): void {\n    try {\n        const parser = new DOMParser()\n        const newDoc = parser.parseFromString(html, 'text/html')\n\n        document.documentElement.innerHTML = newDoc.documentElement.innerHTML\n\n        if (newDoc.title) {\n            document.title = newDoc.title\n        }\n\n        executeNewScripts()\n    } catch (error) {\n        console.error('Failed to replace document:', error)\n        window.location.reload()\n    }\n}\n\n/**\n * Execute scripts in newly inserted document\n *\n * Scripts inserted via innerHTML don't execute automatically\n * This recreates them to enable proper execution\n */\nfunction executeNewScripts(): void {\n    const scripts = document.querySelectorAll('script:not([data-executed])')\n\n    scripts.forEach((element) => {\n        const oldScript = element as HTMLScriptElement\n        oldScript.setAttribute('data-executed', 'true')\n\n        const newScript = document.createElement('script')\n        Array.from(oldScript.attributes).forEach((attr) => {\n            newScript.setAttribute(attr.name, attr.value)\n        })\n\n        if (oldScript.src) {\n            newScript.src = oldScript.src\n        } else {\n            newScript.textContent = oldScript.textContent\n        }\n\n        if (oldScript.parentNode) {\n            oldScript.parentNode.replaceChild(newScript, oldScript)\n        }\n    })\n}\n\n/**\n * Extract URL string from fetch resource parameter\n *\n * @param resource - The fetch resource (string, URL, or Request)\n * @returns The URL as a string\n */\nfunction getUrlFromResource(resource: RequestInfo | URL): string {\n    if (typeof resource === 'string') return resource\n    if (resource instanceof URL) return resource.href\n    if (resource instanceof Request) return resource.url\n    return String(resource)\n}\n\n/**\n * Check if URL should be skipped from interception\n *\n * Prevents intercepting static assets and debugging tools\n * to avoid infinite loops and performance issues\n *\n * @param url - The URL to check\n * @returns True if this URL should be skipped\n */\nfunction shouldSkipUrl(url: string): boolean {\n    const skipPatterns = [\n        '_boost/browser-logs',\n        '_boost/',\n        '_debugbar/',\n        '_ignition/',\n        'telescope/',\n        'horizon/',\n        '.js',\n        '.css',\n        '.png',\n        '.jpg',\n        '.jpeg',\n        '.gif',\n        '.svg',\n        '.ico',\n        '.woff',\n        '.woff2',\n        '.ttf',\n        '.eot',\n    ]\n\n    return skipPatterns.some((pattern) => url.includes(pattern))\n}\n","// packages/dancycodes/hyper-front/src/hyper-ext/plugins/backend/watchers/globalNavigate.ts\n// Icon: material-symbols:public\n// Slug: Browser navigation infrastructure (back/forward button support)\n// Description: Handles browser history events for SPA-like navigation\n\nimport { actions } from '@engine'\n\n// Global flag to ensure this runs only once\nlet globalNavigateSetup = false\n\n/**\n * GlobalNavigate Setup - Pure Datastar Integration\n *\n * This module provides ONLY internal infrastructure for navigation:\n * - Handles browser back/forward buttons (popstate events)\n * - NO window.* global pollution\n * - ALL navigation happens through @navigate action\n *\n * Philosophy: Datastar-pure, zero globals, action-driven\n *\n * This runs as a side-effect when the module is imported (in the bundle)\n */\n\n// Initialize navigation infrastructure\nif (!globalNavigateSetup) {\n    globalNavigateSetup = true\n    setupPopstateHandler()\n    setupBackendNavigateHandler()\n}\n\n/**\n * Set up popstate handler for browser back/forward navigation\n *\n * When user clicks browser back/forward buttons, intercept and use\n * Datastar navigation instead of full page reload\n */\nfunction setupPopstateHandler() {\n    window.addEventListener('popstate', function (event) {\n        // If no state, do full reload\n        if (!event.state) {\n            window.location.reload()\n            return\n        }\n\n        // Get the navigate action from Datastar's action registry\n        const navigateAction = actions.navigate\n\n        if (navigateAction) {\n            // Create minimal context for internal action call\n            const navigateCtx = {\n                el: document.body,\n                error: (name: string, ctx?: Record<string, any>) => {\n                    const err = new Error(`Navigation Error: ${name}`)\n                    console.error(err, ctx)\n                    return err\n                },\n            }\n\n            // Call @navigate action internally\n            // This maintains consistency - all navigation goes through one action\n            navigateAction(\n                navigateCtx,\n                window.location.href,\n                'popstate'\n            )\n        } else {\n            // Fallback to full reload if navigate action not available\n            console.warn(\n                'Navigate action not found. Falling back to page reload.'\n            )\n            window.location.reload()\n        }\n    })\n}\n\n/**\n * Set up backend navigate handler\n *\n * Listens for custom 'hyper:navigate' events dispatched by backend responses\n * and triggers the navigate action. This enables backend-initiated navigation\n * without polluting window namespace.\n */\nfunction setupBackendNavigateHandler() {\n    document.addEventListener('hyper:navigate', function (event: any) {\n        const { url, key, options } = event.detail\n\n        // Get the navigate action from Datastar's action registry\n        const navigateAction = actions.navigate\n\n        if (navigateAction) {\n            // Create minimal context for internal action call\n            const navigateCtx = {\n                el: document.body,\n                error: (name: string, ctx?: Record<string, any>) => {\n                    const err = new Error(`Navigation Error: ${name}`)\n                    console.error(err, ctx)\n                    return err\n                },\n            }\n\n            // Call navigate action with backend-provided parameters\n            navigateAction(navigateCtx, url, key || 'true', options || {})\n        } else {\n            // Fallback to full page navigation if navigate action not available\n            console.warn(\n                'Navigate action not found. Falling back to window.location.'\n            )\n            window.location.href = url\n        }\n    })\n}\n\n/**\n * MIGRATION NOTES:\n *\n * Old approach (REMOVED):\n * - window.hyperNavigate() - 15+ global functions\n * - window.hyperNavigateMerge()\n * - window.hyperNavigateClean()\n * - window.hyperNavigateOnly()\n * - window.hyperNavigateExcept()\n * - window.hyperNavigateReplace()\n * - window.hyperBack()\n * - window.hyperRefresh()\n * - window.hyperUpdateQueries()\n * - window.hyperClearQueries()\n * - window.hyperResetPagination()\n * - window.hyperReload()\n * - window.hyperDebugNavigation()\n *\n * New approach (Datastar-pure):\n * - @navigate(url, key?, options?) - ONE action handles everything (frontend)\n * - Custom DOM event 'hyper:navigate' for backend-initiated navigation\n * - @back(fallback?, key?) - Optional convenience action\n * - @refresh(key?) - Optional convenience action\n * - @reload() - Optional hard refresh action\n *\n * All navigation functionality consolidated into the action system.\n * Zero global pollution. Pure Datastar integration.\n */\n","// Hyper Bundle - Complete Datastar + Laravel Extensions\n// This bundles all Datastar core functionality with Laravel-specific extensions\n\nimport { apply } from '../../datastar/engine/engine'\n\n// Datastar Core Actions\nimport '../../datastar/plugins/actions/peek'\nimport '../../datastar/plugins/actions/setAll'\nimport '../../datastar/plugins/actions/toggleAll'\nimport '../../datastar/plugins/actions/fetch'\n\n// Datastar Core Attributes\nimport '../../datastar/plugins/attributes/attr'\nimport '../../datastar/plugins/attributes/bind'\nimport '../../datastar/plugins/attributes/class'\nimport '../../datastar/plugins/attributes/computed'\nimport '../../datastar/plugins/attributes/effect'\nimport '../../datastar/plugins/attributes/indicator'\nimport '../../datastar/plugins/attributes/jsonSignals'\nimport '../../datastar/plugins/attributes/on'\nimport '../../datastar/plugins/attributes/onIntersect'\nimport '../../datastar/plugins/attributes/onInterval'\nimport '../../datastar/plugins/attributes/init'\nimport '../../datastar/plugins/attributes/onSignalPatch'\nimport '../../datastar/plugins/attributes/ref'\nimport '../../datastar/plugins/attributes/show'\nimport '../../datastar/plugins/attributes/signals'\nimport '../../datastar/plugins/attributes/style'\nimport '../../datastar/plugins/attributes/text'\n\n// Datastar Core Watchers\nimport '../../datastar/plugins/watchers/patchElements'\nimport '../../datastar/plugins/watchers/patchSignals'\n\n// Hyper Actions\nimport '../plugins/actions/dispatch'\nimport '../plugins/actions/fileUrl'\nimport '../plugins/actions/back'\nimport '../plugins/actions/refresh'\nimport '../plugins/actions/reload'\n\n// Hyper Attributes\nimport '../plugins/attributes/error'\nimport '../plugins/attributes/for'\nimport '../plugins/attributes/if'\nimport '../plugins/attributes/navigate'\n\n// Hyper Backend Actions (CSRF-protected)\nimport '../plugins/backend/actions/postx'\nimport '../plugins/backend/actions/putx'\nimport '../plugins/backend/actions/patchx'\nimport '../plugins/backend/actions/deletex'\nimport '../plugins/backend/actions/navigate'\n\n// Hyper Backend Watchers/Infrastructure\nimport '../plugins/backend/watchers/responseInterceptor'\nimport '../plugins/backend/watchers/globalNavigate'\n\n// Apply Datastar to the DOM\napply()\n\n// Export utilities for advanced usage\nexport { apply }\nexport { action, actions, attribute, watcher } from '../../datastar/engine/engine'\n"],"names":["effect","signal","link","prevSub","path","attribute","cleanup","root","action","args","fn","error","url","evt","name","response","overrides","key","update","el","type","value","syncSignal","watcher","apply","mimeType","sourceData","delay","scripts"],"mappings":"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"}